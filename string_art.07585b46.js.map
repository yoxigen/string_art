{"mappings":"I+BsBI,E9BwBA,EKlCG,SAAU,EACf,CAAiC,CACjC,CAA6B,EAM7B,IAAI,EAAQ,EAEZ,IAAK,IAAM,KAAW,EACpB,KAAM,CAAE,QAAA,EAAS,MAAA,EAAO,OAAA,CAAO,EAC3B,EAAQ,QAAQ,EAClB,CAAA,MAAO,EAAe,EAAQ,QAAQ,CAAE,CAAE,QAAA,EAAS,OAAA,EAAQ,MAAA,CAAM,EAAA,EAEnE,GAEJ,CAsBO,SAAS,EACd,CAA+B,CAC/B,CAAqB,EAErB,IAAM,EAAO,EAAc,IAAI,CAC/B,GAAI,CAAC,EACH,OAAO,EAGT,IAAM,EAAW,CAAE,GAAG,CAAI,AAAC,EAE3B,OADA,OAAO,CAAQ,CAAC,EAAc,CACvB,CACL,GAAG,CAAa,CAChB,KAAM,CACR,CACF,CAOO,SAAS,EACd,CAAiC,EAEjC,OAAO,EAAe,GAAG,CAAC,AAAA,IACxB,IAAM,EAAO,CAAE,GAAG,CAAO,AAAC,EAQ1B,OAPI,EAAQ,QAAQ,EAClB,CAAA,EAAK,QAAQ,CAAG,EAAW,EAAQ,QAAQ,CAAA,EAEzC,EAAQ,IAAI,EACd,CAAA,EAAK,IAAI,CAAG,CAAE,GAAG,EAAQ,IAAI,AAAC,CAAA,EAGzB,CACT,EACF,CAyBO,SAAS,EACd,CAAiC,CACjC,CAAsB,CACtB,CAAyC,EAEzC,IAAM,EAAa,EAAW,GACxB,EAAiB,AA1EzB,SACE,CAAiC,CACjC,CAAkB,MAblB,EAe6C,CAAC,CAAA,IAAE,CAAG,CAAE,GAAK,IAAQ,EAblE,IAAK,IAAM,KAAQ,EAaU,GAZ3B,GAAI,EAAO,EAAK,OAAO,EACrB,OAAO,EAIX,OAAO,IAQT,EAqEmD,EAAY,GAE7D,GAAI,EAAgB,CAClB,GAAM,CAAA,MAAE,CAAK,CAAA,OAAE,CAAM,CAAE,CAAG,EAG1B,MADA,AADW,CAAA,GAAQ,QAAQ,UAAY,CAAvC,EACK,MAAM,CAAC,EAAQ,EAAG,KAAM,GACtB,CACT,CAEA,OAAO,CACT,CCcA,IAAA,EA3IoD,CAClD,CACE,IAAK,eACL,MAAO,sBACP,aAAc,CAAA,EACd,KAAM,UACR,EACA,CACE,IAAK,aACL,MAAO,eACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,GACL,KAAM,CACR,EACA,KAAM,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,CAC9B,EACA,CACE,IAAK,QACL,MAAO,eACP,aAAc,UACd,KAAM,QACN,KAAM,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,CAAC,CAC/B,EACA,CACE,IAAK,kBACL,MAAO,mBACP,aAAc,EACd,KAAM,MACN,KAAM,CACJ,WAAY,CAAA,CACd,EACA,KAAM,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,CAC9B,EACA,CACE,IAAK,kBACL,MAAO,mBACP,aAAc,IACd,KAAM,MACN,KAAM,CACJ,MAAO,CAAC,CAAA,gBAAE,CAAe,CAAE,GAAK,EAChC,KAAM,OACR,EACA,KAAM,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,CAC9B,EACA,CACE,IAAK,aACL,MAAO,aACP,aAAc,IACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,IACL,KAAM,CACR,EACA,KAAM,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,CAC9B,EACA,CACE,IAAK,YACL,MAAO,YACP,KAAM,QACN,aAAc,YACd,KAAM,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,EAC5B,SAAU,CACR,CACE,IAAK,wBACL,MAAO,kBACP,aAAc,CAAA,EACd,KAAM,WACN,KAAM,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,CAC9B,EACA,CACE,IAAK,eACL,MAAO,oBACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,IACL,KAAM,EACN,KAAM,KACN,WAAY,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,CAAC,QAAQ,EAAE,EAAa,CAAC,CAAC,CAC5D,WAAY,yCACd,EACA,KAAM,CAAC,CAAA,sBAAE,CAAqB,CAAA,aAAE,CAAY,CAAE,GAC5C,GAAyB,CAC7B,EACA,CACE,IAAK,eACL,MAAO,oBACP,aAAc,IACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,IACL,KAAM,EACN,KAAM,KACN,WAAY,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,CAAC,QAAQ,EAAE,EAAa,CAAC,CAAC,CAC5D,WAAY,yCACd,EACA,KAAM,CAAC,CAAA,sBAAE,CAAqB,CAAA,aAAE,CAAY,CAAE,GAC5C,GAAyB,CAC7B,EACD,AACH,EACA,CACE,IAAK,kBACL,KAAM,QACN,MAAO,QACP,aAAc,YACd,KAAM,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,EAC5B,SAAU,CACR,CACE,IAAK,gBACL,MAAO,uBACP,aAAc,CAAA,EACd,KAAM,WACN,KAAM,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,CAC9B,EACA,CACE,IAAK,eACL,MAAO,gBACP,aAAc,CAAA,EACd,KAAM,WACN,KAAM,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,CAC9B,EACA,CACE,IAAK,eACL,MAAO,gBACP,aAAc,CAAA,EACd,KAAM,WACN,KAAM,CAAC,CAAA,aAAE,CAAY,CAAA,aAAE,CAAY,CAAE,GAAK,GAAgB,CAC5D,EACD,AACH,EACD,AFvIc,OAAA,EACb,MAAoB,AACpB,CAAA,cAAuB,AACvB,CAAA,uBAAgC,AAChC,CAAA,MAA0B,AAE1B,aAAY,CAAmB,CAAE,CAC/B,IAAI,CAAC,MAAM,CAAG,EAEd,GAAM,CAAA,gBACJ,CAAe,CAAA,WACf,CAAU,CAAA,sBACV,CAAqB,CAAA,aACrB,EAAe,CAAA,CAAA,aACf,EAAe,GAAA,CAAA,gBACf,CAAe,CAAA,SACf,CAAQ,CAAA,WACR,CAAU,CAAA,cACV,CAAa,CAAA,aACb,CAAY,CAAA,aACZ,CAAY,CAAA,aACZ,CAAY,CACb,CAAG,EAEJ,GAAI,EAAc,CAiBhB,GAhBA,IAAI,CAAC,cAAc,CAAG,EAAkB,KAAK,GAAG,CAAC,EAAG,EAAa,GACjE,IAAI,CAAC,uBAAuB,CAAG,EAC1B,AAAA,CAAA,EAAe,CAAA,EAAiB,CAAA,KAAK,GAAG,CAAC,EAAY,GAAK,CAAA,EAC3D,EAEJ,IAAI,CAAC,MAAM,CAAG,AAAI,MAAM,GAAY,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,EAAG,KACrD,IAAM,EAAY,EACd,EAAe,IAAI,CAAC,uBAAuB,CAAG,EAC9C,EACA,GACA,GACJ,MAAO,CAAC,IAAI,EACV,EAAkB,EAAa,IAAI,CAAC,cAAc,CACnD,EAAE,EAAE,EAAW,GAAG,EAAE,EAAU,EAAE,CAAC,AACpC,GAEI,GAAgB,EAAc,CAChC,GAAM,CAAC,EAAa,GAAG,EAAW,CAAG,IAAI,CAAC,MAAM,CAChD,EAAW,GAAG,GACd,IAAI,CAAC,MAAM,CAAG,IAAI,IAAI,CAAC,MAAM,IAAK,EAAW,OAAO,GAAG,AACzD,CAEI,GACF,IAAI,CAAC,MAAM,CAAC,OAAO,EAEvB,CACF,CAOA,SAAS,CAAkB,CAAc,CACvC,GAAM,CAAA,aAAE,CAAY,CAAA,WAAE,CAAU,CAAA,MAAE,CAAK,CAAA,aAAE,CAAY,CAAE,CAAG,IAAI,CAAC,MAAM,QAErE,AAAK,GAID,GAAc,GAChB,CAAA,EAAa,EACT,EAAa,IAAI,CAAC,MAAM,CAAC,MAAM,CAC/B,IAAI,CAAC,MAAM,CAAC,MAAM,CAAG,CAAA,EAGpB,IAAI,CAAC,MAAM,CAAC,EAAW,EATrB,CAUX,CAKA,OAAO,iBAAiB,CAAoB,CAAc,CACxD,IAAM,EAAW,EAAS,KAAK,CAC7B,0DAEF,GAAI,EAAU,CACZ,IAAM,EAAe,AAAA,CAAA,OAAO,CAAQ,CAAC,EAAE,EAAI,GAAA,EAAO,IAClD,MAAO,CAAC,IAAI,EAAE,EAAY,EAAE,EAAE,CAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,CAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,AAC9D,CAEA,OAAO,IACT,CAEA,YAAY,CAAA,UACV,CAAS,CAAA,WACT,CAAU,CAIX,CAAY,CACX,GAAI,CAAC,EACH,MAAM,AAAI,MAAM,gDAElB,IAAM,EAAgB,KAAK,KAAK,CAAC,EAAY,GACvC,EAAW,IAAI,IACrB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAY,IAC9B,EAAS,GAAG,CAAC,EAAI,EAAe,IAAI,CAAC,QAAQ,CAAC,IAEhD,OAAO,CACT,CAEA,OAAO,UAA8B,CAAA,QACnC,CAAO,CAAA,QACP,CAAO,CAAA,SACP,EAAW,CAAC,CAAA,CAAA,eACZ,CAAc,CAAA,WACd,CAAU,CAAA,WACV,CAAU,CAAA,cACV,CAAa,CAWb,CAA8C,CAG9C,MAAO,CACL,IAAK,aACL,MAAO,GAAc,QACrB,KAAM,QACN,SAAU,IAAK,GAAkB,EAAE,IANpB,ACKd,SAAS,EACd,CAAiC,CACjC,CAA2E,EAE3E,OAAO,EACH,EAAe,GAAG,CAAC,AAAA,IACb,EAAQ,QAAQ,EAClB,CAAA,EAAU,CACR,GAAG,CAAO,CACV,SAAU,EAAY,EAAQ,QAAQ,CAAE,EAC1C,CAAA,EAGK,CACL,GAAG,CAAO,CACV,GAAG,EAAkB,EAAQ,AAC/B,IAEF,CACN,EDxBiC,AAS7B,SAAS,EACP,CAA4C,EAE5C,MAAQ,AAAA,CAAA,GAAkB,AAAA,EAAW,EAAa,EAC/C,MAAM,CACL,CAAC,CAAA,IAAE,CAAG,CAAE,GACL,AAAA,CAAA,CAAC,GAAW,CAAC,EAAQ,QAAQ,CAAC,EAAA,GAC9B,CAAA,CAAC,GAAW,EAAQ,QAAQ,CAAC,EAAA,GAEjC,GAAG,CAAC,AAAA,IACH,IAAM,EAAe,CACnB,GAAG,CAAO,CACV,aAAc,CAAQ,CAAC,EAAQ,GAAG,CAAC,EAAI,EAAQ,YAAY,AAC7D,EAUA,MARI,AAAiB,UAAjB,EAAQ,IAAI,EACd,CAAA,EAAa,QAAQ,CAAG,EAAY,EAAQ,QAAQ,CAAA,EAGlD,AAAgB,eAAhB,EAAQ,GAAG,EAAqB,GAClC,CAAA,EAAa,IAAI,CAAC,GAAG,CAAG,CAD1B,EAIO,OAAO,MAAM,CAAC,EACvB,EACJ,IAlC4C,GAMQ,AACpD,CA4BF,CACF,CI5JA,MAAM,EAAsC,CAC1C,MAAO,UACP,SAAU,GACV,OAAQ,IACR,cAAe,CAAA,EACf,OAPoB,CAQtB,CAEe,OAAA,EACb,WAAqB,EAAgB,MAAM,AAAC,AAC5C,CAAA,WAAyB,EAAgB,KAAK,AAAC,AAC/C,CAAA,oBAA8B,EAAgB,QAAQ,AAAC,AACvD,CAAA,KAAmB,AACnB,CAAA,WAAyB,AAEzB,EAAA,CAAW,CAAiB,EAAE,AAAC,AAE/B,aAAY,CAAmB,CAAE,CAC/B,IAAI,CAAC,SAAS,CAAC,GACf,IAAI,CAAC,KAAK,CAAG,EAAE,CACf,IAAI,CAAC,WAAW,CAAG,IAAI,GACzB,CAEA,UAAU,CAAA,WAAE,CAAU,CAAA,WAAE,CAAU,CAAA,oBAAE,CAAmB,CAAe,CAAE,CACtE,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,mBAAmB,CAAG,EAC3B,IAAI,CAAC,KAAK,CAAG,EAAE,CACX,IAAI,CAAC,WAAW,EAClB,IAAI,CAAC,WAAW,CAAC,KAAK,EAE1B,CAGA,QAAQ,CAAU,CAAE,CAClB,IAAM,EAAY,EAAK,KAAK,CAAC,GAAG,CAAC,KAAK,KAAK,EAAE,IAAI,CAAC,KAC7C,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,KACxB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAChB,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAEzB,CAEA,SAAS,CAA0B,CAAE,CAAoC,CAAE,CACzE,IAAI,CAAC,CAAA,CAAW,CAAC,IAAI,CAAC,CAAE,MAAA,EAAO,QAAA,CAAQ,EACzC,CAEA,CAAA,CAAO,CACL,CAAkB,CAClB,CAA0B,CAC1B,CAA2B,EAE3B,EAAS,WAAW,CAAC,EAAO,CAC1B,GAAG,CAAe,CAClB,GAAG,CAAO,AACZ,EACF,CAEA,KAAK,CAAkB,CAAE,CAAA,YAAE,EAAc,CAAA,CAAA,CAAM,CAAG,CAAC,CAAC,CAAE,CACpD,IAAM,EAA8B,CAClC,MAAO,IAAI,CAAC,UAAU,CACtB,SAAU,IAAI,CAAC,mBAAmB,CAClC,OAAQ,IAAI,CAAC,UAAU,CACvB,cAAe,CACjB,EAEA,IAAI,CAAC,CAAA,CAAO,CAAC,EAAU,IAAI,CAAC,KAAK,CAAE,GAEnC,IAAI,CAAC,KAAK,CAAG,EAAE,CACf,IAAI,CAAC,WAAW,CAAC,KAAK,GAEtB,IAAI,CAAC,CAAA,CAAW,CAAC,OAAO,CAAC,CAAC,CAAE,MAAO,CAAU,CAAE,QAAS,CAAW,CAAE,IACnE,IAAI,CAAC,CAAA,CAAO,CAAC,EAAU,EAAY,CACjC,GAAG,CAAO,CACV,GAAG,CAAW,AAChB,EACF,GAEA,IAAI,CAAC,CAAA,CAAW,CAAG,EAAE,AACvB,CACF,CD3EA,QACQ,UAQF,EAAyC,CAC7C,CACE,IAAK,UACL,MAAO,UACP,KAAM,QACN,aAAc,YACd,SAAU,CACR,CACE,IAAK,cACL,MAAO,eACP,aAAc,CAAA,EACd,KAAM,WACN,WAAY,CAAC,CAAA,UAAE,CAAS,CAAE,GAAK,CAAC,CAClC,EACA,CACE,IAAK,cACL,MAAO,eACP,aAAc,EACd,KAAM,QACN,KAAM,CAAE,IAAK,GAAK,IAAK,EAAG,KAAM,GAAK,KAAM,GAAI,EAC/C,KAAM,CAAC,CAAA,YAAE,CAAW,CAAE,GAAK,CAC7B,EACD,AACH,EACA,CACE,IAAK,QACL,MAAO,QACP,KAAM,QACN,aAAc,YACd,SAAU,CACR,CACE,IAAK,YACL,MAAO,aACP,aAAc,CAAA,EACd,KAAM,WACN,WAAY,CAAC,CAAA,YAAE,CAAW,CAAE,GAAK,CAAC,CACpC,EACA,CACE,IAAK,kBACL,MAAO,oBACP,aAAc,CAAA,EACd,KAAM,WACN,KAAM,CAAC,CAAA,UAAE,CAAS,CAAE,GAAK,CAC3B,EACA,CACE,IAAK,sBACL,MAAO,yBACP,aAAc,GACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,GAAI,KAAM,EAAI,EACnC,aAAc,CAAC,CAAA,oBAAE,CAAmB,CAAE,GAAK,CAAA,EAAG,EAAoB,EAAE,CAAC,CACrE,KAAM,CAAC,CAAA,UAAE,CAAS,CAAA,gBAAE,CAAe,CAAE,GAAK,GAAa,CACzD,EACA,CACE,IAAK,SACL,MAAO,SACP,aAAc,GACd,KAAM,SACN,KAAM,CAAE,IAAK,EAAG,IAAK,IAAK,KAAM,CAAE,EAClC,aAAc,CAAC,CAAA,OAAE,CAAM,CAAE,GAAK,CAAA,EAAG,EAAO,EAAE,CAAC,AAC7C,EACA,CACE,IAAK,aACL,MAAO,YACP,aAAc,IACd,KAAM,QACN,KAAM,CAAE,IAAK,GAAK,IAAK,EAAG,KAAM,IAAM,KAAM,KAAM,EAClD,KAAM,CAAC,CAAA,UAAE,CAAS,CAAE,GAAK,CAC3B,EACA,CACE,IAAK,aACL,MAAO,cACP,aAAc,UACd,KAAM,QACN,KAAM,CAAC,CAAA,UAAE,CAAS,CAAE,GAAK,CAC3B,EACD,AACH,EACA,CACE,IAAK,aACL,MAAO,aACP,KAAM,QACN,aAAc,YACd,SAAU,CACR,CACE,IAAK,WACL,MAAO,YACP,aAAc,CAAA,EACd,KAAM,WACN,WAAY,CAAC,CAAA,iBAAE,CAAgB,CAAE,GAAK,CAAC,CACzC,EACA,CACE,IAAK,wBACL,MAAO,0BACP,aAAc,CAAA,EACd,KAAM,WACN,WAAY,CAAC,CAAA,iBAAE,CAAgB,CAAE,GAAK,CAAC,CACzC,EACA,CACE,IAAK,kBACL,MAAO,mBACP,YAAA,GACA,KAAM,QACN,KAAM,CAAC,CAAA,sBAAE,CAAqB,CAAE,GAAK,EACrC,WAAY,CAAC,CAAA,iBAAE,CAAgB,CAAE,GAAK,CAAC,CACzC,EACA,CACE,IAAK,mBACL,MAAO,oBACP,aAAc,CAAA,EACd,KAAM,UACR,EACD,AACH,EACD,CA0RD,IAAA,EAxRA,MACE,QAAsC,AACtC,CAAA,SAAoC,EAAE,AAAC,AACvC,CAAA,cAA0C,CAAC,CAAE,AAC7C,CAAA,UAA2B,IAAK,AAChC,CAAA,KAAmB,IAAK,AACxB,CAAA,OAAsB,IAAK,AAC3B,CAAA,MAAe,IAAK,AACpB,CAAA,SAAmB,CAAE,AACrB,CAAA,eAAgC,AAEhC,CAAA,EAAW,AACX,CAAA,IAAa,AACb,CAAA,IAAa,AACb,CAAA,QAAiB,AAEjB,EAAA,CAAO,AAAkB,AACzB,EAAA,CAAc,AAAgD,AAC9D,EAAA,CAAc,AAAyB,AAGvC,aAAY,CAAmB,CAAE,CAC/B,IAAI,CAAC,QAAQ,CAAG,CAClB,CAMA,OAAO,eAAiC,AACxC,QAAO,IAAa,AAEpB,CAAA,mBAA2D,CACzD,OAAO,CACT,CAEA,IAAI,gBAA0C,CAC5C,MAAQ,AAAA,CAAA,IAAI,CAAC,QAAQ,EAAI,EAAE,AAAF,EAAI,MAAM,CAAC,IAAI,CAAC,iBAAiB,GAC5D,CAEA,IAAI,eAA+D,CAKjE,OAJI,AAAC,IAAI,CAAC,CAAA,CAAc,EACtB,CAAA,IAAI,CAAC,CAAA,CAAc,CAAG,AFArB,SACL,CAAiC,EAEjC,IAAM,EAAc,CAAC,EACrB,IAAK,GAAM,CAAA,QAAE,CAAO,CAAE,GAAI,EAAe,GACvC,CAAW,CAAC,EAAQ,GAAG,CAAC,CAAG,EAG7B,OAAO,CACT,EETsD,IAAI,CAAC,cAAc,CAAA,EAG9D,IAAI,CAAC,CAAA,CAAc,AAC5B,CAEA,IAAI,MAAe,CACjB,OAAQ,IAAI,CAAC,WAAW,CAA2B,IAAI,AACzD,CAKA,IAAI,YAAsB,CACxB,OAAO,IAAI,CAAC,IAAI,GAAK,IAAI,CAAC,EAAE,AAC9B,CAEA,IAAI,eAAiC,CAUnC,OATI,AAAC,IAAI,CAAC,CAAA,CAAc,EACtB,CAAA,IAAI,CAAC,CAAA,CAAc,CAAG,OAAO,MAAM,CACjC,OAAO,MAAM,CACX,AFzCH,SACL,CAAiC,EAEjC,IAAM,EAAgB,CAAC,EACvB,IAAK,GAAM,CACT,QAAS,CAAA,IAAE,CAAG,CAAA,aAAE,CAAY,CAAE,CAC/B,GAAI,EAAe,GACd,AAAE,aAAwB,UAC5B,CAAA,CAAa,CAAC,EAAI,CAAG,CAJzB,EAQA,OAAO,CACT,EE4BiC,IAAI,CAAC,cAAc,EAC1C,IAAI,CAAC,aAAa,EAJxB,EASO,IAAI,CAAC,CAAA,CAAc,AAC5B,CAEA,IAAI,QAA0B,CAC5B,OAAO,IAAI,CAAC,CAAA,CAAO,EAAI,IAAI,CAAC,aAAa,AAC3C,CAEA,IAAI,OAAO,CAA+B,CAAE,CAC1C,IAAI,CAAC,CAAA,CAAO,CAAG,OAAO,MAAM,CAAC,CAAC,EAAG,IAAI,CAAC,aAAa,CAAE,EACvD,CAMA,aAAa,CAAgC,CAAE,CAC7C,IAAI,CAAC,CAAA,CAAO,CAAG,OAAO,MAAM,CAAC,CAAC,EAAG,IAAI,CAAC,MAAM,CAAE,EAChD,CAMA,UAAU,CAAuB,CAAE,CACjC,IAAM,EAAgB,IAAI,CAAC,MAAM,CAEjC,GADA,IAAI,CAAC,MAAM,CAAG,EACV,IAAI,CAAC,cAAc,CAAE,CACvB,IAAM,EAAqB,OAAO,IAAI,CAAC,GAAe,MAAM,CAC1D,AAAA,GAAO,CAAM,CAAC,EAAI,GAAK,CAAa,CAAC,EAAI,EAG3C,IAAI,CAAC,cAAc,CACjB,EAAmB,GAAG,CAAC,AAAA,GAAQ,CAAA,CAC7B,QAAS,IAAI,CAAC,aAAa,CAAC,EAAI,CAChC,MAAO,CAAM,CAAC,EAAI,AACpB,CAAA,GAEJ,CACF,CAKA,gBAAiB,CAAC,CAElB,eACE,CAGE,CACF,CACI,EAAS,IAAI,CAAC,CAAC,CAAA,QAAE,CAAO,CAAE,GAAK,EAAQ,YAAY,IACrD,IAAI,CAAC,cAAc,GAEjB,AAAkB,MAAlB,IAAI,CAAC,SAAS,EACd,EAAS,IAAI,CAAC,CAAC,CAAA,QAAE,CAAO,CAAE,GAAK,AAA6B,CAAA,IAA7B,EAAQ,gBAAgB,GAEvD,CAAA,IAAI,CAAC,SAAS,CAAG,IAJnB,EAOJ,CAEA,UAAW,CACT,IAAI,CAAC,cAAc,EACrB,CAEA,eAAe,CAAyB,CAAE,CAAqB,CAAE,CAC3D,CAAA,CAAA,IAAI,CAAC,CAAA,CAAO,EAAI,IAAI,CAAC,CAAA,CAAO,CAAC,EAAW,GAAK,CAAA,IAIjD,IAAI,CAAC,CAAA,CAAO,CAAG,OAAO,MAAM,CAAC,CAC3B,GAAI,IAAI,CAAC,CAAA,CAAO,EAAI,IAAI,CAAC,aAAa,CACtC,CAAC,EAAW,CAAE,CAChB,GAEI,IAAI,CAAC,cAAc,EACrB,IAAI,CAAC,cAAc,CACjB,CAAC,CAAE,QAAS,IAAI,CAAC,aAAa,CAAC,EAAW,CAAE,MAAA,CAAM,EAAE,CAAC,MAAM,CACzD,CAAC,CAAA,QAAE,CAAO,CAAE,GAAK,CAAC,CAAC,IAI3B,CAEA,SAAsB,CAGpB,OAFA,IAAI,CAAC,CAAA,CAAa,GAEX,IAAI,CAAC,QAAQ,CAAC,OAAO,EAC9B,CAEA,WAAY,CACV,IAAI,CAAC,CAAA,CAAa,GAElB,IAAM,EAAe,IAAI,CAAC,IAAI,CAC9B,IAAI,CAAC,QAAQ,CAAC,KAAK,GACnB,GAAM,CAAC,EAAO,EAAO,CAAI,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,OAAO,GACjD,OAAO,MAAM,CAAC,IAAI,CAAE,IAAI,CAAC,IAAI,EAC7B,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,AAAA,GAAS,EAAQ,GAG3C,GACC,CAAA,CAAY,CAAC,EAAE,GAAK,GAAS,CAAY,CAAC,EAAE,GAAK,CAAA,GAE9C,IAAI,CAAC,QAAQ,EACf,IAAI,CAAC,QAAQ,GAIb,IAAI,CAAC,KAAK,CACZ,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,EAEhC,IAAI,CAAC,KAAK,CAAG,IAAI,EAAM,IAAI,CAAC,MAAM,EAGpC,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CACpD,CAEA,WAAY,CACV,IAAI,CAAC,CAAA,CAAa,GAElB,GAAM,CAAA,UAAE,CAAS,CAAA,gBAAE,CAAe,CAAE,CAAG,IAAI,CAAC,MAAM,CAC9C,IACF,IAAI,CAAC,SAAS,GACd,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAE,CAAE,YAAa,CAAgB,GAElE,CAEA,UAAW,CACT,IAAI,CAAC,CAAA,CAAa,GAElB,IAAI,CAAC,SAAS,GACd,GAAM,CAAA,UACJ,CAAS,CAAA,gBACT,CAAe,CAAA,SACf,CAAQ,CAAA,gBACR,CAAe,CAAA,sBACf,CAAqB,CAAA,iBACrB,CAAgB,CACjB,CAAG,IAAI,CAAC,MAAM,AAEX,CAAA,GACF,IAAI,CAAC,QAAQ,CAAC,aAAa,CACzB,EACI,EACA,IAjVH,WAuVD,IACF,IAAI,CAAC,SAAS,GACd,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAE,CAAE,YAAa,CAAgB,GAElE,CAMA,KAAK,CAAA,SAAE,EAAW,GAAA,CAAiC,CAAG,CAAC,CAAC,CAAE,CACxD,IAAI,CAAC,CAAA,CAAa,GAElB,IAAI,CAAC,QAAQ,GACb,GAAM,CAAA,YAAE,CAAW,CAAE,CAAG,IAAI,CAAC,MAAM,CAEnC,GAAI,EAAa,CAIf,IAHA,IAAI,CAAC,eAAe,CAAG,IAAI,CAAC,eAAe,GAC3C,IAAI,CAAC,QAAQ,CAAG,EAET,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,EAAI,IAAI,CAAC,QAAQ,CAAG,IAChD,IAAI,CAAC,SAAS,EAChB,CACF,CAEA,KAAK,CAAgB,CAAE,CACrB,GAAI,IAAa,IAAI,CAAC,QAAQ,CAI9B,GAAI,IAAI,CAAC,eAAe,EAAI,EAAW,IAAI,CAAC,QAAQ,CAClD,KAAO,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,EAAI,IAAI,CAAC,QAAQ,CAAG,SAEhD,IAAI,CAAC,IAAI,CAAC,CAAE,SAAA,CAAS,EAEzB,CAMA,UAAW,CACT,IAAM,EAAS,IAAI,CAAC,eAAe,CAAC,IAAI,GAQxC,OANI,EAAO,IAAI,CACb,IAAI,CAAC,SAAS,GAEd,IAAI,CAAC,QAAQ,GAGR,CACT,CAEA,CAAA,CAAa,GACX,GAAI,CAAC,IAAI,CAAC,QAAQ,CAChB,MAAM,AAAI,MAAM,kCAEpB,CACF,EGlaA,MAAM,EAAS,CACb,OAAQ,AAAA,GAAK,EACb,UAAA,AAAU,GACD,EAAI,GACN,AAAA,CAAA,EAAI,KAAK,IAAI,CAAC,EAAI,KAAK,GAAG,CAAC,EAAI,EAAG,GAAA,EAAO,EACzC,AAAA,CAAA,KAAK,IAAI,CAAC,EAAI,KAAK,GAAG,CAAC,GAAK,EAAI,EAAG,IAAM,CAAA,EAAK,EAErD,aAAA,AAAa,GACJ,EAAI,KAAK,GAAG,CAAC,EAAI,EAAG,GAE7B,aAAA,AAAa,GAIJ,GAAO,AAAA,CAAA,EAAI,KAAK,GAAG,CAAC,KAAK,EAAE,CAFlC,CAAA,EAAI,KAAK,GAAG,CAAC,EAAG,KAAK,GAAG,CAAC,EAAG,GAA5B,EAEqC,GAAO,IAE9C,gBAAA,AAAgB,GACP,GAAK,GACR,AAAC,CAAA,EAAI,KAAK,GAAG,CAAC,EAAI,AAAI,EAAJ,EAAO,EAAA,EAAM,EAC/B,GAAM,KAAK,GAAG,CAAC,AAAI,EAAJ,EAAQ,EAAG,GAAK,EAErC,eAAA,AAAe,GACN,GAAK,GACR,AAAC,CAAA,EAAI,KAAK,GAAG,CAAC,EAAI,AAAI,EAAJ,EAAO,EAAA,EAAM,EAC/B,GAAM,KAAK,GAAG,CAAC,AAAI,EAAJ,EAAQ,EAAG,GAAK,EAErC,eAAA,AAAe,GACN,GAAK,GACR,AAAC,CAAA,EAAI,KAAK,GAAG,CAAC,EAAI,AAAI,EAAJ,EAAO,EAAA,EAAM,EAC/B,GAAM,KAAK,GAAG,CAAC,AAAI,EAAJ,EAAQ,EAAG,GAAK,EAErC,UAAA,CAAU,EAAa,IACd,GAAK,GACR,AAAC,CAAA,EAAI,KAAK,GAAG,CAAC,EAAI,AAAI,EAAJ,EAAO,EAAA,EAAQ,EACjC,GAAM,KAAK,GAAG,CAAC,AAAI,EAAJ,EAAQ,EAAG,GAAO,EAEvC,eAAe,CAAW,CAAE,CAAgB,CAAE,CAAS,EACrD,GAAI,EAAI,GAAY,EAAI,EAAI,EAAU,CACpC,IAAM,EAAM,AAAA,CAAA,EAAI,KAAK,GAAG,CAAC,EAAI,AAAW,EAAX,EAAc,EAAA,EAAQ,EAC7C,EAAK,GAAM,KAAK,GAAG,CAAE,AAAA,CAAA,EAAI,CAAA,EAAY,EAAI,EAAG,GAAO,EAEzD,OAAO,EAAK,AAAE,CAAA,EAAI,CAAA,EAAa,CAAA,EAAK,CAAA,EAAQ,CAAA,EAAI,EAAI,CAAA,CACtD,CACA,OAAO,GAAK,EACR,AAAC,CAAA,EAAI,KAAK,GAAG,CAAC,EAAI,AAAI,EAAJ,EAAO,EAAA,EAAQ,EACjC,GAAM,KAAK,GAAG,CAAC,AAAI,EAAJ,EAAQ,EAAG,GAAO,CACvC,CACF,CAEA,CAAA,EAAO,SAAS,CAAC,YAAY,CAAG,CAAA,EAChC,EAAO,cAAc,CAAC,YAAY,CAAG,CAAA,EACrC,EAAO,cAAc,CAAC,eAAe,CAAG,CAAA,EC5BjC,MAAM,EAAM,AAAU,EAAV,KAAK,EAAE,CCpBnB,SAAS,EACd,CAAY,CACZ,CAAY,CAIZ,CAA6B,EAE7B,GAAI,IAAS,EACX,MAAO,CAAA,EAGT,GAAI,AAAgB,UAAhB,OAAO,GAAqB,AAAgB,UAAhB,OAAO,EAAmB,CACxD,GAAK,AAAS,OAAT,GAAoB,CAAA,AAAS,OAAT,CAAS,EAChC,MAAO,CAAA,EAGT,GAAI,aAAgB,OAAS,aAAgB,MAAO,CAClD,GAAI,EAAK,MAAM,GAAK,EAAK,MAAM,CAC7B,MAAO,CAAA,EAGT,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,IAC/B,GAAI,CAAC,EAAe,CAAI,CAAC,EAAE,CAAE,CAAI,CAAC,EAAE,EAClC,MAAO,CAAA,EAIX,MAAO,CAAA,CACT,OAEA,AAAI,CAAA,CAAA,CAAC,GAEC,AADJ,CAAA,EAAQ,OAAO,IAAI,CAAC,EAApB,EACU,MAAM,GAAK,OAAO,IAAI,CAAC,GAAM,MAAM,AAF1C,IAOD,CAAA,GAAS,EAAM,IAAI,CAAC,AAAA,GAAK,CAAC,EAAe,CAAI,CAAC,EAAE,CAAE,CAAI,CAAC,EAAE,EAAA,CAK/D,CAEA,OAAO,IAAS,CAClB,CHPe,MAAA,EACb,MAAiC,AACjC,CAAA,cAAyB,AACzB,CAAA,MAAqB,AACrB,CAAA,MAAoB,AACpB,CAAA,QAAqB,AACrB,CAAA,cAAwB,CAAE,AAC1B,CAAA,UAAmB,AACnB,CAAA,UAAqB,CAAA,CAAM,AAC3B,CAAA,MAAe,AACf,CAAA,IAAc,CAAI,AAClB,CAAA,aAAwB,CAAA,CAAM,AAC9B,CAAA,mBAAyC,AAEzC,aAAY,CAAoB,CAAE,CAChC,IAAI,CAAC,SAAS,CAAC,EACjB,CAEA,SAAS,EAAQ,CAAC,CAAE,CAClB,IAAM,EAAY,IAAI,CAAC,YAAY,CAAC,GAEpC,GAAI,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAClB,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAGzB,IAAM,EACJ,IAAI,CAAC,cAAc,CACjB,EAAa,CAAA,IAAI,CAAC,MAAM,CAAC,CAAC,GAAI,IAAI,CAAC,YAAY,AAAO,GAEtD,IAAI,CAAC,GAAG,CACV,IAAI,CAAC,aAAa,CACjB,CAAA,IAAI,CAAC,MAAM,CAAC,UAAU,EAAI,CAAA,EAEvB,EAAqB,CACzB,IAAI,CAAC,MAAM,CAAC,EAAE,CAAG,KAAK,GAAG,CAAC,GAAS,IAAI,CAAC,QAAQ,CAAC,EAAE,CACnD,IAAI,CAAC,MAAM,CAAC,EAAE,CAAG,KAAK,GAAG,CAAC,GAAS,IAAI,CAAC,QAAQ,CAAC,EAAE,CACpD,CAGD,OADA,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,EAAO,GAChB,CACT,CAEA,aAAa,EAAQ,CAAC,CAAE,CACtB,IAAI,EAAY,IAAI,CAAC,SAAS,CAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAG,EAAI,EAAQ,EAI7D,OAHI,EAAY,IAAI,CAAC,MAAM,CAAC,CAAC,CAAG,GAC9B,CAAA,GAAwB,IAAI,CAAC,MAAM,CAAC,CAAC,AAAD,EAE/B,CACT,CAEA,UAAU,CAAoB,CAAE,CAC9B,GAAI,CAAC,AAAA,EAAe,EAAQ,IAAI,CAAC,MAAM,EAAG,CACxC,GAAM,CAAA,EACJ,CAAC,CAAA,KACD,CAAI,CAAA,OACJ,EAAS,CAAA,CAAA,SACT,EAAW,CAAA,CACX,OAAQ,CAAY,CAAA,OACpB,CAAM,CAAA,QACN,EAAU,CAAA,CAAA,CAAA,WACV,CAAU,CAAA,SACV,CAAQ,CACT,CAAG,EACE,EAAS,GAAgB,EAAK,GAAG,CAAC,AAAA,GAAK,EAAI,GAC3C,EAAgB,GAAU,KAAK,GAAG,IAAI,GAAU,EAClD,EAAW,CAAC,EAAe,EAAc,AAEzC,CAAA,EAAO,UAAU,EAMnB,CAAA,EAAW,AEjGZ,SAAmB,CAAK,CAAE,CAAK,EACpC,IAAM,EAAQ,KAAK,GAAG,CAAC,CAAK,CAAC,EAAE,CAAG,CAAK,CAAC,EAAE,CAAE,CAAK,CAAC,EAAE,CAAG,CAAK,CAAC,EAAE,EAC/D,OAAO,EAAM,GAAG,CAAC,AAAA,GAAK,EAAI,EAC5B,EF0FU,EAAO,UAAU,CAAG,EAChB,CAAC,EAAiB,CAAA,EAAI,KAAK,GAAG,CAAC,EAAO,UAAU,CAAA,EAAI,EAAc,CAClE,CAAC,EAAiB,CAAA,EAAI,EAAO,UAAU,AAAV,EAAa,EAAc,CAI5D,EAAO,GAAG,CAAC,AAAA,GAAK,EAAI,GAFtB,EAOF,IAAI,CAAC,YAAY,CAAG,GAAc,GAAY,EAAW,EACzD,IAAM,EAAM,IAAI,CAAC,YAAY,CAAG,EAAW,EAAa,EAElD,EAAQ,CACZ,OAAA,EACA,OAAQ,EACR,SAAA,EACA,WAAY,EAAO,CAAA,IAAI,CAAC,YAAY,CAAG,EAAI,EAAI,CAAA,EAC/C,cAAe,CAAC,EAAM,EACtB,UAAW,EACX,IAAA,CACF,EAEM,EAAiB,EAAO,gBAAgB,CAC1C,ACnFK,CDmFC,CAAC,EAAO,gBAAgB,CAAC,CAC/B,ACpFK,EDoFE,MAAM,CACX,EAAe,EAAE,AACnB,CAAA,EAAe,YAAY,EAC7B,EAAa,IAAI,CAAC,EAAO,eAAe,EAEtC,EAAe,eAAe,EAChC,EAAa,IAAI,CAAC,EAAO,oBAAoB,EAE/C,IAAM,EAA2B,EAAa,MAAM,CAChD,EAAe,IAAI,CAAC,QAAS,GAC7B,CAEJ,CAAA,IAAI,CAAC,cAAc,CAAG,EACtB,IAAI,CAAC,MAAM,CAAG,EACd,OAAO,MAAM,CAAC,IAAI,CAAE,GAChB,IAAI,CAAC,MAAM,CACb,IAAI,CAAC,MAAM,CAAC,KAAK,GAEjB,IAAI,CAAC,MAAM,CAAG,IAAI,GAEtB,CACF,CAEA,CAAC,cAAc,CAAA,iBACb,EAAmB,CAAA,CAAA,UACnB,CAAS,CAAA,mBACT,CAAkB,CACC,CAAG,CAAC,CAAC,CAAmB,CAC3C,IAEI,EAFE,CAAA,EAAE,CAAC,CAAE,CAAG,IAAI,CAAC,MAAM,CAGrB,IACF,EAAsB,IAAI,IAC1B,EAAmB,OAAO,CAAC,CAAC,CAAC,EAAO,EAAI,IACtC,IAAM,EAAM,KAAK,GAAG,CAAC,EAAK,GAC1B,IAAK,IAAI,EAAI,KAAK,GAAG,CAAC,EAAG,GAAQ,GAAK,EAAK,IACzC,EAAoB,GAAG,CAAC,EAE5B,IAGF,IAAI,EAAI,EACJ,EAAI,EAER,KAAO,EAAI,IAAI,CAAC,MAAM,CAAC,CAAC,EAClB,CAAC,GAAqB,IAAI,KAC5B,KAAM,CACJ,MAAO,IAAI,CAAC,QAAQ,CAAC,GACrB,OAAQ,EAAY,EAAU,GAAK,EAAI,CACzC,EAEA,KAEF,GAEJ,CAOA,UACE,CAAY,CACZ,EAEI,CAAC,CAAC,CACN,CACA,IAAM,EAAM,EAAE,CACR,CAAA,MAAE,CAAK,CAAE,GAAG,EAAW,CAAG,EAEhC,IAAK,IAAM,KAAQ,IAAI,CAAC,aAAa,CAAC,GACpC,EAAI,IAAI,CAAC,GAEX,EAAM,QAAQ,CAAC,EAAK,CAAE,MAAA,CAAM,EAC9B,CAEA,CAAC,SACC,CAAkB,CAClB,CAAA,SAAE,CAAQ,CAAA,MAAE,CAAK,CAA2C,CAC3C,CACjB,IAGI,EAHE,CAAA,EAAE,CAAC,CAAE,CAAG,IAAI,CAAC,MAAM,CACnB,EAAe,KAAK,KAAK,CAAC,EAAW,GAGvC,EAAiB,EACjB,EAAa,CAAA,EACjB,EAAS,QAAQ,CAAC,GAElB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAG,IAAK,CACtB,AAAC,GACH,CAAA,EAAY,IAAI,CAAC,QAAQ,CAAC,EAD5B,EAIA,IAAM,EAAa,EACb,EAAgC,EAAE,CACxC,EAAiB,EAAa,EAAI,EAAiB,EACnD,EAAY,IAAI,CAAC,QAAQ,CAAC,GAC1B,EAAU,IAAI,CAAC,GAEX,EAAI,EAAI,IACV,IACA,EAAY,IAAI,CAAC,QAAQ,CAAC,GAC1B,EAAU,IAAI,CAAC,IAGjB,EAAS,WAAW,CAAC,KAAe,GACpC,MAEA,EAAa,CAAC,CAChB,CACF,CAEA,OAAO,eAAsD,CAC3D,IAAK,WACL,MAAO,WACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,EAAI,EAAI,IACb,KAAM,EAAI,IACV,KAAM,iBACR,EACA,aAAc,CAAC,CAAA,SAAE,CAAQ,CAAE,GAAK,CAAA,EAAG,KAAK,KAAK,CAAC,AAAW,IAAX,GAAgB,IAAC,CAAC,CAChE,aAAc,CAAA,EACd,iBAAkB,CAAA,CACpB,CAAE,AAEF,QAAO,YAAc,OAAO,MAAM,CAAC,CACjC,IAAK,IACL,MAAO,kBACP,aAAc,IACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,IACL,KAAM,CACR,EACA,aAAc,CAAA,CAChB,EAAG,AAEH,QAAO,mBAAkD,CACvD,IAAK,eACL,MAAO,eACP,KAAM,QACN,SAAU,CACR,CACE,IAAK,mBACL,MAAO,wBACP,aAAc,SACd,KAAM,SACN,QAAS,OAAO,IAAI,CC5Ob,GD6OP,aAAc,CAAA,EACd,iBAAkB,CAAA,CACpB,EACA,CACE,IAAK,kBACL,MAAO,yBACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,GACL,KAAM,EACR,EACA,KAAM,CAAC,CAAA,iBAAE,CAAgB,CAAE,GAAK,AC1PzB,CD0P+B,CAAC,EAAiB,CAAC,YAAY,CACrE,aAAc,CAAA,EACd,iBAAkB,CAAA,CACpB,EACA,CACE,IAAK,uBACL,MAAO,yBACP,aAAc,GACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,GACL,KAAM,GACR,EACA,KAAM,CAAC,CAAA,iBAAE,CAAgB,CAAE,GACzB,ACzQK,CDyQC,CAAC,EAAiB,CAAC,eAAe,CAC1C,aAAc,CAAA,EACd,iBAAkB,CAAA,CACpB,EACD,AACH,CAAE,AAEF,QAAO,iBAA2D,CAChE,IAAK,aACL,MAAO,aACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,KACL,IAAK,IACL,KAAM,IACN,KAAM,GACR,EACA,aAAc,CAAA,EACd,iBAAkB,CAAA,CACpB,CAAE,AACJ,CNzUA,MAAM,EAAe,AAAA,EAAM,SAAS,CAAC,CACnC,SAAU,CACR,aAAc,CAAA,EACd,WAAY,EACZ,MAAO,UACP,gBAAiB,GACjB,gBAAiB,GACjB,sBAAuB,CAAA,EACvB,aAAc,GACd,aAAc,EAChB,CACF,EAUe,OAAA,UAAqB,EAClC,OAAO,KAAO,QAAS,AAEvB,CAAA,GAAK,QAAS,AACd,CAAA,KAAO,QAAS,AAChB,CAAA,KACE,mFAAoF,AACtF,CAAA,SAAyC,CACvC,CACE,GAAG,AAAA,EAAO,WAAW,CACrB,aAAc,GAChB,EACA,CACE,IAAK,aACL,MAAO,aACP,aAAc,EACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,GAAI,KAAM,CAAE,CACnC,EACA,CACE,IAAK,cACL,MAAO,mBACP,aAAc,GACd,KAAM,QACN,KAAM,CACJ,IAAK,CAAC,CAAA,EAAE,CAAC,CAAE,GAAK,EAAI,EACpB,IAAK,EACL,KAAM,CAAC,CAAA,EAAE,CAAC,CAAE,GAAK,EAAI,CACvB,EACA,aAAc,CAAC,CAAA,EAAE,CAAC,CAAA,YAAE,CAAW,CAAE,GAAK,KAAK,KAAK,CAAC,EAAI,EACvD,EACA,CACE,GAAG,AAAA,EAAO,cAAc,CACxB,aAAc,GAChB,EACA,AAAA,EAAO,gBAAgB,CACvB,EACD,AAAC,AAEF,EAAA,CAAe,AAAS,AACxB,EAAA,CAAO,AAAS,AAChB,EAAA,CAAM,AAAQ,AACd,EAAA,CAAS,AAAW,AAEpB,CAAA,WAAY,CACV,KAAK,CAAC,YACN,GAAM,CAAA,EAAE,CAAC,CAAA,SAAE,CAAQ,CAAA,OAAE,CAAM,CAAA,WAAE,CAAU,CAAA,WAAE,CAAU,CAAA,WAAE,CAAU,CAAE,CAC/D,IAAI,CAAC,MAAM,AACb,CAAA,IAAI,CAAC,CAAA,CAAe,CAAG,AAAa,EAAb,EAAiB,EAExC,IAAM,EAAe,CACnB,KAAM,IAAI,CAAC,IAAI,CACf,EAAA,EACA,OAAA,EACA,SAAA,EACA,WAAA,CACF,CAEI,CAAA,IAAI,CAAC,CAAA,CAAO,CACd,IAAI,CAAC,CAAA,CAAO,CAAC,SAAS,CAAC,GAEvB,IAAI,CAAC,CAAA,CAAO,CAAG,IAAI,EAAO,GAG5B,IAAI,CAAC,CAAA,CAAM,CAAG,IAAI,EAAM,CACtB,GAAG,IAAI,CAAC,MAAM,CACd,WAAY,CACd,GAEI,GACF,CAAA,IAAI,CAAC,CAAA,CAAS,CAAG,IAAI,CAAC,CAAA,CAAM,CAAC,WAAW,CAAC,CACvC,UAAW,IAAI,CAAC,YAAY,GAC5B,WAAA,CACF,EAAA,CAEJ,CAEA,CAAC,WAAW,CAAA,MACV,EAAQ,CAAA,CAAA,MACR,EAAQ,SAAA,CAC+B,CAAG,CAAC,CAAC,CAAmB,CAC/D,GAAM,CAAA,YAAE,CAAW,CAAA,EAAE,CAAC,CAAE,CAAG,IAAI,CAAC,MAAM,CAElC,EAAqB,KAAK,KAAK,CAAC,EAAc,GAC9C,EAAkB,EACtB,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GACvB,IAAI,EAAiB,EACjB,EAAY,IAAI,CAAC,CAAA,CAAO,CAAC,QAAQ,CAAC,GAClC,EAAc,CAAA,EAElB,IAAK,IAAI,EAAI,EAAG,EAAqB,EAAG,IAAK,CAC3C,GAAI,IAAI,CAAC,CAAA,CAAS,CAAE,CAClB,IAAM,EAAY,IAAI,CAAC,CAAA,CAAS,CAAC,GAAG,CAAC,EACjC,CAAA,GACF,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAE3B,CAEA,EAAiB,EACb,EAAiB,EAAqB,EACtC,EAAiB,EAEjB,IAAoB,IAAI,CAAC,CAAA,CAAe,EAC1C,IACA,EAAkB,EAClB,KAEA,IAGF,IAAM,EAAY,IAAI,CAAC,CAAA,CAAO,CAAC,QAAQ,CAAC,GAExC,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAW,GACrC,EAAY,EAEZ,MACA,EAAc,CAAC,CACjB,CACF,CAEA,CAAC,iBAAmC,CAClC,MAAO,IAAI,CAAC,UAAU,CAAC,CACrB,MAAO,IAAI,CAAC,CAAA,CAAM,CAAC,QAAQ,CAAC,EAC9B,EACF,CAEA,cAAuB,CACrB,GAAM,CAAA,YAAE,CAAW,CAAA,WAAE,CAAU,CAAA,EAAE,CAAC,CAAE,CAAG,IAAI,CAAC,MAAM,CAClD,OAAO,KAAK,KAAK,CAAC,AAAmB,EAAd,EAAL,EAAwB,EAC5C,CAEA,WAAY,CACV,IAAI,CAAC,CAAA,CAAO,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CACnC,CAEA,OAAO,gBAAkB,CACvB,EAAG,EACL,CAAE,AACJ,CUnJA,MAAM,UAAgB,EACpB,OAAO,KAAO,SAAU,AAExB,CAAA,KAAO,SAAU,AACjB,CAAA,GAAK,SAAU,AACf,CAAA,KACE,8GAA+G,AACjH,CAAA,SAA0C,CACxC,CACE,IAAK,iBACL,MAAO,gBACP,aAAc,IACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,GAAI,KAAM,EAAI,CACrC,EACA,CACE,IAAK,YACL,MAAO,aACP,aAAc,IACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,EAAG,KAAM,GAAK,CACrC,EACA,CACE,IAAK,WACL,MAAO,oBACP,aAAc,EACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,GAAI,KAAM,CAAE,CACnC,EACA,CACE,GAAG,AAAA,EAAO,cAAc,CACxB,aAAc,IAAM,GACtB,EACA,AAAA,EAAM,SAAS,CAAC,CACd,SAAU,CACR,aAAc,CAAA,EACd,WAAY,EACZ,MAAO,UACP,gBAAiB,EACjB,gBAAiB,IACjB,sBAAuB,CAAA,EACvB,aAAc,GACd,aAAc,GACd,cAAe,CAAA,CACjB,CACF,GACD,AAAC,AAEF,CAAA,IAAY,AACZ,CAAA,KAAa,AACb,CAAA,QAAmB,AAEnB,CAAA,SAAiB,CACf,GAAM,CAAA,SAAE,CAAQ,CAAA,SAAE,CAAQ,CAAA,OAAE,CAAM,CAAA,eAAE,CAAc,CAAA,UAAE,CAAS,CAAE,CAC7D,IAAI,CAAC,MAAM,CACP,EAAY,KAAK,GAAG,IAAI,IAAI,CAAC,IAAI,EAAI,EAAI,EAE/C,MAAO,CACL,gBAAiB,AAAI,MAAM,GACxB,IAAI,CAAC,MACL,GAAG,CAAC,CAAC,EAAG,IAAM,EAAK,EAAO,GAC7B,cAAe,CAAC,EAAM,EACtB,eAAgB,KAAK,KAAK,CAAC,EAAY,GACvC,cAAe,EAAa,CAAA,EAAY,EAAA,CAC1C,CACF,CAEA,WAAY,CACV,KAAK,CAAC,YAEN,GAAM,CAAA,WAAE,CAAU,CAAE,CAAG,IAAI,CAAC,MAAM,AAElC,CAAA,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,OAAO,GACxB,IAAI,CAAC,KAAK,CAAG,IAAI,EAAM,IAAI,CAAC,MAAM,EAClC,IAAI,CAAC,QAAQ,CAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CACrC,UAAW,IAAI,CAAC,YAAY,GAC5B,WAAA,CACF,EACF,CAEA,CAAC,gBAAiB,CAChB,GAAM,CAAA,SAAE,CAAQ,CAAE,CAAG,IAAI,CAAC,MAAM,CAEhC,IAAK,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,IAAI,CAAC,cAAc,CAAE,IAC5C,IAAK,IAAI,EAAI,EAAG,EAAI,EAAU,IAAK,CACjC,IAAM,EAAQ,IAAI,CAAC,QAAQ,CAAC,EAAG,EAC/B,MAAM,CAAE,MAAA,EAAO,WAAY,CAAA,EAAG,EAAE,CAAC,EAAE,EAAA,CAAG,AAAC,CACzC,CAEJ,CAEA,SAAS,CAAmB,CAAE,CAAa,CAAe,CACxD,GAAM,CAAC,EAAS,EAAQ,CAAG,IAAI,CAAC,MAAM,CAChC,CAAA,eAAE,CAAc,CAAE,CAAG,IAAI,CAAC,MAAM,CAEhC,EACJ,IAAI,CAAC,IAAI,CAAC,aAAa,CACvB,IAAI,CAAC,IAAI,CAAC,aAAa,CAAG,EAC1B,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,EAAY,CAClC,EAAS,EAAQ,EAEvB,MAAO,CACL,EAAU,EAAS,KAAK,GAAG,CAAC,GAC5B,EAAU,EAAS,KAAK,GAAG,CAAC,GAC7B,AACH,CAEA,CAAC,iBAAmC,CAClC,IAAM,EAAS,IAAI,CAAC,cAAc,GAC9B,EAAQ,EACZ,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAC3C,IAAI,EAAY,IAAI,CAAC,MAAM,CAE3B,IAAK,GAAM,CAAA,MAAE,CAAK,CAAE,GAAI,EAAQ,CAC9B,GAAI,IAAI,CAAC,QAAQ,CAAE,CACjB,IAAM,EAAY,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAChC,CAAA,GACF,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAE3B,CAEI,GACF,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAW,GAEvC,EAAY,EACZ,IACA,KACF,CACF,CAEA,cAAuB,CACrB,GAAM,CAAA,SAAE,CAAQ,CAAA,eAAE,CAAc,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,MAAM,CAGxD,OAAO,AADG,KAAK,KAAK,CAAC,AADH,CAAA,KAAK,GAAG,IAAI,IAAI,CAAC,OAAO,IAAM,EAAI,CAApD,EACiC,GACtB,CACb,CAEA,WAAY,CAEV,IAAK,GAAM,CAAA,MAAE,CAAK,CAAA,WAAE,CAAU,CAAE,GADjB,IAAI,CAAC,cAAc,GAEhC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAE,MAAA,EAAO,OAAQ,CAAW,EAEnD,CAEA,OAAO,gBAAkB,CACvB,eAAgB,IAChB,UAAW,GACb,CAAE,AACJ,CEpJe,MAAA,UAA4C,EAGzD,OAAO,KAAO,SAAU,AAExB,CAAA,KAAO,SAAU,AACjB,CAAA,GAAK,SAAU,AACf,CAAA,KAAO,6CAA8C,AACrD,CAAA,SAAW,OAAQ,AACnB,CAAA,SAA0D,CACxD,CACE,IAAK,IACL,MAAO,kBACP,aAAc,IACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,IAAK,KAAM,CAAE,CACpC,EACA,CACE,IAAK,OACL,MAAO,iBACP,aAAc,EACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,GAAI,KAAM,CAAE,CACnC,EACA,CACE,IAAK,SACL,MAAO,SACP,aAAc,EACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,GAAI,KAAM,CAAE,CACnC,EACA,AAAA,EAAO,cAAc,CACrB,AAAA,EAAO,gBAAgB,CACvB,AAAA,EAAM,SAAS,CAAC,CACd,SAAU,CACR,aAAc,CAAA,EACd,gBAAiB,IACjB,gBAAiB,IACjB,MAAO,SACT,EACA,QAAS,CAAC,aAAa,AACzB,GACD,AAAC,AAEF,CAAA,MAAe,AACf,CAAA,KAAa,AACb,CAAA,IAAY,AAEZ,KAAI,GAAI,CACN,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC,AACpB,CAEA,SAAiB,CACf,GAAM,CAAE,EAAG,CAAO,CAAA,OAAE,CAAM,CAAA,UAAE,CAAS,CAAE,CAAG,IAAI,CAAC,MAAM,CAE/C,EAAI,EADS,EAAU,EAG7B,MAAO,CACL,EAAA,EACA,gBAAiB,EAAY,KAAK,KAAK,CAAC,EAAI,GAAa,EACzD,WAAY,KAAK,KAAK,CAAC,EAAI,EAC7B,CACF,CAEA,WAAY,CACV,KAAK,CAAC,YAEN,GAAM,CAAA,OAAE,CAAM,CAAA,SAAE,CAAQ,CAAA,WAAE,CAAU,CAAA,OAAE,CAAM,CAAA,UAAE,CAAS,CAAA,KAAE,CAAI,CAAA,QAAE,CAAO,CAAE,CACtE,IAAI,CAAC,MAAM,AACb,CAAA,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,OAAO,GAExB,IAAM,EAA6B,CACjC,KAAM,IAAI,CAAC,IAAI,CACf,EAAG,IAAI,CAAC,CAAC,CACT,OAAA,EACA,SAAA,EACA,WAAA,EACA,QAAA,CACF,CAEI,CAAA,IAAI,CAAC,MAAM,CACb,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,GAEtB,IAAI,CAAC,MAAM,CAAG,IAAI,EAAO,GAG3B,IAAI,CAAC,KAAK,CAAG,IAAI,EAAM,CACrB,GAAG,IAAI,CAAC,MAAM,CACd,WAAY,CACd,EACF,CAEA,CAAC,eAAe,CAAkB,CAAmB,CACnD,GAAM,CAAA,QAAE,CAAO,CAAA,KAAE,CAAI,CAAE,CAAG,IAAI,CAAC,MAAM,CAC/B,CAAA,EAAE,CAAC,CAAA,WAAE,CAAU,CAAA,gBAAE,CAAe,CAAE,CAAG,IAAI,CAAC,IAAI,CAE9C,EAAQ,EAAa,EAAc,CAAA,EAAU,EAAI,EAAA,EACjD,EAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,GAClC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAEvB,IAAI,EAAQ,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,GAEjC,IAAK,IAAI,EAAI,EAAG,GAAK,EAAiB,IAAK,CACzC,IAAM,EAAa,EACnB,EAAQ,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAI,GACjC,IAAM,EAAW,EAAI,EAAQ,EAC7B,IAAI,CAAC,QAAQ,CAAC,WAAW,CACvB,EACA,EACA,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAU,IAGjC,KACF,CACF,CAEA,CAAC,iBAAmC,CAClC,GAAM,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,MAAM,CAE9B,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAQ,IAClC,MAAO,IAAI,CAAC,cAAc,CAAC,EAE/B,CAEA,WAAY,CACV,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAClC,CAEA,cAAuB,CACrB,GAAM,CAAA,OAAE,CAAM,CAAA,UAAE,CAAS,CAAE,CAAG,IAAI,CAAC,MAAM,CACnC,CAAA,EAAE,CAAC,CAAE,CAAG,IAAI,CAAC,OAAO,GAE1B,MAAO,AAAC,CAAA,GAAU,CAAA,EADM,CAAA,EAAY,KAAK,KAAK,CAAC,EAAI,GAAa,CAAA,CAElE,CAEA,OAAO,gBAAkB,CACvB,EAAG,EACL,CAAE,AACJ,CChKO,SAAS,EAAwB,CAAa,EACnD,MAAO,CAAA,EAAG,KAAK,KAAK,CAAC,AAAQ,IAAR,GAAa,CAAC,CAAC,AACtC,CFQe,MAAA,UAAmB,EAChC,OAAO,KAAO,MAAO,AAErB,CAAA,GAAK,MAAO,AACZ,CAAA,KAAO,MAAO,AACd,CAAA,KACE,sGAAuG,AACzG,CAAA,SAAuD,CACrD,CACE,GAAG,AAAA,EAAO,WAAW,CACrB,aAAc,GAChB,EACA,CACE,IAAK,YACL,MAAO,aACP,aAAc,GACd,KAAM,QACN,KAAM,CACJ,IAAK,CAAC,CAAA,EAAE,CAAC,CAAE,GAAK,EAAI,EACpB,IAAK,EACL,KAAM,CAAC,CAAA,EAAE,CAAC,CAAE,GAAK,EAAI,CACvB,EACA,aAAc,CAAC,CAAA,UAAE,CAAS,CAAE,GAAK,AAAA,EAAwB,EAC3D,EACA,CACE,GAAG,AAAA,EAAO,cAAc,CACxB,aAAc,IAAM,GACtB,EACA,AAAA,EAAO,gBAAgB,CACvB,CACE,IAAK,SACL,MAAO,SACP,aAAc,GACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,GAAI,KAAM,CAAE,CACnC,EACA,CACE,IAAK,cACL,MAAO,eACP,aAAc,KACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,EACL,KAAM,CAAC,CAAA,EAAE,CAAC,CAAE,GAAK,EAAI,CACvB,EACA,aAAc,CAAC,CAAA,YAAE,CAAW,CAAA,EAAE,CAAC,CAAE,GAAK,KAAK,KAAK,CAAC,EAAc,EACjE,EACA,CACE,IAAK,UACL,MAAO,UACP,aAAc,CAAA,EACd,KAAM,UACR,EACA,AAAA,EAAM,SAAS,CAAC,CACd,SAAU,CACR,aAAc,CAAA,EACd,gBAAiB,IACjB,gBAAiB,IACjB,MAAO,UACP,sBAAuB,CAAA,EACvB,aAAc,GACd,aAAc,EAChB,EACA,QAAS,CAAC,aAAa,AACzB,GACD,AAAC,AAEF,CAAA,cAAgB,CACd,KAAM,CACR,CAAE,AAEF,CAAA,WAAY,CACV,KAAK,CAAC,YACN,GAAM,CAAA,EAAE,CAAC,CAAA,YAAE,CAAW,CAAE,CAAG,IAAI,CAAC,MAAM,AACtC,CAAA,IAAI,CAAC,IAAI,CAAC,UAAU,CAAG,KAAK,KAAK,CAAC,EAAI,EACxC,CAEA,CAAC,iBAAkB,CACjB,GAAM,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,MAAM,CAE9B,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAQ,IAClC,MAAO,IAAI,CAAC,cAAc,CAAC,EAE/B,CAEA,OAAO,gBAAkB,CACvB,EAAG,EACL,CAAE,AACJ,CG5FA,MAAM,EAAkC,CAAC,OAAQ,SAAU,QAAS,MAAM,CACpE,EAAwC,CAC5C,OACA,SACA,QACA,MACD,CAEK,EAAiB,CACrB,KAAM,EACN,OAAQ,KAAK,EAAE,CAAG,EAClB,MAAO,KAAK,EAAE,CACd,IAAK,AAAU,IAAV,KAAK,EAAE,AACd,CAsBA,OAAM,UAAY,EAChB,OAAO,KAAO,KAAM,AAEpB,CAAA,KAAO,KAAM,AACb,CAAA,GAAK,KAAM,AACX,CAAA,KACE,8SAA+S,AACjT,CAAA,SAAsC,CACpC,CACE,IAAK,IACL,MAAO,2BACP,aAAc,GACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,IAAK,KAAM,CAAE,CACpC,EACA,CACE,IAAK,SACL,MAAO,SACP,aAAc,GACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,GAAI,KAAM,CAAE,CACnC,EACA,CACE,IAAK,QACL,MAAO,cACP,aAAc,GACd,aAAc,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,CAAA,EAAG,EAAM,IAAC,CAAC,CACxC,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,GAAI,KAAM,CAAE,CACnC,EACA,AAAA,EAAM,SAAS,CAAC,CACd,SAAU,CACR,aAAc,CAAA,EACd,MAAO,UACP,gBAAiB,IACjB,gBAAiB,IACjB,sBAAuB,CAAA,EACvB,aAAc,GACd,aAAc,GACd,WAAY,CACd,EACA,eAAgB,CACd,CACE,IAAK,gBACL,MAAO,kBACP,aAAc,CAAA,EACd,KAAM,WACN,KAAM,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,CAC9B,EACD,CACD,QAAS,CAAC,aAAc,eAAe,AACzC,GACD,AAAC,AAEF,CAAA,cAA4C,CAC1C,WAAY,SACd,CAAE,AAEF,EAAA,CAAK,AAAQ,AACb,CAAA,KAAa,AAEb,CAAA,SAAiB,CACf,GAAM,CAAA,EAAE,CAAC,CAAA,MAAE,CAAK,CAAA,OAAE,CAAM,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,MAAM,CAE1C,EAAU,KAAK,GAAG,IAAI,IAAI,CAAC,IAAI,EAAI,EAAI,EACvC,EAAc,EAAW,CAAA,EAAI,CAAA,EAC7B,EAAa,EAAS,KAAK,EAAE,CAAI,IAEjC,EAAgB,AAAC,IACrB,IAAM,EACJ,EACA,KAAK,GAAG,CAAC,KAAK,GAAG,CAAC,GAAc,KAAK,GAAG,CAAC,GAAa,GAClD,EAA0B,CAC9B,IAAI,CAAC,MAAM,CAAC,EAAE,CAAG,EAAY,EAC7B,IAAI,CAAC,MAAM,CAAC,EAAE,CAAG,EAAY,EAC9B,CACK,EAAmB,KAAK,KAAK,CAAC,EAAY,GAEhD,MAAO,CACL,WAAY,EAAa,EACzB,UAAA,EACA,WAAA,EACA,iBAAA,CACF,CACF,EAEA,MAAO,CACL,QAAA,EACA,YAAA,EACA,WAAA,EACA,OAAQ,AAAI,MAAM,GACf,IAAI,CAAC,MACL,GAAG,CAAC,CAAC,EAAG,IAAe,EAAc,GAC1C,CACF,CAEA,WAAY,CACV,KAAK,CAAC,YACN,IAAI,CAAC,KAAK,CAAG,IAAI,EAAM,CACrB,GAAG,IAAI,CAAC,MAAM,CACd,aAAc,CAAA,EACd,WAAY,CACd,GACA,IAAI,CAAC,CAAA,CAAK,CAAG,IAAI,CAAC,OAAO,EAC3B,CAGA,SAAS,CAAA,MACP,CAAK,CAAA,MACL,CAAK,CAAA,WACL,CAAU,CAAA,SACV,CAAQ,CAMT,CAAe,CACd,IAAM,EAAQ,EAAQ,EAEhB,EAAqB,CACzB,CAAU,CAAC,EAAE,CACb,CAAU,CAAC,EAAE,CAAG,IAAI,CAAC,CAAA,CAAK,CAAC,WAAW,CAAG,EAC1C,CAEK,EAAQ,IAAI,CAAC,MAAM,CAEnB,EAAW,KAAK,GAAG,CAAC,GACpB,EAAW,KAAK,GAAG,CAAC,GAE1B,MAAO,CACL,EAAY,CAAA,CAAK,CAAC,EAAE,CAAG,CAAK,CAAC,EAAC,AAAD,EAC3B,EAAY,CAAA,CAAK,CAAC,EAAE,CAAG,CAAK,CAAC,EAAE,AAAF,EAC7B,CAAK,CAAC,EAAE,CACV,EAAY,CAAA,CAAK,CAAC,EAAE,CAAG,CAAK,CAAC,EAAC,AAAD,EAC3B,EAAY,CAAA,CAAK,CAAC,EAAE,CAAG,CAAK,CAAC,EAAE,AAAF,EAC7B,CAAK,CAAC,EAAE,CACX,AACH,CAEA,CAAC,SAAS,CAAA,KACR,CAAI,CAAA,MACJ,EAAQ,SAAA,CAAA,MACR,CAAK,CAAA,KACL,CAAI,CAAA,WACJ,CAAU,CAAA,iBACV,CAAgB,CAQjB,CAAmB,CAClB,IAAM,EAAY,EAAM,OAAO,CAAC,GAC1B,EAAW,CAAK,CAAC,IAAc,EAAM,MAAM,CAAG,EAAI,EAAI,EAAY,EAAE,CACpE,EAAW,CAAc,CAAC,EAAK,CAC/B,EAAmB,CAAc,CAAC,EAAS,CAE3C,EAAY,CAAE,iBAAA,EAAkB,KAAA,EAAM,WAAA,EAAY,MAAA,CAAM,EAC9D,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAEvB,IAAK,IAAI,EAAI,EAAG,GAAK,EAAkB,IACrC,IAAI,CAAC,QAAQ,CAAC,WAAW,CACvB,IAAI,CAAC,QAAQ,CAAC,CAAE,MAAO,EAAG,SAAA,EAAU,GAAG,CAAS,AAAC,GACjD,IAAI,CAAC,QAAQ,CAAC,CACZ,MAAO,EACP,SAAU,EACV,GAAG,CAAS,AACd,IAGF,KAEJ,CAEA,CAAC,UAAU,CAAkB,CAAmB,CAC9C,GAAM,CAAA,cAAE,CAAa,CAAE,CAAG,IAAI,CAAC,MAAM,CAE/B,CAAA,WAAE,CAAU,CAAA,UAAE,CAAS,CAAA,WAAE,CAAU,CAAA,iBAAE,CAAgB,CAAE,CAC3D,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,EAAW,CAE/B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAChC,MAAO,IAAI,CAAC,QAAQ,CAAC,CACnB,MAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAgB,EAAa,GACxD,KAAM,CAAW,CAAC,EAAE,CACpB,MAAO,EACP,KAAM,EACN,WAAA,EACA,iBAAA,CACF,EAEJ,CAEA,CAAC,iBAAkB,CACjB,GAAM,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,MAAM,CAC9B,IAAK,IAAI,EAAQ,EAAS,EAAG,GAAS,EAAG,IACvC,MAAO,IAAI,CAAC,SAAS,CAAC,EAE1B,CAEA,cAAe,CACb,IAAI,EAAQ,EACN,CAAA,OAAE,CAAM,CAAA,MAAE,CAAK,CAAA,EAAE,CAAC,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,MAAM,CAC1C,EAAa,EAAS,KAAK,EAAE,CAAI,IACjC,EAAU,KAAK,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,IAAM,EAAI,EACrD,EAAc,EAAW,CAAA,EAAI,CAAA,EAEnC,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAQ,IAGlC,GAAS,EAAK,CAAA,KAAK,KAAK,CAAC,AADvB,EAAU,KAAK,GAAG,CAAC,KAAK,GAAG,CAAC,GAAc,KAAK,GAAG,CAAC,GAAa,GAC7B,GAAe,CAAA,EAGtD,OAAO,CACT,CAEA,WAAY,CACV,GAAM,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,MAAM,CAC9B,IAAK,IAAI,EAAQ,EAAS,EAAG,GAAS,EAAG,IAAS,CAChD,GAAM,CACJ,WAAY,CAAK,CACjB,UAAW,CAAI,CAAA,WACf,CAAU,CAAA,iBACV,CAAgB,CACjB,CAAG,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,EAAM,CAE5B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAAK,CAErC,IAAM,EAAW,CAAc,CADb,CAAW,CAAC,EAAE,CACU,CAE1C,IAAK,IAAI,EAAI,EAAG,GAAK,EAAkB,IAAK,CAC1C,IAAM,EAAY,CAAE,iBAAA,EAAkB,KAAA,EAAM,WAAA,EAAY,MAAA,CAAM,EAC9D,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CACjB,MAAO,IAAI,CAAC,QAAQ,CAAC,CACnB,MAAO,EACP,SAAA,EACA,GAAG,CAAS,AACd,GACA,OAAQ,CAAA,EAAG,EAAM,CAAC,EAAE,EAAE,CAAC,EAAE,EAAA,CAAG,AAC9B,EACF,CACF,CACF,CACF,CAEA,OAAO,gBAAkB,CACvB,EAAG,GACH,OAAQ,CACV,CAAE,AACJ,CE/Qe,MAAA,EACb,MAAwB,AACxB,CAAA,MAAoB,AACpB,CAAA,IAA2C,AAE3C,aAAY,CAAuB,CAAE,CACnC,IAAI,CAAC,SAAS,CAAC,EACjB,CAEA,OAAO,QAAQ,CAAA,OACb,CAAM,CAAA,MACN,CAAK,CAAA,UACL,CAAS,CAAA,SACT,CAAQ,CACR,aAAc,EAAuB,CAAC,CAAA,aACtC,EAAe,CAAA,CACC,CAAE,CAClB,IAAM,EAAe,EAAS,EAExB,EAAa,AAAW,EAAX,KAAM,EAAE,CAAQ,EAC7B,EAAgB,EAAW,CAAA,CAAA,AAAY,EAAV,KAAK,EAAE,AAAG,EAAI,EAAY,EAAQ,EAErE,MAAO,CACL,UAAW,EACX,YANmB,AAAA,CAAA,EAAS,CAAA,EAAiB,CAAA,EAAY,CAAA,EAOzD,aAAA,EACA,cAAe,EAAQ,EAAI,AAAQ,EAAR,EAAY,EACvC,qBAAsB,KAAK,KAAK,CAAC,KAAK,GAAG,CAAC,EAAG,GAAgB,GAC7D,SAAU,EAAS,EACnB,MAAO,AAAI,MAAM,GAAO,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,EAAG,KACzC,IAAM,EAAY,EAAO,EAAa,EAEtC,MAAO,CACL,aAAc,KAAK,GAAG,CAAC,GACvB,aAAc,KAAK,GAAG,CAAC,EACzB,CACF,EACF,CACF,CAEA,SAAS,EAAO,CAAC,CAAE,EAAQ,CAAC,CAAe,CACzC,IAAM,EAAS,IAAI,CAAC,IAAI,CAAC,YAAY,CAAG,EAAQ,IAAI,CAAC,IAAI,CAAC,WAAW,CAC/D,CAAA,aAAE,CAAY,CAAA,aAAE,CAAY,CAAE,CAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAK,CAE5D,MAAO,CACL,IAAI,CAAC,MAAM,CAAC,EAAE,CAAG,EAAe,EAChC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAG,EAAe,EACjC,AACH,CAEA,UAAU,CAAuB,CAAE,CACjC,GACE,AAAA,EAAe,EAAQ,IAAI,CAAC,MAAM,CAAE,CAClC,SACA,QACA,YACA,WACA,SACA,OACA,eACA,eACD,EAED,OAGF,IAAM,EACJ,EAAO,MAAM,EAAK,EAAO,IAAI,CAAC,GAAG,CAAC,AAAA,GAAK,EAAI,EAE7C,CAAA,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,IAAI,CAAG,EAAU,OAAO,CAAC,EAChC,CAKA,UACE,CAAY,CACZ,CAAA,UACE,CAAS,CAAA,aACT,CAAY,CACZ,GAAG,EAMJ,CAAG,CAAC,CAAC,CACA,CACN,GAAM,CAAA,MAAE,CAAK,CAAA,UAAE,CAAS,CAAE,CAAG,IAAI,CAAC,MAAM,CAElC,EAAa,EAAE,CAErB,IAAK,IAAI,EAAO,EAAG,EAAO,EAAO,IAC/B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAW,IAAK,CAClC,IAAM,EAAY,EAAe,EAAY,EAAI,EACjD,EAAW,IAAI,CAAC,CACd,MAAO,IAAI,CAAC,QAAQ,CAAC,EAAM,GAC3B,OAAQ,EACJ,EAAU,EAAM,GAChB,GAAa,IAAI,CAAC,MAAM,CAAC,YAAY,CACrC,CAAA,EAAG,EAAK,CAAC,EAAE,EAAA,CAAW,CACtB,CACN,EACF,CAGF,EAAM,QAAQ,CAAC,EAAY,EAC7B,CAOA,CAAC,gBACC,CAAkB,CAClB,CAAA,KAAE,CAAI,CAAqB,CAAG,CAAC,CAAC,CACf,CACjB,GAAM,CAAE,UAAW,CAAe,CAAA,MAAE,CAAK,CAAE,CAAG,IAAI,CAAC,MAAM,CACnD,CAAA,qBAAE,CAAoB,CAAA,cAAE,CAAa,CAAE,CAAG,IAAI,CAAC,IAAI,CAEnD,EAAY,EACd,KAAK,GAAG,CAAC,EAAG,KAAK,GAAG,CAAC,KAAK,KAAK,CAAC,GAAO,IACvC,EAEE,EAAe,KAAK,GAAG,CAAC,EAAG,EAAY,GAEzC,EAAY,CAAA,EAEV,EACJ,EAAQ,EACJ,KAAK,IAAI,CAAC,KAAK,GAAG,CAAC,EAAW,GAAwB,GACtD,EAAY,EAEd,EAAiB,EACjB,EAAY,IAAI,CAAC,QAAQ,CAAC,EAAG,GAEjC,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAQ,IAAS,CAC3C,IAAM,EAAc,IAAU,EAAS,EACnC,EAAO,EAEX,IAAK,IAAI,EAAI,EAAG,EAAI,EAAe,IAAK,CACtC,EAAO,AAAC,CAAA,EAAO,CAAA,EAAK,EAEpB,EAAiB,AADjB,CAAA,EAAY,CAAC,CAAb,EAEI,EAAY,EAAQ,EACpB,EAAQ,EACZ,IAAM,EAAY,IAAI,CAAC,QAAQ,CAAC,EAAM,GAKtC,GAJA,EAAS,WAAW,CAAC,EAAW,GAChC,EAAY,EACZ,MAEI,GAAe,IAAM,EAAQ,GAAK,EAAQ,GAAK,EAAY,EAC7D,KAEJ,CAEA,GAAI,CAAC,EAAa,CAChB,EAAiB,EAAY,EAAiB,EAAI,EAAiB,EACnE,IAAM,EAAY,IAAI,CAAC,QAAQ,CAAC,EAAG,GACnC,EAAS,WAAW,CAAC,EAAW,GAChC,EAAY,CACd,CACF,CACF,CAEA,aAAa,CAAY,CAAE,CACzB,OAAO,EAAU,YAAY,CAAC,IAAI,CAAC,MAAM,CAAE,CAAE,KAAA,CAAK,EACpD,CAEA,OAAO,aACL,CAAA,MACE,CAAK,CACL,UAAW,CAAe,CAAA,aAC1B,EAAe,CAAA,CACU,CAC3B,CAAA,KAAE,CAAI,CAAqB,CAAG,CAAC,CAAC,CAChC,CACA,IAAM,EAAuB,KAAK,KAAK,CACrC,KAAK,GAAG,CAAC,EAAG,GAAgB,GAExB,EAAY,EACd,KAAK,GAAG,CAAC,KAAK,KAAK,CAAC,GAAO,GAC3B,EACE,EAAe,KAAK,GAAG,CAAC,EAAG,EAAY,GAS7C,MAAO,AANL,CAAA,EAAQ,EACJ,KAAK,IAAI,CAAC,KAAK,GAAG,CAAC,EAAW,GAAwB,GACtD,EAAY,CAHlB,EAKsB,CAAA,EAAQ,EAAI,AAAQ,EAAR,EAAY,CAA9C,EAEiC,CAAA,AADnB,EAAQ,GAAK,EAAY,EACE,EAAQ,CAAA,CACnD,CAEA,OAAO,YAA8C,OAAO,MAAM,CAAC,CACjE,IAAK,YACL,MAAO,iBACP,aAAc,GACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,IAAK,KAAM,CAAE,EAClC,aAAc,CAAA,CAChB,EAAG,AAEH,QAAO,YAA8C,OAAO,MAAM,CAAC,CACjE,IAAK,QACL,MAAO,QACP,aAAc,EACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,GAAI,KAAM,CAAE,EACjC,aAAc,CAAA,CAChB,EAAG,AAEH,QAAO,aAA+C,CACpD,IAAK,eACL,MAAO,iBACP,YACE,8EACF,aAAc,EACd,KAAM,QACN,aAAc,CAAC,CAAA,aAAE,CAAY,CAAA,UAAE,CAAS,CAAE,GACxC,KAAK,KAAK,CAAC,EAAe,GAC5B,KAAM,CACJ,IAAK,EACL,IAAK,EACL,KAAM,CAAC,CAAA,UAAE,CAAS,CAAE,GAAK,EAAI,CAC/B,EACA,aAAc,CAAA,CAChB,CAAE,AAEF,QAAO,mBAAqD,CAC1D,IAAK,eACL,MAAO,gBACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,CAAC,CAAA,UAAE,CAAS,CAAE,GAAK,AAAC,CAAA,EAAY,CAAA,EAAK,EAC1C,KAAM,GACR,EACA,aAAc,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,AAAA,EAAwB,GAC5D,aAAc,CAAA,CAChB,CAAE,AAEF,QAAO,eAAiD,CACtD,IAAK,WACL,MAAO,WACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,EACL,KAAM,IACN,KAAM,KACR,EACA,aAAc,CAAC,CAAA,SAAE,CAAQ,CAAA,MAAE,CAAK,CAAE,GAChC,CAAA,EAAG,KAAK,KAAK,CAAC,AAAY,IAAZ,EAAmB,GAAO,IAAC,CAAC,CAC5C,aAAc,CAAA,EACd,iBAAkB,CAAA,CACpB,CAAE,AAEF,QAAO,WAA8C,CACnD,EAAU,WAAW,CACrB,EAAU,WAAW,CACrB,EAAU,kBAAkB,CAC5B,EAAU,YAAY,CACtB,EAAU,cAAc,CACzB,AAAC,AACJ,CDhRe,MAAA,UAAmB,EAChC,OAAO,KAAO,MAAO,AAErB,CAAA,KAAO,MAAO,AACd,CAAA,GAAK,MAAO,AACZ,CAAA,KACE,+LAAgM,AAClM,CAAA,SAAuC,CACrC,CACE,IAAK,QACL,MAAO,QACP,aAAc,EACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,GAAI,KAAM,CAAE,CACnC,EACA,CACE,IAAK,YACL,MAAO,iBACP,aAAc,GACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,IAAK,KAAM,CAAE,CACpC,EACA,AAAA,EAAU,kBAAkB,CAC5B,CACE,IAAK,WACL,MAAO,kBACP,aAAc,GACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,GACL,KAAM,CAAC,CAAA,UAAE,CAAS,CAAA,MAAE,CAAK,CAAE,GAAK,EAAK,CAAA,EAAY,CAAA,CACnD,EACA,aAAc,CAAC,CAAA,UAAE,CAAS,CAAA,MAAE,CAAK,CAAA,SAAE,CAAQ,CAAE,GAC3C,KAAK,KAAK,CAAC,EAAW,EAAY,EACtC,EACA,AAAA,EAA6B,AAAA,EAAO,cAAc,CAAE,QACpD,AAAA,EAAO,gBAAgB,CACvB,CACE,IAAK,aACL,MAAO,QACP,KAAM,QACN,SAAU,CACR,CACE,IAAK,aACL,MAAO,aACP,aAAc,UACd,KAAM,OACR,EACA,CACE,IAAK,aACL,MAAO,eACP,aAAc,UACd,KAAM,OACR,EACA,CACE,IAAK,YACL,MAAO,aACP,aAAc,UACd,KAAM,OACR,EACD,AACH,EACD,AAAC,AAEF,EAAA,CAAK,CAAc,IAAK,AACxB,EAAA,CAAO,AAAS,AAEhB,CAAA,WAAY,CACV,KAAK,CAAC,YAEN,GAAM,CAAA,MAAE,CAAK,CAAA,SAAE,CAAQ,CAAA,WAAE,CAAU,CAAA,UAAE,CAAS,CAAA,OAAE,EAAS,CAAA,CAAG,CAAG,IAAI,CAAC,MAAM,CACpE,EAA6B,CACjC,KAAM,IAAI,CAAC,IAAI,CACf,EAAG,EAAY,EACf,OAAA,EACA,SAAU,EAAW,EAAW,EAAQ,EACxC,WAAA,CACF,CAEI,CAAA,IAAI,CAAC,CAAA,CAAO,CACd,IAAI,CAAC,CAAA,CAAO,CAAC,SAAS,CAAC,GAEvB,IAAI,CAAC,CAAA,CAAO,CAAG,IAAI,EAAO,GAG5B,IAAM,EAA8B,CAClC,GAAG,IAAI,CAAC,MAAM,CACd,OAAQ,IAAI,CAAC,CAAA,CAAO,CAAC,MAAM,CAC3B,KAAM,IAAI,CAAC,IAAI,AACjB,CAEI,CAAA,IAAI,CAAC,CAAA,CAAK,CACZ,IAAI,CAAC,CAAA,CAAK,CAAC,SAAS,CAAC,GAErB,IAAI,CAAC,CAAA,CAAK,CAAG,IAAI,EAAU,EAE/B,CAEA,YAAY,CAAA,KACV,CAAI,CAAA,UACJ,CAAS,CAIV,CAAe,CACd,OAAO,IAAI,CAAC,CAAA,CAAO,CAAC,QAAQ,CAAC,EAAO,IAAI,CAAC,MAAM,CAAC,SAAS,CAAG,EAC9D,CAEA,CAAC,UAA4B,CAC3B,GAAM,CAAA,WAAE,CAAU,CAAE,CAAG,IAAI,CAAC,MAAM,CAElC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GACvB,MAAO,IAAI,CAAC,CAAA,CAAK,CAAC,eAAe,CAAC,IAAI,CAAC,QAAQ,CACjD,CAEA,CAAC,YAA8B,CAC7B,GAAM,CAAA,WAAE,CAAU,CAAA,MAAE,CAAK,CAAA,UAAE,CAAS,CAAE,CAAG,IAAI,CAAC,MAAM,CACpD,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAEvB,IAAI,EAAY,IAAI,CAAC,CAAA,CAAK,CAAC,QAAQ,CAAC,EAAG,GACnC,EAAY,CAAA,EACZ,EAAS,CAAA,EAEP,EAAS,EAAQ,EAAI,KAAK,IAAI,CAAC,EAAY,GAAK,EAClD,EAAO,EACL,EAAgB,EAAQ,EAAI,AAAQ,EAAR,EAAY,AAAQ,EAAR,EAE9C,IAAK,IAAI,EAAQ,EAAG,GAAS,EAAQ,IAAS,CAC5C,IAAM,EACJ,EAAiB,CAAA,IAAU,EAAS,AAAQ,EAAR,EAAY,CAAA,EAElD,IAAK,IAAI,EAAI,EAAG,EAAI,EAAmB,IAAK,CAC1C,IAAM,EAAgB,CACpB,KAAA,EACA,UAAW,EAAY,EAAY,EAAQ,EAAI,CACjD,EAEM,EAAY,EACd,IAAI,CAAC,CAAA,CAAK,CAAC,QAAQ,CAAC,EAAc,IAAI,CAAE,EAAc,SAAS,EAC/D,IAAI,CAAC,WAAW,CAAC,GAErB,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAW,GACrC,EAAY,EAEZ,MACA,CAAA,EAAS,CAAC,CAAV,IAGE,EAAO,IAAS,EAAQ,EAAI,EAAO,EAAI,EACvC,EAAY,CAAC,EAEjB,CACA,EAAY,IAAI,CAAC,CAAA,CAAK,CAAC,QAAQ,CAAC,EAAG,EAAQ,EAC7C,CACF,CAEA,CAAC,iBAAmC,CAClC,MAAO,IAAI,CAAC,UAAU,GAEtB,GAAM,CAAA,SAAE,CAAQ,CAAA,UAAE,CAAS,CAAE,CAAG,IAAI,CAAC,MAAM,AAEvC,AAAa,CAAA,IAAb,GACF,CAAA,MAAO,IAAI,CAAC,CAAA,CAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAE,CAC1C,SAAA,EACA,MAAO,CACT,EAAA,EAEF,MAAO,IAAI,CAAC,QAAQ,EACtB,CAEA,WAAkB,CAChB,IAAI,CAAC,CAAA,CAAO,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,EACjC,IAAI,CAAC,CAAA,CAAK,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,EAC/B,IAAI,CAAC,CAAA,CAAO,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CACnC,CAEA,CAAA,CAAmB,GACjB,GAAM,CAAA,MAAE,CAAK,CAAA,UAAE,CAAS,CAAE,CAAG,IAAI,CAAC,MAAM,CAIxC,MAAQ,AAAA,CAAA,AAHa,CAAA,EAAQ,EAAI,KAAK,IAAI,CAAC,EAAY,GAAK,CAA5D,EAGuB,CAAA,EAFD,CAAA,EAAQ,EAAI,AAAQ,EAAR,EAAY,AAAQ,EAAR,CAAQ,EAEV,AAAQ,EAAR,CAC9C,CAEA,cAAuB,CACrB,GAAM,CAAA,MAAE,CAAK,CAAA,UAAE,CAAS,CAAA,SAAE,CAAQ,CAAE,CAAG,IAAI,CAAC,MAAM,CAKlD,OAAO,AAFa,IAAI,CAAC,CAAA,CAAmB,GAD1B,CAAA,EAAW,EAAY,EAAQ,CAAA,EAE/B,AAAA,EAAU,YAAY,CAAC,IAAI,CAAC,MAAM,CAEtD,CAEA,OAAO,gBAAkB,CACvB,UAAW,EACb,CAAE,AACJ,CErNA,MAAM,EAAiB,CACrB,CAAE,KAAM,IAAM,IAAK,EAAG,MAAO,SAAU,EACvC,CAAE,KAAM,KAAO,IAAK,KAAO,MAAO,SAAU,EAC5C,CAAE,KAAM,EAAG,IAAK,KAAO,MAAO,UAAW,QAAS,CAAA,CAAK,EACxD,AA8Cc,OAAA,UAAwB,EACrC,OAAO,KAAO,WAAY,AAE1B,CAAA,KAAO,WAAY,AACnB,CAAA,GAAK,WAAY,AACjB,CAAA,KACE,kFAAmF,AACrF,CAAA,SAA4C,CAC1C,AAAA,EAAO,WAAW,CAClB,AAAA,EAAO,cAAc,CACrB,AAAA,EAAO,gBAAgB,CACvB,CACE,IAAK,SACL,MAAO,SACP,KAAM,QAEN,SAAU,EAAe,GAAG,CAAC,CAAC,CAAA,KAAE,CAAI,CAAA,IAAE,CAAG,CAAA,MAAE,CAAK,CAAA,QAAE,CAAO,CAAE,CAAE,KAC3D,IAAM,EAAQ,EAAI,EAClB,MAAO,CACL,IAAK,CAAC,KAAK,EAAE,EAAA,CAAO,CACpB,MAAO,CAAC,MAAM,EAAE,EAAA,CAAO,CACvB,KAAM,QACN,SAAU,CACR,CACE,IAAK,CAAC,IAAI,EAAE,EAAA,CAAO,CACnB,MAAO,SACP,aAAc,CAAA,EACd,KAAM,UACR,EACA,CACE,IAAK,CAAC,IAAI,EAAE,EAAA,CAAO,CACnB,MAAO,OACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,GACL,KAAM,CAAC,CAAA,EAAE,CAAC,CAAE,GAAK,EAAI,CACvB,EACA,aAAc,AAAA,GACZ,KAAK,KAAK,CAAC,EAAO,CAAC,CAAG,CAAM,CAAC,CAAC,IAAI,EAAE,EAAA,CAAO,CAAC,EAC9C,KAAM,AAAA,GAAU,CAAM,CAAC,CAAC,IAAI,EAAE,EAAA,CAAO,CAAC,AACxC,EACA,CACE,IAAK,CAAC,GAAG,EAAE,EAAA,CAAO,CAClB,MAAO,eACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,EACL,KAAM,CAAC,CAAA,EAAE,CAAC,CAAE,GAAK,EAAI,CACvB,EACA,aAAc,AAAA,GACZ,KAAK,KAAK,CAAC,EAAO,CAAC,CAAG,CAAM,CAAC,CAAC,GAAG,EAAE,EAAA,CAAO,CAAC,EAC7C,KAAM,AAAA,GAAU,CAAM,CAAC,CAAC,IAAI,EAAE,EAAA,CAAO,CAAC,AACxC,EACA,CACE,IAAK,CAAC,KAAK,EAAE,EAAA,CAAO,CACpB,MAAO,QACP,aAAc,EACd,KAAM,QACN,KAAM,AAAA,GAAU,CAAM,CAAC,CAAC,IAAI,EAAE,EAAA,CAAO,CAAC,AACxC,EACA,CACE,IAAK,CAAC,OAAO,EAAE,EAAA,CAAO,CACtB,MAAO,UACP,aAAc,AAAY,CAAA,IAAZ,EACd,KAAM,WACN,KAAM,AAAA,GAAU,CAAM,CAAC,CAAC,IAAI,EAAE,EAAA,CAAO,CAAC,AACxC,EACD,AACH,CACF,EACF,EACD,AAAC,AAEF,EAAA,CAAO,AAAS,AAChB,EAAA,CAAK,AAAQ,AAEb,CAAA,WAAY,CACV,KAAK,CAAC,YACN,IAAI,CAAC,CAAA,CAAK,CAAG,IAAI,CAAC,CAAA,CAAQ,EAC5B,CAEA,CAAA,CAAQ,GACN,IAWI,EAXE,CAAA,SAAE,CAAQ,CAAA,EAAE,CAAC,CAAA,OAAE,EAAS,CAAA,CAAA,WAAG,CAAU,CAAE,CAAG,IAAI,CAAC,MAAM,CAGrD,EAA6B,CACjC,KAHW,IAAI,CAAC,OAAO,GAIvB,EAAA,EACA,OAAA,EACA,SAAU,EAAW,IACrB,WAAA,CACF,CAGI,CAAA,IAAI,CAAC,CAAA,CAAK,EAAE,QACd,EAAS,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAC1B,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,SAAS,CAAC,IAE5B,EAAS,IAAI,EAAO,GAGtB,IAAI,EAAc,EAAO,UAAU,CAAG,EAAO,MAAM,CAC7C,EAAgB,KAAK,KAAK,CAAC,EAAO,MAAM,CAAG,GAAe,EAChE,GACG,AAAA,CAAA,EAAO,MAAM,CAAG,EAAc,CAAA,EAAiB,EAClD,IAAM,EAAmB,EAAO,QAAQ,CAAC,GACnC,EAAiB,EAAgB,EAOvC,MAAO,CACL,OAAA,EACA,YAAA,EACA,cAAA,EACA,iBAAA,EACA,OAVa,KAAU,CACtB,IAAI,CAAC,MACL,GAAG,CAAC,CAAC,EAAG,IAAM,EAAS,IAAI,CAAC,IAAI,CAAE,EAAI,IACtC,MAAM,CAAC,CAAC,CAAA,OAAE,CAAM,CAAE,GAAK,GAQxB,eAAA,EACA,gBAbsB,EAAiB,CAczC,EAEA,SAAS,EAAS,CAAkB,EAClC,IAAM,EACJ,KAAK,KAAK,CAAC,EAAI,IAAI,CAAC,MAAM,CAAC,OAAS,EAAW,EAAI,EACrD,MAAO,CACL,KAAA,EACA,SACE,KAAK,KAAK,CACR,IAAI,CAAC,MAAM,CAAC,MAAQ,EAAW,CAAI,CAAA,EAAiB,CAAA,GAClD,EACN,MAAO,IAAI,CAAC,MAAM,CAAC,QAAU,EAAW,CACxC,OAAQ,IAAI,CAAC,MAAM,CAAC,OAAS,EAAW,CACxC,UAAW,IAAI,CAAC,MAAM,CAAC,UAAY,EAAW,AAChD,CACF,CACF,CAKA,SAAS,CAAa,CAAe,CACnC,GAAI,EAAQ,IAAI,CAAC,CAAA,CAAK,CAAC,aAAa,EAAI,EAAQ,IAAI,CAAC,CAAA,CAAK,CAAC,cAAc,CAAE,CAMzE,IAAM,EAAc,AAJlB,CAAA,EAAQ,IAAI,CAAC,CAAA,CAAK,CAAC,aAAa,CAC5B,IAAI,CAAC,CAAA,CAAK,CAAC,aAAa,CAAG,EAC3B,EAAQ,IAAI,CAAC,CAAA,CAAK,CAAC,cAAc,AAAd,EAEU,IAAI,CAAC,CAAA,CAAK,CAAC,WAAW,CACzD,MAAO,CACL,IAAI,CAAC,CAAA,CAAK,CAAC,gBAAgB,CAAC,EAAE,CAC5B,EAAc,KAAK,GAAG,CAAC,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,aAAa,EACxD,IAAI,CAAC,CAAA,CAAK,CAAC,gBAAgB,CAAC,EAAE,CAC5B,EAAc,KAAK,GAAG,CAAC,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,aAAa,EACzD,AACH,CAAO,CACL,IAAM,EAAc,EAAQ,IAAI,CAAC,CAAA,CAAK,CAAC,aAAa,CACpD,OAAO,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,EACpC,CACF,CAEA,CAAC,WAAW,CAAA,SAAE,CAAQ,CAAA,MAAE,CAAK,CAAA,UAAE,CAAS,CAAA,KAAE,CAAI,CAAE,CAAmB,CAGjE,IAFI,EACA,EACA,EAAa,CAAA,EACjB,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GACvB,IAAM,EAAO,IAAI,CACX,EAAU,EAAY,GAAK,EAEjC,IAAK,IAAI,EAAQ,EAAG,GAAS,EAAU,IAAS,CAC9C,IAAM,EAAa,GAAa,IAAI,CAAC,QAAQ,CAAC,EAAc,IACtD,EAAY,EAAE,AAChB,CAAA,GACF,EAAU,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAiB,IAEhD,EAAiB,EAAc,EAAa,EAAQ,EAAQ,GAC5D,EAAU,IAAI,CAAE,EAAY,IAAI,CAAC,QAAQ,CAAC,IAE1C,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,KAAe,GAEzC,MAEA,EAAa,CAAC,CAChB,CAEA,SAAS,EAAc,CAAa,EAClC,OAAO,EAAY,EAAK,CAAA,CAAK,CAAC,eAAe,CAAG,EAAQ,CAC1D,CACF,CAEA,CAAC,iBAAkB,CACjB,IAAK,IAAM,KAAS,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CACnC,MAAO,IAAI,CAAC,UAAU,CAAC,EAE3B,CAEA,WAAY,CACV,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAE,CACtC,iBAAkB,IAAI,CAAC,CAAA,CAAK,CAAC,aAAa,AAC5C,GAEA,IAAK,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,CAAA,CAAK,CAAC,aAAa,CAAE,IAC5C,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAE,MAAO,IAAI,CAAC,QAAQ,CAAC,GAAI,OAAQ,CAAE,EAE5D,CAEA,cAAuB,CACrB,GAAM,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,CAAA,CAAQ,GAChC,OAAO,EAAO,MAAM,CAClB,CAAC,EAAW,IAAU,EAAY,EAAM,QAAQ,CAAG,EACnD,EAEJ,CAEA,OAAO,gBAAkB,CACvB,EAAG,EACL,CAAE,AACJ,CC3OA,MAAM,EAAiB,CACrB,MAAO,WACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,EAAI,EAAI,IACb,KAAM,EAAI,GACZ,EACA,aAAc,CAAA,EACd,iBAAkB,CAAA,CACpB,CAgBe,OAAA,UAAwB,EACrC,OAAO,KAAO,WAAY,AAE1B,CAAA,KAAO,WAAY,AACnB,CAAA,GAAK,WAAY,AACjB,CAAA,KACE,kFAAmF,AACrF,CAAA,SAA4C,CAC1C,CACE,IAAK,IACL,MAAO,eACP,aAAc,GACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,IAAK,KAAM,CAAE,CACpC,EACA,CACE,IAAK,kBACL,MAAO,oBACP,aAAc,GACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,IAAK,KAAM,CAAE,CACpC,EACA,CACE,IAAK,QACL,MAAO,QACP,aAAc,UACd,KAAM,OACR,EACA,CACE,IAAK,SACL,MAAO,SACP,KAAM,QACN,SAAU,CACR,CACE,IAAK,SACL,MAAO,UACP,KAAM,QACN,SAAU,CACR,CACE,IAAK,QACL,MAAO,SACP,aAAc,CAAA,EACd,KAAM,UACR,EACA,CACE,IAAK,UACL,MAAO,SACP,aAAc,GACd,KAAM,QACN,KAAM,CAAE,IAAK,IAAM,IAAK,EAAG,KAAM,GAAK,EACtC,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,CACvB,EACA,CACE,IAAK,KACL,MAAO,aACP,aAAc,GACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,EAAG,KAAM,GAAK,EACnC,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,CACvB,EACA,CACE,IAAK,KACL,MAAO,aACP,aAAc,EACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,EAAG,KAAM,GAAK,EACnC,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,CACvB,EACA,CACE,GAAG,CAAc,CACjB,IAAK,YACL,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,EACrB,aAAc,CAAC,CAAA,UAAE,CAAS,CAAE,GAC1B,CAAA,EAAG,KAAK,KAAK,CAAC,AAAY,IAAZ,GAAiB,IAAC,CAAC,AACrC,EACA,CACE,IAAK,WACL,MAAO,UACP,aAAc,CAAA,EACd,KAAM,WACN,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,CACvB,EACD,AACH,EACA,CACE,IAAK,SACL,MAAO,UACP,KAAM,QACN,SAAU,CACR,CACE,IAAK,QACL,MAAO,SACP,aAAc,CAAA,EACd,KAAM,UACR,EACA,CACE,IAAK,UACL,MAAO,SACP,aAAc,GACd,KAAM,QACN,KAAM,CAAE,IAAK,IAAM,IAAK,EAAG,KAAM,GAAK,EACtC,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,CACvB,EACA,CACE,IAAK,KACL,MAAO,aACP,aAAc,EACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,EAAG,KAAM,GAAK,EACnC,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,CACvB,EACA,CACE,IAAK,KACL,MAAO,aACP,aAAc,EACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,EAAG,KAAM,GAAK,EACnC,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,CACvB,EACA,CACE,GAAG,CAAc,CACjB,IAAK,YACL,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,EACrB,aAAc,CAAC,CAAA,UAAE,CAAS,CAAE,GAC1B,CAAA,EAAG,KAAK,KAAK,CAAC,AAAY,IAAZ,GAAiB,IAAC,CAAC,AACrC,EACA,CACE,IAAK,WACL,MAAO,UACP,aAAc,CAAA,EACd,KAAM,WACN,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,CACvB,EACD,AACH,EACA,CACE,IAAK,SACL,MAAO,UACP,KAAM,QACN,SAAU,CACR,CACE,IAAK,QACL,MAAO,SACP,aAAc,CAAA,EACd,KAAM,UACR,EACA,CACE,IAAK,UACL,MAAO,SACP,aAAc,GACd,KAAM,QACN,KAAM,CAAE,IAAK,IAAM,IAAK,EAAG,KAAM,GAAK,EACtC,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,CACvB,EACA,CACE,IAAK,KACL,MAAO,aACP,aAAc,EACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,EAAG,KAAM,GAAK,EACnC,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,CACvB,EACA,CACE,IAAK,KACL,MAAO,aACP,aAAc,EACd,KAAM,QACN,KAAM,CAAE,IAAK,EAAG,IAAK,EAAG,KAAM,GAAK,EACnC,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,CACvB,EACA,CACE,GAAG,CAAc,CACjB,IAAK,YACL,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,EACrB,aAAc,CAAC,CAAA,UAAE,CAAS,CAAE,GAC1B,CAAA,EAAG,KAAK,KAAK,CAAC,AAAY,IAAZ,GAAiB,IAAC,CAAC,AACrC,EACA,CACE,IAAK,WACL,MAAO,UACP,aAAc,CAAA,EACd,KAAM,WACN,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,CACvB,EACD,AACH,EACD,AACH,EACD,AAAC,AAEF,EAAA,CAAK,AAAQ,AAEb,CAAA,WAAY,CACV,KAAK,CAAC,YACN,IAAI,CAAC,CAAA,CAAK,CAAG,IAAI,CAAC,OAAO,EAC3B,CAEA,SAAiB,CACf,GAAM,CAAA,EAAE,CAAC,CAAA,OAAE,EAAS,CAAA,CAAA,gBAAG,CAAe,CAAE,CAAG,IAAI,CAAC,MAAM,CAChD,EAAO,IAAI,CAAC,OAAO,GAEnB,EAAY,KAAK,GAAG,IAAI,EAAK,GAAG,CAAC,AAAA,GAAK,EAAI,EAAI,IAAW,EACzD,EAAS,KAAU,CACtB,IAAI,CAAC,MACL,GAAG,CAAC,CAAC,EAAG,IAAM,EAAS,IAAI,CAAC,IAAI,CAAE,EAAI,IACtC,MAAM,CAAC,CAAC,CAAA,OAAE,CAAM,CAAE,GAAK,GAEpB,EAAqB,KAAK,GAAG,IAC9B,EAAO,GAAG,CAAC,CAAC,CAAA,OAAE,CAAM,CAAE,GAAK,EAAO,MAAM,CAAC,CAAC,GAG/C,MAAO,CACL,OAAA,EACA,mBAAA,CACF,EAEA,SAAS,EAAS,CAAkB,EAClC,IAAM,EAAO,AAAC,GAAiB,IAAI,CAAC,MAAM,CAAC,EAAO,EAAW,CAEvD,EAAQ,CACZ,OAAQ,EAAK,QACb,UAAW,EAAK,WAChB,SAAU,CAAC,EAAK,KAAM,EAAK,KAAK,CAChC,OAAQ,EAAY,EAAK,UACzB,SAAU,EAAK,WACjB,EAGM,EAAc,KAAK,GAAG,CAC1B,EACA,KAAK,KAAK,CAAC,AAHoB,EAAV,KAAK,EAAE,CAAO,EAAM,MAAM,CAGnB,IAe9B,MAAO,CACL,OAba,IAAI,EAAO,CACxB,OAAQ,EAAM,MAAM,CACpB,KAAM,IAAI,CAAC,IAAI,CACf,OAAQ,EAAM,QAAQ,CAAC,GAAG,CACxB,CAAC,EAAG,IACF,EAAM,MAAM,CAAG,EAAU,AAAA,CAAA,CAAI,CAAC,EAAE,CAAI,AAAA,CAAA,EAAM,MAAM,CAAG,CAAA,EAAU,CAAA,EAAK,GAEtE,EAAG,EACH,SAAU,EAAM,QAAQ,CACxB,QAAS,EAAM,SAAS,AAC1B,GAIE,GAAG,CAAK,AACV,CACF,CACF,CAEA,SAAS,CAAY,CAAE,CAAa,CAAe,CACjD,GAAM,CAAA,OAAE,CAAM,CAAE,CAAG,EACf,EAAc,KAAK,KAAK,CACzB,EAAQ,EAAO,MAAM,CAAC,CAAC,CAAI,IAAI,CAAC,CAAA,CAAK,CAAC,kBAAkB,EAE3D,OAAO,EAAO,QAAQ,CAAC,EACzB,CAEA,CAAC,iBAAmC,CAClC,IAGI,EAHE,CAAA,MAAE,CAAK,CAAE,CAAG,IAAI,CAAC,MAAM,CAE7B,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAGvB,IAAK,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,CAAA,CAAK,CAAC,kBAAkB,CAAE,IACjD,IACE,IAAI,EAAa,EACjB,EAAa,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,MAAM,CACrC,IACA,CACA,IAAM,EAAQ,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,EAAW,CACrC,EAAa,GAAmB,IAAI,CAAC,QAAQ,CAAC,EAAO,GAErD,EAA2B,EAAE,AAC/B,AAAe,CAAA,IAAf,GAAoB,GACtB,EAAU,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAO,IAGtC,IAAI,EAAiB,EAAa,CAC9B,CAAA,IAAmB,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,MAAM,EAC7C,CAAA,EAAiB,CAAA,EAGnB,EAAkB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,EAAe,CAAE,GAEnE,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAY,GACtC,KACF,CAEJ,CAEA,WAAY,CACV,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAA,OAAE,CAAM,CAAE,CAAE,IACrC,EAAO,SAAS,CAAC,IAAI,CAAC,KAAK,CAAE,CAC3B,UAAW,AAAA,GAAK,CAAA,EAAG,EAAa,EAAE,CAAC,EAAE,EAAI,EAAA,CAAG,AAC9C,GAEJ,CAEA,cAAe,CACb,GAAM,CAAA,OAAE,CAAM,CAAA,mBAAE,CAAkB,CAAE,CAAG,IAAI,CAAC,OAAO,GACnD,OAAO,EAAO,MAAM,CAAG,EAAqB,CAC9C,CAEA,OAAO,gBAAkB,CACvB,gBAAiB,EACjB,EAAG,EACL,CAAE,AACJ,CE5Ue,MAAA,EACb,MAAsB,AACtB,EAAA,CAAO,AAA2B,AAClC,EAAA,CAAK,AAAQ,AAEb,aAAY,CAAqB,CAAE,CACjC,IAAI,CAAC,SAAS,CAAC,EACjB,CAEA,UAAU,CAAqB,CAAE,CAC/B,GAAI,CAAC,AAAA,EAAe,EAAQ,IAAI,CAAC,MAAM,IACrC,IAAI,CAAC,MAAM,CAAG,EAEV,IAAI,CAAC,CAAA,CAAO,CACd,IAAI,CAAC,CAAA,CAAO,CAAC,KAAK,GAElB,IAAI,CAAC,CAAA,CAAO,CAAG,IAAI,IAGrB,IAAI,CAAC,CAAA,CAAK,CAAG,IAAI,CAAC,CAAA,CAAQ,GAEtB,EAAO,OAAO,EAAE,CAClB,IAAM,EAAgB,IAAI,CAAC,CAAA,CAAiB,GAC5C,IAAI,CAAC,CAAA,CAAO,CAAC,KAAK,GAClB,IAAI,CAAC,CAAA,CAAK,CAAG,CAAE,GAAG,IAAI,CAAC,CAAA,CAAQ,EAAE,CAAE,GAAG,CAAa,AAAC,CACtD,CAEJ,CAEA,CAAA,CAAiB,GAIf,GAAM,CAAE,KAAM,CAAU,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,MAAM,CAE1C,EAAe,IAAI,CAAC,eAAe,GACnC,EAAQ,KAAK,GAAG,CACpB,AAAC,CAAA,CAAU,CAAC,EAAE,CAAG,EAAI,CAAA,EAAU,EAAa,KAAK,CAChD,AAAA,CAAA,CAAU,CAAC,EAAE,CAAG,EAAI,CAAA,EAAU,EAAa,MAAM,EAWpD,MAAO,CAAE,KARI,EAAW,GAAG,CAAC,AAAA,GAAK,EAAI,GAQtB,OAPA,CACb,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,EAAE,CAClB,EAAU,CAAA,EAAa,IAAI,CAAG,CAAU,CAAC,EAAE,CAAG,EAAa,KAAK,AAAL,EAAU,EACvE,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,EAAE,CAClB,EAAU,CAAA,EAAa,GAAG,CAAG,CAAU,CAAC,EAAE,CAAG,EAAa,MAAM,AAAN,EAAW,EACxE,AAEqB,CACxB,CAEA,CAAA,CAAQ,GACN,GAAM,CAAA,KACJ,CAAI,CAAA,SACJ,EAAW,CAAA,CACX,MAAO,CAAS,CAChB,OAAQ,CAAY,CAAA,OACpB,CAAM,CAAA,aACN,CAAY,CACb,CAAG,IAAI,CAAC,MAAM,CAET,EAAY,AAAA,EAAM,EAElB,EAA6B,AAAI,MAAM,GAC1C,IAAI,CAAC,MACL,GAAG,CAAC,CAAC,EAAG,KACP,IAAM,EAAQ,EAAY,EAAI,AAAA,EAAM,EAC9B,EAAc,CAAC,EAAa,CAAA,EAAI,EAAA,EAAO,AAAA,EAAM,EAEnD,MAAO,CACL,IAAK,KAAK,GAAG,CAAC,GACd,IAAK,KAAK,GAAG,CAAC,GACd,OAAQ,CACN,IAAK,KAAK,GAAG,CAAC,GACd,IAAK,KAAK,GAAG,CAAC,EAChB,CACF,CACF,GAEI,EACJ,GAAiB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,AAAA,GAAK,EAAI,GAE3C,EAAS,KAAK,GAAG,IAAI,GAAQ,EAAI,EACjC,EAAW,EAAI,EAAS,KAAK,GAAG,CAAC,EAAY,GAC7C,EAAqB,CACzB,EAAS,KAAK,GAAG,CAAC,EAAY,GAC9B,EAAS,KAAK,GAAG,CAAC,EAAY,GAC/B,CACK,EAAgB,EAAW,EAC3B,EAAmB,KAAK,KAAK,CAAC,EAAS,GAG7C,MAAO,CACL,aAAc,EAAI,EAClB,OAAA,EACA,OAAA,EACA,SAAA,EACA,MAAA,EACA,cAAA,EACA,iBAAA,EACA,oBAV0B,EAAS,EAWnC,MAAA,EACA,UAAA,CACF,CACF,CAEA,IAAI,cAAuB,CACzB,OAAO,IAAI,CAAC,CAAA,CAAK,CAAC,YAAY,AAChC,CAEA,IAAI,kBAA2B,CAC7B,OAAO,IAAI,CAAC,CAAA,CAAK,CAAC,gBAAgB,AACpC,CAEA,IAAI,UAAmB,CACrB,OAAO,IAAI,CAAC,CAAA,CAAK,CAAC,QAAQ,AAC5B,CAEA,aAAa,CAAA,KAAE,CAAI,CAAA,MAAE,CAAK,CAAE,CAAe,CACzC,IAAM,EAAiB,CAAC,EAAM,EAAM,CAAC,IAAI,CAAC,KAE1C,GAAI,IAAI,CAAC,CAAA,CAAO,CAAC,GAAG,CAAC,GACnB,OAAO,IAAI,CAAC,CAAA,CAAO,CAAC,GAAG,CAAC,GAG1B,IAAM,EAAS,IAAI,CAAC,CAAA,CAAK,CAAC,KAAK,CAAC,EAAE,CAAG,EAAQ,IAAI,CAAC,CAAA,CAAK,CAAC,aAAa,CAC/D,CAAA,IAAE,CAAG,CAAA,IAAE,CAAG,CAAE,CAAG,IAAI,CAAC,CAAA,CAAK,CAAC,KAAK,CAAC,EAAK,CAErC,EAAQ,CACZ,EAAM,EAAS,EAAM,IAAI,CAAC,CAAA,CAAK,CAAC,KAAK,CAAC,EAAE,CAAG,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,EAAE,CAC/D,EAAM,EAAS,EAAM,IAAI,CAAC,CAAA,CAAK,CAAC,KAAK,CAAC,EAAE,CAAG,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,EAAE,CAChE,CAGD,OADA,IAAI,CAAC,CAAA,CAAO,CAAC,GAAG,CAAC,EAAgB,GAC1B,CACT,CAEA,eAAe,CAAA,KAAE,CAAI,CAAA,MAAE,CAAK,CAAE,CAAe,CAC3C,IAAM,EAAS,EAAQ,IAAI,CAAC,CAAA,CAAK,CAAC,mBAAmB,CAC/C,CAAA,IAAE,CAAG,CAAA,IAAE,CAAG,CAAE,CAAG,IAAI,CAAC,CAAA,CAAK,CAAC,KAAK,CAAC,EAAK,CAAC,MAAM,CAElD,MAAO,CACL,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,EAAE,CAAG,EAAM,EAC7B,IAAI,CAAC,CAAA,CAAK,CAAC,MAAM,CAAC,EAAE,CAAG,EAAM,EAC9B,AACH,CAEA,iBAAgC,CAC9B,IAAM,EAAS,IAAI,CAAC,CAAA,CAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAG,IACtC,IAAI,CAAC,YAAY,CAAC,CAAE,KAAA,EAAM,MAAO,CAAE,IAE/B,EAAa,CAAM,CAAC,EAAE,CAEtB,EAAe,EAAO,KAAK,CAAC,GAAG,MAAM,CACzC,CAAC,EAAc,CAAC,EAAG,EAAE,GAAM,CAAA,CACzB,KAAM,KAAK,GAAG,CAAC,EAAa,IAAI,CAAE,GAClC,MAAO,KAAK,GAAG,CAAC,EAAa,KAAK,CAAE,GACpC,IAAK,KAAK,GAAG,CAAC,EAAa,GAAG,CAAE,GAChC,OAAQ,KAAK,GAAG,CAAC,EAAa,MAAM,CAAE,EACxC,CAAA,EACA,CACE,KAAM,CAAU,CAAC,EAAE,CACnB,MAAO,CAAU,CAAC,EAAE,CACpB,IAAK,CAAU,CAAC,EAAE,CAClB,OAAQ,CAAU,CAAC,EAAE,AACvB,GAGF,MAAO,CACL,GAAG,CAAY,CACf,OAAQ,EAAa,MAAM,CAAG,EAAa,GAAG,CAC9C,MAAO,EAAa,KAAK,CAAG,EAAa,IAAI,AAC/C,CACF,CAEA,UACE,CAAY,CACZ,CAAA,WACE,EAAa,CAAA,CAAA,CAAA,UACb,EAAY,CAAA,CAAA,CAAA,kBACZ,CAAiB,CAKlB,CAAG,CAAC,CAAC,CACN,CACA,IAAK,IAAI,EAAO,EAAG,EAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAE,IAAQ,CACnD,IAAM,EAAiB,EAAO,IAAI,CAAC,CAAA,CAAK,CAAC,YAAY,CAErD,GAAI,EACF,IAAK,IAAI,EAAQ,EAAG,EAAQ,IAAI,CAAC,CAAA,CAAK,CAAC,YAAY,CAAE,IACnD,EAAM,OAAO,CAAC,CACZ,MAAO,IAAI,CAAC,YAAY,CAAC,CAAE,KAAA,EAAM,MAAA,CAAM,GACvC,OAAQ,EAAiB,CAC3B,GAIJ,GAAI,EACF,IAAK,IAAI,EAAQ,EAAG,EAAQ,IAAI,CAAC,CAAA,CAAK,CAAC,gBAAgB,CAAE,IACnD,CAAA,CAAC,GAAqB,EAAkB,EAAM,EAAA,GAChD,EAAM,OAAO,CAAC,CACZ,MAAO,IAAI,CAAC,cAAc,CAAC,CAAE,KAAA,EAAM,MAAA,CAAM,GACzC,OAAQ,CAAA,EAAG,EAAK,CAAC,EAAE,EAAA,CAAO,AAC5B,EAIR,CACF,CAEA,OAAO,eAAqE,CAC1E,IAAK,WACL,MAAO,WACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,EACL,KAAM,GACR,EACA,aAAc,CAAC,CAAA,SAAE,CAAQ,CAAA,MAAE,CAAK,CAAE,GAChC,CAAA,EAAG,KAAK,KAAK,CAAC,AAAY,IAAZ,EAAmB,GAAO,IAAC,CAAC,CAC5C,aAAc,CAAA,EACd,iBAAkB,CAAA,CACpB,CAAE,AACJ,CDrQA,MAAM,EAAe,AAAA,EAAM,SAAS,CAAC,CACnC,SAAU,CACR,aAAc,CAAA,EACd,MAAO,UACP,gBAAiB,EACjB,gBAAiB,EACjB,sBAAuB,CAAA,EACvB,aAAc,GACd,aAAc,EAChB,EACA,QAAS,CAAC,aAAa,AACzB,EAEe,OAAA,UAA6B,EAC1C,OAAO,KAAO,SAAU,AAExB,CAAA,KAAO,SAAU,AACjB,CAAA,GAAK,SAAU,AACf,CAAA,SAAiD,CAC/C,CACE,IAAK,QACL,MAAO,QACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,GACL,KAAM,CACR,CACF,EACA,CACE,IAAK,IACL,MAAO,iBACP,aAAc,GACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,IACL,KAAM,CACR,CACF,EACA,CACE,IAAK,SACL,MAAO,SACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,EACL,KAAM,CACR,EACA,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,EAAQ,CAC/B,EACA,AAAA,EAAQ,cAAc,CACtB,EACD,AAAC,AAEF,CAAA,cAAgB,CACd,WAAY,UACZ,WAAY,CACd,CAAE,AAEF,EAAA,CAAQ,AAAU,AAClB,CAAA,KAAa,AACb,CAAA,QAAmB,AAEnB,CAAA,WAAY,CACV,KAAK,CAAC,YACN,GAAM,CAAA,EAAE,CAAC,CAAA,SAAE,CAAQ,CAAA,MAAE,CAAK,CAAA,OAAE,CAAM,CAAA,aAAE,CAAY,CAAE,CAAG,IAAI,CAAC,MAAM,CAG1D,EAA+B,CACnC,MAAA,EACA,SAAU,EAAY,CAAA,AAAQ,EAAR,CAAQ,EAC9B,OAAA,EACA,KANW,IAAI,CAAC,OAAO,GAOvB,aAAc,EAAI,EAClB,QAAS,CAAA,CACX,CAEI,CAAA,IAAI,CAAC,CAAA,CAAQ,CACf,IAAI,CAAC,CAAA,CAAQ,CAAC,SAAS,CAAC,GAExB,IAAI,CAAC,CAAA,CAAQ,CAAG,IAAI,EAAQ,GAG9B,IAAI,CAAC,KAAK,CAAG,IAAI,EAAM,CACrB,GAAG,IAAI,CAAC,MAAM,CACd,aAAA,EACA,WAAY,CACd,GAEI,EACF,IAAI,CAAC,QAAQ,CAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CACrC,UAAW,IAAI,CAAC,YAAY,GAC5B,WAAY,CACd,GAEA,IAAI,CAAC,QAAQ,CAAG,IAEpB,CAEA,CAAC,iBAAkB,CACjB,GAAM,CAAA,MAAE,CAAK,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,MAAM,CAC/B,EAAgB,KAAK,GAAG,CAAC,EAAQ,KAAK,IAAI,CAAC,EAAQ,GAAK,GAE1D,EAAO,EACX,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAE3C,IAAK,IAAI,EAAO,EAAG,EAAO,EAAO,IAAQ,CACvC,IAAM,EAAW,AAAC,CAAA,EAAO,CAAA,EAAiB,CAEtC,CAAA,IAAI,CAAC,QAAQ,EACf,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAE3C,IAAK,IAAI,EAAQ,EAAG,EAAQ,IAAI,CAAC,CAAA,CAAQ,CAAC,YAAY,CAAE,IACtD,IAAI,CAAC,QAAQ,CAAC,WAAW,CACvB,IAAI,CAAC,CAAA,CAAQ,CAAC,YAAY,CAAC,CAAE,KAAA,EAAM,MAAA,CAAM,GACzC,IAAI,CAAC,CAAA,CAAQ,CAAC,YAAY,CAAC,CAAE,KAAM,EAAU,MAAA,CAAM,IAGrD,MACA,GAEJ,CACF,CAEA,cAAe,CACb,GAAM,CAAA,MAAE,CAAK,CAAA,EAAE,CAAC,CAAE,CAAG,IAAI,CAAC,MAAM,CAChC,OAAO,EAAQ,CACjB,CAEA,WAAY,CACV,IAAI,CAAC,CAAA,CAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CACpC,CAEA,OAAO,gBAAkB,CACvB,EAAG,EACL,CAAE,AACJ,CE3IA,MAAM,EAAe,AAAA,EAAM,SAAS,CAAC,CACnC,SAAU,CACR,aAAc,CAAA,EACd,MAAO,UACP,gBAAiB,IACjB,gBAAiB,GACjB,sBAAuB,CAAA,EACvB,aAAc,GACd,aAAc,EAChB,EACA,QAAS,CAAC,aAAa,AACzB,EAEe,OAAA,UAAqB,EAClC,OAAO,KAAO,QAAS,AAEvB,CAAA,KAAO,QAAS,AAChB,CAAA,GAAK,QAAS,AACd,CAAA,KAAO,+CAAgD,AACvD,CAAA,SAAyC,CACvC,CACE,IAAK,QACL,MAAO,QACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,GACL,KAAM,CACR,CACF,EACA,CACE,IAAK,IACL,MAAO,iBACP,aAAc,GACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,IACL,KAAM,CACR,CACF,EACA,CACE,IAAK,SACL,MAAO,SACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,GACL,KAAM,CACR,CACF,EACA,AAAA,EAAQ,cAAc,CACtB,EACD,AAAC,AAEF,CAAA,cAAgB,CACd,WAAY,UACZ,WAAY,EACZ,YAAa,EACf,CAAE,AAEF,EAAA,CAAS,AAAyB,AAClC,CAAA,KAAa,AACb,CAAA,QAAmB,AAEnB,CAAA,WAAY,CACV,KAAK,CAAC,YACN,GAAM,CAAA,EAAE,CAAC,CAAA,SAAE,CAAQ,CAAA,MAAE,CAAK,CAAA,OAAE,CAAM,CAAA,OAAE,CAAM,CAAA,aAAE,CAAY,CAAE,CAAG,IAAI,CAAC,MAAM,CAClE,EAAO,IAAI,CAAC,OAAO,GAEnB,EAAkB,EAAK,CAAA,EAAQ,CAAA,CAErC,CAAA,IAAI,CAAC,CAAA,CAAS,CAAG,AAAI,MAAM,GAAQ,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,EAAG,IAS7C,IAAI,EARW,CACpB,MAAA,EACA,SAAU,EAAW,EAAQ,EAAI,EACjC,OAAA,EACA,KAAA,EACA,aAAc,EAAI,CACpB,IAKF,IAAI,CAAC,KAAK,CAAG,IAAI,EAAM,CACrB,GAAG,IAAI,CAAC,MAAM,CACd,aAAA,EACA,WAAY,CACd,GAEI,EACF,IAAI,CAAC,QAAQ,CAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CACrC,UAAW,IAAI,CAAC,YAAY,GAC5B,WAAY,CACd,GAEA,IAAI,CAAC,QAAQ,CAAG,IAEpB,CAEA,CAAC,iBAAkB,CACjB,GAAM,CAAA,MAAE,CAAK,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,MAAM,CAEjC,EAAO,EACX,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAE3C,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAQ,IAAS,CAC3C,IAAM,EAAU,IAAI,CAAC,CAAA,CAAS,CAAC,EAAM,CAErC,IAAK,IAAI,EAAO,EAAG,EAAO,EAAO,IAAQ,CACvC,IAAM,EAAW,IAAS,EAAQ,EAAI,EAAI,EAAO,EAEjD,IAAK,IAAI,EAAQ,EAAG,GAAS,EAAQ,YAAY,CAAE,IAAS,CACtD,IAAI,CAAC,QAAQ,EAAE,IAAI,IACrB,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAG3C,IAAM,EAAgB,IAAI,CAAC,gBAAgB,CAAC,CAC1C,QAAA,EACA,UAAW,CACb,GAEA,IAAI,CAAC,QAAQ,CAAC,WAAW,CACvB,EAAQ,cAAc,CAAC,CACrB,KAAM,EACN,MAAO,CAAa,CAAC,EAAE,AACzB,GACA,EAAQ,YAAY,CAAC,CAAE,KAAA,EAAM,MAAA,CAAM,GACnC,EAAQ,cAAc,CAAC,CACrB,KAAM,EACN,MAAO,CAAa,CAAC,EAAE,AACzB,IAGF,MACA,GACF,CACF,CACF,CACF,CAEA,iBAAiB,CAAA,QACf,CAAO,CAAA,UACP,CAAS,CAIV,CAAoB,CACnB,IAAM,EAAiB,EAAQ,YAAY,CAAG,EAAQ,gBAAgB,CAEtE,MAAO,CACL,EAAY,EACR,CAAC,EAAiB,EAClB,EAAY,EAChB,EAAQ,gBAAgB,CAAG,EAC5B,AACH,CAEA,cAAuB,CACrB,GAAM,CAAA,MAAE,CAAK,CAAA,EAAE,CAAC,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,MAAM,CACxC,OAAO,EAAS,CAAA,EAAI,CAAA,EAAK,CAC3B,CAEA,WAAY,CACV,IAAM,EACJ,IAAI,CAAC,CAAA,CAAS,CAAC,EAAE,CAAC,gBAAgB,CAAG,IAAI,CAAC,CAAA,CAAS,CAAC,EAAE,CAAC,YAAY,CAC/D,EACJ,EAAiB,EAAI,CAAC,EAAG,IAAU,GAAS,EAAiB,KAE/D,IAAI,CAAC,CAAA,CAAS,CAAC,OAAO,CAAC,AAAA,GACrB,EAAQ,SAAS,CAAC,IAAI,CAAC,KAAK,CAAE,CAAE,WAAY,CAAA,EAAM,kBAAA,CAAkB,GAExE,CAEA,OAAO,gBAAkB,CACvB,EAAG,EACL,CAAE,AACJ,CClLA,MAAM,EAAe,AAAA,EAAM,SAAS,CAAC,CACnC,SAAU,CACR,aAAc,CAAA,EACd,MAAO,UACP,gBAAiB,IACjB,gBAAiB,IACjB,sBAAuB,CAAA,EACvB,aAAc,GACd,aAAc,GACd,WAAY,CACd,EACA,QAAS,CAAC,eAAgB,eAAe,AAC3C,EASe,OAAA,UAAyB,EACtC,OAAO,KAAO,aAAc,AAE5B,CAAA,KAAO,aAAc,AACrB,CAAA,GAAK,aAAc,AACnB,CAAA,KAAO,gDAAiD,AACxD,CAAA,SAAW,OAAQ,AACnB,CAAA,SAA6C,CAC3C,CACE,IAAK,IACL,MAAO,IACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,GACL,KAAM,CACR,EACA,aAAc,CAAA,CAChB,EACA,CACE,IAAK,WACL,MAAO,YACP,aAAc,IACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,IACL,KAAM,CACR,EACA,aAAc,CAAA,CAChB,EACA,CACE,IAAK,QACL,MAAO,QACP,aAAc,IACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,IACL,KAAM,CACR,EACA,aAAc,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,CAAA,EAAG,EAAM,IAAC,CAAC,CACxC,aAAc,CAAA,CAChB,EACA,AAAA,EAAO,cAAc,CACrB,EACD,AAAC,AAEF,CAAA,IAAY,AACZ,CAAA,MAAiC,AACjC,CAAA,KAAa,AACb,CAAA,QAAmB,AAEnB,CAAA,gBAAiB,CACf,KAAK,CAAC,iBAEF,IAAI,CAAC,MAAM,EACb,IAAI,CAAC,MAAM,CAAC,KAAK,GAEnB,IAAI,CAAC,IAAI,CAAG,IACd,CAEA,WAAY,CACV,KAAK,CAAC,YACN,GAAM,CAAA,aAAE,CAAY,CAAA,WAAE,CAAU,CAAE,CAAG,IAAI,CAAC,MAAM,AAE5C,AAAC,CAAA,IAAI,CAAC,IAAI,EACZ,CAAA,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,OAAO,EAD1B,EAII,AAAC,IAAI,CAAC,MAAM,EACd,CAAA,IAAI,CAAC,MAAM,CAAG,IAAI,GADpB,EAII,AAAC,IAAI,CAAC,SAAS,EACjB,CAAA,IAAI,CAAC,SAAS,CAAG,IAAI,CAAC,YAAY,EADpC,EAIA,IAAI,CAAC,KAAK,CAAG,IAAI,EAAM,CACrB,GAAG,IAAI,CAAC,MAAM,CACd,aAAA,EACA,WAAA,CACF,GAEI,EACF,IAAI,CAAC,QAAQ,CAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CACrC,UAAW,IAAI,CAAC,SAAS,CACzB,WAAA,CACF,GAEA,IAAI,CAAC,QAAQ,CAAG,IAEpB,CAEA,SAAiB,CACf,GAAM,CAAA,MAAE,CAAK,CAAA,SAAE,CAAQ,CAAA,SAAE,CAAQ,CAAE,CAAG,IAAI,CAAC,MAAM,CAC3C,EAAO,IAAI,CAAC,OAAO,GAEzB,MAAO,CACL,aAAe,AAAA,EAAM,EAAS,EAC9B,OAAQ,KAAK,GAAG,IAAI,GAAQ,EAC5B,YAAa,EACb,cAAe,CAAA,CAAA,AAAW,EAAV,KAAK,EAAE,AAAG,EAAI,CAChC,CACF,CAEA,SAAS,CAAa,CAAe,CACnC,GAAM,CAAA,cAAE,CAAa,CAAA,aAAE,CAAY,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,IAAI,CAEzD,GAAI,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAClB,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAGzB,IAAM,EAAI,EAAQ,EACZ,EAAI,EAAS,KAAK,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAG,GAEtC,EAAQ,CACZ,IAAI,CAAC,MAAM,CAAC,EAAE,CAAG,EAAI,KAAK,GAAG,CAAC,EAAI,GAClC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAG,EAAI,KAAK,GAAG,CAAC,EAAI,GACnC,CAED,OADA,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,EAAO,GAChB,CACT,CAEA,CAAC,gBAAmE,CAClE,IAAM,EAAQ,IAAI,CAAC,SAAS,CAE5B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAQ,EAAG,IAC7B,KAAM,CAAE,MAAO,IAAI,CAAC,QAAQ,CAAC,GAAI,MAAO,CAAE,CAE9C,CAEA,CAAC,iBAAmC,CAClC,IAEI,EAFE,EAAS,IAAI,CAAC,cAAc,GAKlC,IAAK,GAAM,CAAA,MAAE,CAAK,CAAA,MAAE,CAAK,CAAE,GAF3B,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAEZ,GAAQ,CACrC,GAAI,CAAC,EAAW,CACd,EAAY,EACZ,QACF,CAEA,GAAI,IAAI,CAAC,QAAQ,CAAE,CACjB,IAAM,EAAY,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAChC,CAAA,GACF,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAE3B,CAEA,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAW,GACrC,EAAY,EAEZ,KACF,CACF,CAEA,cAAuB,CACrB,GAAI,IAAI,CAAC,SAAS,CAChB,OAAO,IAAI,CAAC,SAAS,CAGvB,GAAM,CAAA,SAAE,CAAQ,CAAA,MAAE,CAAK,CAAA,EAAE,CAAC,CAAE,CAAG,IAAI,CAAC,MAAM,CACpC,EAAW,AdlMd,SAAS,EAAI,CAAI,CAAE,CAAI,SAC5B,AAAK,EAEE,EAAI,EAAM,EAAO,GAFN,CAGpB,Ec8LyB,EAAU,GAE3B,EAAQ,EAAW,EAIvB,MAHI,CAAE,CAAA,EAAQ,CAAA,GAAM,EAAI,GACtB,CAAA,GAAS,CAAA,EAEJ,KAAK,KAAK,CAAC,EACpB,CAEA,WAAY,CAEV,IAAK,GAAM,CAAA,MAAE,CAAK,CAAA,MAAE,CAAK,CAAE,GADZ,IAAI,CAAC,cAAc,GAEhC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAE,MAAA,EAAO,OAAQ,CAAM,EAE9C,CAEA,OAAO,gBAAkB,CAAC,CAAE,AAC9B,CC9KA,MAAM,EAAe,AAAA,EAAM,SAAS,CAAC,CACnC,SAAU,CACR,aAAc,CAAA,EACd,MAAO,UACP,gBAAiB,GACjB,gBAAiB,GACjB,sBAAuB,CAAA,EACvB,aAAc,GACd,aAAc,GACd,WAAY,EACZ,aAAc,CAAA,EACd,WAAY,GACZ,cAAe,CAAA,CACjB,EACA,eAAgB,CACd,CACE,IAAK,gBACL,MAAO,kBACP,aAAc,CAAA,EACd,KAAM,UACR,EACD,AACH,GAIM,EAAQ,CAAC,EAAM,EACf,EAAc,AAAI,MAAM,GAC3B,IAAI,CAAC,MACL,GAAG,CAAC,CAAC,EAAG,IAAM,KAAK,EAAE,CAAG,EAAI,EAAQ,GCnDjC,EAAkD,CACtD,OAAQ,CACN,EAAG,CAAC,EAAY,CAAA,SAAE,CAAQ,CAAA,OAAE,CAAM,CAAA,EAAE,CAAC,CAAE,GAE9B,KAAK,KAAK,CAAG,AAAA,CAAA,EAAS,CAAA,EADF,KAAK,KAAK,CAAC,EAAI,GACuB,GAEnE,KAAM,QACR,EACA,SAAU,CACR,EAAG,CAAC,EAAY,CAAA,EAAE,CAAC,CAAA,SAAE,CAAQ,CAAA,cAAE,CAAa,CAAE,IAC5C,IAAM,EAAqB,KAAK,KAAK,CAAC,EAAI,UAE1C,AAAI,EAAa,EACR,EAAqB,EAAa,EAGpC,CACT,EACA,KAAM,mBACR,CACF,EAEM,EAAe,AAAA,EAAM,SAAS,CAAC,CACnC,SAAU,CACR,aAAc,CAAA,EACd,MAAO,UACP,gBAAiB,IACjB,gBAAiB,IACjB,sBAAuB,CAAA,EACvB,aAAc,GACd,aAAc,GACd,WAAY,CACd,EACA,eAAgB,CACd,CACE,IAAK,gBACL,MAAO,kBACP,aAAc,CAAA,EACd,KAAM,UACR,EACD,AACH,EAEe,OAAA,UAAoB,EACjC,OAAO,KAAO,OAAQ,AAEtB,CAAA,KAAO,OAAQ,AACf,CAAA,GAAK,OAAQ,AACb,CAAA,SAAwC,CACtC,AAAA,EAAO,WAAW,CAClB,CACE,IAAK,SACL,MAAO,SACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,GACL,KAAM,CACR,EACA,aAAc,CAAA,CAChB,EACA,CACE,IAAK,WACL,MAAO,mBACP,YACE,qFACF,aAAc,GACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,EACL,KAAM,GACR,EACA,aAAc,CAAC,CAAA,SAAE,CAAQ,CAAA,EAAE,CAAC,CAAE,GAAK,KAAK,KAAK,CAAC,EAAI,GAClD,aAAc,CAAA,CAChB,EACA,CACE,IAAK,cACL,MAAO,eACP,KAAM,SACN,aAAc,WACd,QAAS,OAAO,OAAO,CAAC,GAAa,GAAG,CAAC,CAAC,CAAC,EAAK,CAAA,KAAE,CAAI,CAAE,CAAC,GAAM,CAAA,CAC7D,MAAO,EACP,MAAO,CACT,CAAA,GACA,aAAc,CAAA,CAChB,EACA,CACE,IAAK,gBACL,MAAO,iBACP,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,CAAC,CAAA,EAAE,CAAC,CAAA,OAAE,CAAM,CAAE,GAAK,KAAK,KAAK,CAAC,EAAI,EAAI,GAC3C,KAAM,CACR,EACA,aAAc,EACd,aAAc,CAAA,EACd,KAAM,CAAC,CAAA,YAAE,CAAW,CAAE,GAAK,AAAgB,WAAhB,CAC7B,EACA,AAAA,EAAO,cAAc,CACrB,AAAA,EAAO,gBAAgB,CACvB,AAAA,EAAO,kBAAkB,CACzB,EACD,AAAC,AAEF,CAAA,cAAsC,CACpC,EAAG,GACH,OAAQ,GACR,cAAe,CAAA,EACf,gBAAiB,IACjB,gBAAiB,IACjB,SAAU,IACV,SAAU,IACV,WAAY,IACZ,iBAAkB,YAClB,gBAAiB,IACjB,qBAAsB,IACtB,YAAa,WACb,cAAe,CACjB,CAAE,AAEF,EAAA,CAAO,AAAS,AAChB,CAAA,KAAa,AAEb,CAAA,WAAY,CACV,KAAK,CAAC,YACN,IAAM,EAAe,CACnB,KAAM,IAAI,CAAC,IAAI,CACf,EAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAChB,OAAQ,IAAI,CAAC,MAAM,CAAC,MAAM,CAC1B,SAAU,IAAI,CAAC,MAAM,CAAC,QAAQ,CAC9B,WAAY,IAAI,CAAC,MAAM,CAAC,UAAU,CAClC,iBAAkB,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAC9C,gBAAiB,IAAI,CAAC,MAAM,CAAC,eAAe,CAC5C,qBAAsB,IAAI,CAAC,MAAM,CAAC,oBAAoB,AACxD,CAEI,CAAA,IAAI,CAAC,CAAA,CAAO,CACd,IAAI,CAAC,CAAA,CAAO,CAAC,SAAS,CAAC,GAEvB,IAAI,CAAC,CAAA,CAAO,CAAG,IAAI,EAAO,GAGxB,AAAC,IAAI,CAAC,SAAS,EACjB,CAAA,IAAI,CAAC,SAAS,CAAG,IAAI,CAAC,YAAY,EADpC,EAIA,GAAM,CAAA,aAAE,CAAY,CAAA,WAAE,CAAU,CAAA,OAAE,CAAM,CAAA,cAAE,CAAa,CAAE,CAAG,IAAI,CAAC,MAAM,CACjE,EAAiB,EACnB,EACE,EACA,KAAK,GAAG,CAAC,EAAY,GACvB,CAEJ,CAAA,IAAI,CAAC,KAAK,CAAG,IAAI,EAAM,CACrB,GAAG,IAAI,CAAC,MAAM,CACd,aAAA,EACA,WAAY,CACd,EACF,CAEA,qBAAqB,CAAkB,CAAU,CAC/C,IAAM,EAAS,CAAW,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CACnD,GAAI,CAAC,EACH,MAAM,AAAI,MAAM,CAAC,sBAAsB,EAAE,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,EAGtE,OAAO,EAAO,CAAC,CAAC,EAAY,IAAI,CAAC,MAAM,CACzC,CAEA,sBAAsB,CAAkB,CAAU,CAChD,IAAM,EAAoB,IAAI,CAAC,oBAAoB,CAAC,GACpD,MAAO,AAAC,CAAA,IAAI,CAAC,MAAM,CAAC,CAAC,CAAG,EAAoB,CAAA,EAAK,EAAI,CACvD,CAEA,CAAC,UAAU,EAAa,CAAC,CAAmB,CAC1C,GAAM,CAAA,EAAE,CAAC,CAAE,CAAG,IAAI,CAAC,MAAM,CACnB,EAAe,IAAI,CAAC,oBAAoB,CAAC,GACzC,EAAY,EAAI,EAAe,EAEjC,EAAY,IAAI,CAAC,CAAA,CAAO,CAAC,QAAQ,CAAC,GAClC,EAAiB,EACrB,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAE3C,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,EAAe,EAAG,IAAK,CAC7C,IAAM,EAAa,EAAI,EACjB,EAAQ,IAAI,CAAC,CAAA,CAAO,CAAC,QAAQ,CAAC,GAEpC,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAW,GACrC,MAEI,IAAM,EAAY,IACpB,EAAiB,EAAI,EACrB,EAAY,IAAI,CAAC,CAAA,CAAO,CAAC,QAAQ,CAAC,GAElC,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAO,GAEjC,MAEJ,CACF,CAEA,CAAC,iBAAkB,CACjB,IAAK,IAAI,EAAQ,EAAG,EAAQ,IAAI,CAAC,MAAM,CAAC,MAAM,CAAE,IAC9C,MAAO,IAAI,CAAC,SAAS,CAAC,EAE1B,CAEA,cAAuB,CACrB,GAAI,IAAI,CAAC,SAAS,CAChB,OAAO,IAAI,CAAC,SAAS,CAGvB,GAAM,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,MAAM,CAC9B,OAAO,AAAI,MAAM,GACd,IAAI,CAAC,GACL,MAAM,CACL,CAAC,EAAgB,EAAG,IAClB,EAAiB,IAAI,CAAC,qBAAqB,CAAC,GAC9C,EAEN,CAEA,WAAY,CACV,IAAI,CAAC,CAAA,CAAO,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CACnC,CAEA,OAAO,gBAAkB,CACvB,EAAG,GACH,OAAQ,CACV,CAAE,AACJ,CC5Ne,MAAA,UAAkB,EAC/B,OAAO,KAAO,KAAM,AAEpB,CAAA,KAAO,KAAM,AACb,CAAA,GAAK,KAAM,AACX,CAAA,SAAsC,CACpC,CACE,IAAK,YACL,MAAO,OACP,KAAM,QACN,SAAU,IACL,AAAA,EACD,IACK,AAAA,EAAU,UAAU,CACvB,AAAA,EAAM,SAAS,CAAC,CACd,SAAU,CACR,aAAc,CAAA,EACd,gBAAiB,EACjB,gBAAiB,IACjB,MAAO,UACP,WAAY,GACZ,sBAAuB,CAAA,EACvB,aAAc,GACd,aAAc,EAChB,EACA,QAAS,CAAC,aAAa,AACzB,GACD,CACD,QACA,CACE,CACE,IAAK,SACL,MAAO,SACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,GACL,KAAM,CACR,EACA,aAAc,CAAA,CAChB,EACA,CACE,IAAK,cACL,MAAO,eACP,aAAc,MACd,KAAM,QACN,aAAc,CAAC,CAAA,YAAE,CAAW,CAAE,GAC5B,AAAA,EAAwB,GAC1B,KAAM,CACJ,IAAK,IACL,IAAK,EACL,KAAM,GACR,EACA,KAAM,CAAC,CAAA,OAAE,CAAM,CAAE,GAAK,AAAW,IAAX,EACtB,aAAc,CAAA,CAChB,EACA,CACE,IAAK,aACL,MAAO,cACP,aAAc,EACd,KAAM,QACN,aAAc,CAAC,CAAA,WAAE,CAAU,CAAE,GAC3B,AAAA,EAAwB,GAC1B,KAAM,CACJ,IAAK,GACL,IAAK,EACL,KAAM,GACR,EACA,aAAc,CAAA,EACd,iBAAkB,CAAA,CACpB,EACD,EAEJ,AACH,EACA,CACE,IAAK,WACL,MAAO,WACP,KAAM,QACN,SAAU,CACR,CACE,IAAK,eACL,MAAO,gBACP,aAAc,GACd,KAAM,QACN,aAAc,CAAC,CAAA,aAAE,CAAY,CAAE,GAC7B,AAAA,EAAwB,GAC1B,KAAM,CACJ,IAAK,EACL,IAAK,EACL,KAAM,CAAC,CAAA,UAAE,CAAS,CAAE,GAAK,EAAI,CAC/B,EACA,aAAc,CAAA,CAChB,EACA,CACE,IAAK,iBACL,MAAO,kBACP,aAAc,EACd,KAAM,QACN,aAAc,CAAC,CAAA,eAAE,CAAc,CAAE,GAC/B,AAAA,EAAwB,GAC1B,KAAM,CACJ,IAAK,EACL,IAAK,EACL,KAAM,GACR,EACA,aAAc,CAAA,EACd,iBAAkB,CAAA,CACpB,EACA,CACE,IAAK,gBACL,MAAO,iBACP,aAAc,EACd,KAAM,QACN,aAAc,CAAC,CAAA,cAAE,CAAa,CAAE,GAC9B,AAAA,EAAwB,GAC1B,KAAM,CACJ,IAAK,EACL,IAAK,EACL,KAAM,CAAC,CAAA,UAAE,CAAS,CAAA,aAAE,CAAY,CAAE,GAChC,AAAC,CAAA,EAAK,CAAA,EAAa,CAAA,EAAI,CAAA,CAAW,CAAC,EAAI,OAAO,CAAC,EACnD,EACA,aAAc,CAAA,EACd,iBAAkB,CAAA,CACpB,EACA,CACE,IAAK,eACL,MAAO,gBACP,YACE,oHACF,aAAc,CAAA,EACd,KAAM,WACN,aAAc,CAAA,EACd,iBAAkB,CAAA,EAClB,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,EAAQ,CAC/B,EACA,AAAA,EAAM,SAAS,CAAY,CACzB,SAAU,CACR,aAAc,CAAA,EACd,gBAAiB,GACjB,gBAAiB,EACjB,MAAO,UACP,WAAY,GACZ,sBAAuB,CAAA,EACvB,aAAc,GACd,aAAc,EAChB,EACA,WAAY,CAAC,CAAA,IAAE,CAAG,CAAA,KAAE,CAAI,CAAE,IACT,AAAa,CAAG,CAAC,EAAE,CAAC,WAAW,GAAK,EAAI,KAAK,CAAC,GAC7D,IAAM,EAAuC,CAC3C,IAAK,WAAa,CAAG,CAAC,EAAE,CAAC,WAAW,GAAK,EAAI,KAAK,CAAC,GACnD,KAAM,EACF,CAAC,CAAA,qBAAE,CAAoB,CAAE,GACvB,AAAQ,UAAR,EACI,CAAC,EACD,EACN,IACN,EAQA,MANI,AAAQ,oBAAR,GACF,CAAA,EAAQ,IAAI,CAAG,CACb,MAAO,CAAC,CAAA,wBAAE,CAAuB,CAAE,GAAK,EACxC,KAAM,OACR,CAAA,EAEK,CACT,EACA,WAAY,iBACZ,cAAe,CACjB,GACD,AACH,EACD,AAAC,AAEF,CAAA,mBAAwD,CACtD,OAAO,AAAA,EACL,KAAK,CAAC,oBACN,aACA,CACE,CACE,IAAK,qBACL,MAAO,uBACP,KAAM,QACN,aAAc,UACd,KAAM,CAAC,CAAA,UAAE,CAAS,CAAE,GAAK,CAC3B,EACA,CACE,IAAK,sBACL,MAAO,wBACP,KAAM,QACN,aAAc,IACd,KAAM,CAAE,IAAK,GAAK,IAAK,EAAG,KAAM,GAAK,EACrC,KAAM,CAAC,CAAA,UAAE,CAAS,CAAE,GAAK,CAC3B,EACD,CAEL,CAEA,CAAA,CAAO,CAAW,IAAK,AACvB,EAAA,CAAK,CAAc,IAAK,AACxB,EAAA,CAAK,AAAQ,AACb,EAAA,CAAM,AAAQ,AACd,EAAA,CAAc,AAAQ,AAEtB,CAAA,cAAgB,CACd,UAAW,GACX,MAAO,GACP,OAAQ,EACR,YAAa,IACb,aAAc,IACd,eAAgB,GAChB,cAAe,IACf,mBAAoB,EACpB,aAAc,GACd,aAAc,IACd,SAAU,GACV,WAAY,GACZ,gBAAiB,IACjB,gBAAiB,EACjB,sBAAuB,CAAA,EACvB,aAAc,GACd,aAAc,IACd,WAAY,UACZ,mBAAoB,UACpB,oBAAqB,KACvB,CAAE,AAEF,CAAA,SAAiB,CACf,GAAM,CAAA,UAAE,CAAS,CAAA,aAAE,CAAY,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,MAAM,CAEvD,MAAO,CACL,cAAe,KAAK,KAAK,CAAC,EAAY,EACxC,CACF,CAEA,gBAAiB,CACf,KAAK,CAAC,iBAEN,IAAI,CAAC,CAAA,CAAK,CAAG,IACf,CAEA,WAAY,CACV,KAAK,CAAC,YAEN,GAAM,CAAA,OACJ,EAAS,CAAA,CAAA,OACT,CAAM,CACN,eAAgB,EAAuB,CAAC,CAAA,aACxC,CAAY,CAAA,SACZ,CAAQ,CAAA,MACR,CAAK,CACL,WAAY,EAAmB,CAAC,CAAA,mBAChC,CAAkB,CACnB,CAAG,IAAI,CAAC,MAAM,CAET,EAAS,KAAK,GAAG,IADR,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,AAAA,GAAK,EAAI,IACD,CAUjC,AAAC,CAAA,IAAI,CAAC,CAAA,CAAK,EACb,CAAA,IAAI,CAAC,CAAA,CAAK,CAAG,IAAI,CAAC,OAAO,EAD3B,EAIA,IAAM,EAA8B,CAClC,GAAG,IAAI,CAAC,MAAM,CACd,OAdA,GAAgB,EAAmB,EAC/B,EAAU,EAAoB,EAC9B,EAaJ,KAAM,IAAI,CAAC,IAAI,AACjB,CAEI,CAAA,IAAI,CAAC,CAAA,CAAK,CACZ,IAAI,CAAC,CAAA,CAAK,CAAC,SAAS,CAAC,GAErB,IAAI,CAAC,CAAA,CAAK,CAAG,IAAI,EAAU,GAG7B,IAAI,CAAC,CAAA,CAAM,CAAG,IAAI,EAAM,CACtB,GAAG,IAAI,CAAC,MAAM,CACd,WAAY,CACd,GAGA,IAAI,CAAC,CAAA,CAAc,CAAG,IAAI,EAAM,CAC9B,GAAG,AhB7QF,SACL,CAAM,CACN,CAA8C,EAE9C,IAAM,EAAY,CAAC,EAInB,OAHA,OAAO,OAAO,CAAC,GAAK,OAAO,CACzB,CAAC,CAAC,EAAK,EAAM,GAAM,CAAS,CAAC,EAAO,EAAK,GAAO,CAAG,GAE9C,CACT,EgBoQiB,IAAI,CAAC,MAAM,CAAE,AAAA,IACtB,IAAM,EAAQ,EAAI,KAAK,CAAC,qBACxB,OAAO,EAAQ,CAAK,CAAC,EAAE,CAAC,WAAW,GAAK,CAAK,CAAC,EAAE,CAAG,CACrD,EAAE,CACF,WAAY,CACd,GACA,IAAM,EAA6B,CACjC,KAAM,IAAI,CAAC,IAAI,CACf,EAAG,EACH,SAAU,GAAK,EAAQ,EAAK,CAAA,EAAW,EAAW,EAAQ,CAAA,EAC1D,OArCA,EAAuB,EACnB,EAAU,EAAwB,EAClC,CAoCN,CAEI,CAAA,IAAI,CAAC,CAAA,CAAO,CACd,IAAI,CAAC,CAAA,CAAO,CAAC,SAAS,CAAC,GAEvB,IAAI,CAAC,CAAA,CAAO,CAAG,IAAI,EAAO,EAE9B,CAEA,CAAC,SAAS,CAAa,CAAmB,CACxC,MAAO,IAAI,CAAC,CAAA,CAAK,CAAC,eAAe,CAAC,IAAI,CAAC,QAAQ,CAAE,CAAE,KAAA,CAAK,EAC1D,CAEA,CAAC,gBAAkC,CACjC,GAAM,CAAA,UAAE,CAAS,CAAA,YAAE,CAAW,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,MAAM,CAEtD,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAQ,IAAS,CAC3C,IAAM,EAAQ,IAAI,CAAC,CAAA,CAAM,CAAC,QAAQ,CAAC,GACnC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAEvB,IAAM,EAAY,IAAI,CAAC,CAAA,CAAa,CAAC,EACrC,OAAO,IAAI,CAAC,QAAQ,CAAC,EACvB,CACF,CAEA,CAAC,cAAgC,CAI/B,IAII,EAJE,CAAA,cAAE,CAAa,CAAE,CAAG,IAAI,CAAC,CAAA,CAAK,CAC9B,CAAA,MAAE,CAAK,CAAA,cAAE,CAAa,CAAA,UAAE,CAAS,CAAA,aAAE,CAAY,CAAE,CAAG,IAAI,CAAC,MAAM,CAE/D,EAAa,GAAgB,EAAQ,EAEvC,EAAc,EAGd,EAAmB,AAFT,KAAK,KAAK,CAAC,EAAiB,CAAA,EAAY,CAAA,GAEvB,EAAgB,EAE/C,IAAK,IAAI,EAAO,EAAG,EAAO,EAAO,IAAQ,CACvC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAA,CAAc,CAAC,QAAQ,CAAC,EAAO,EAAI,EAAI,IACnE,IAAM,EAAgB,IAAI,CAAC,CAAA,CAAO,CAAC,QAAQ,CACzC,EAAc,AAAA,CAAA,EAAO,CAAA,EAAK,EAAQ,GAEhC,EAAY,CAAA,EACV,EAAY,EAAO,EAAI,EAAI,GACjC,EAAY,IAAI,CAAC,CAAA,CAAK,CAAC,QAAQ,CAAC,EAAM,GAEtC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAe,IASjC,GARA,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAW,GACrC,MAEA,EAAc,AAAC,CAAA,EAAY,EAAO,EAAQ,CAAA,EAAa,EAAI,CAAA,CAAA,EAAM,EACjE,EAAY,IAAI,CAAC,CAAA,CAAK,CAAC,QAAQ,CAAC,EAAa,GAC7C,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAe,GACzC,MAEI,EAAI,EAAgB,EAAG,CACzB,EAAY,CAAC,EACb,GAAoB,EACpB,IAAM,EAAY,IAAI,CAAC,CAAA,CAAK,CAAC,QAAQ,CAAC,EAAa,GACnD,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAW,GACrC,EAAY,CACd,CAEJ,CACF,CAEA,CAAC,iBAAkB,CACjB,MAAO,IAAI,CAAC,YAAY,GACxB,MAAO,IAAI,CAAC,cAAc,EAC5B,CAEA,WAAY,CACV,GAAM,CAAA,aAAE,CAAY,CAAA,mBAAE,CAAkB,CAAA,oBAAE,CAAmB,CAAE,CAC7D,IAAI,CAAC,MAAM,CAGb,GADA,IAAI,CAAC,CAAA,CAAK,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,EAC3B,EAAc,CAChB,IAAM,EAAc,EAAE,CACtB,IAAK,IAAM,KAAc,IAAI,CAAC,CAAA,CAAO,CAAC,aAAa,GACjD,EAAY,IAAI,CAAC,GAEnB,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAa,CAC/B,MAAO,EACP,OAAQ,CACV,EACF,CACF,CAEA,CAAA,CAAa,CAAC,CAAa,EACzB,GAAM,CAAA,OAAE,CAAM,CAAA,YAAE,CAAW,CAAA,UAAE,CAAS,CAAE,CAAG,IAAI,CAAC,MAAM,CACtD,OAAO,KAAK,GAAG,CACb,EACA,EACE,EAAQ,KAAK,GAAG,CAAC,EAAG,KAAK,KAAK,CAAC,EAAa,EAAU,IAE5D,CAEA,cAAe,CACb,GAAM,CAAA,OAAE,CAAM,CAAA,MAAE,CAAK,CAAE,CAAG,IAAI,CAAC,MAAM,CAC/B,CAAA,cAAE,CAAa,CAAE,CAAG,IAAI,CAAC,OAAO,GAIlC,EAFsB,EAAQ,EAAgB,EAGlD,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAQ,IAAS,CAC3C,IAAM,EAAY,IAAI,CAAC,CAAA,CAAa,CAAC,GACrC,GAAa,AAAA,EAAU,YAAY,CAAC,IAAI,CAAC,MAAM,CAAE,CAAE,KAAM,CAAU,EACrE,CAEA,OAAO,CACT,CAEA,OAAO,gBAAkB,CACvB,UAAW,GACX,oBAAqB,EACvB,CAAE,AACJ,CCpae,MAAA,UAAoB,EACjC,OAAO,KAAO,OAAQ,AAEtB,CAAA,KAAO,OAAQ,AACf,CAAA,GAAK,OAAQ,AACb,CAAA,SAAwC,CACtC,CACE,IAAK,QACL,MAAO,QACP,YAAa,yCACb,KAAM,QACN,aAAc,GACd,KAAM,CACJ,IAAK,EACL,IAAK,GACL,KAAM,CACR,EACA,aAAc,CAAA,CAChB,EACA,CACE,IAAK,UACL,MAAO,UACP,KAAM,QACN,aAAc,IACd,KAAM,CACJ,IAAK,EACL,IAAK,IACL,KAAM,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,CACvB,EACA,aAAc,CAAA,CAChB,EACA,AAAA,EAAiB,AAAA,EAAO,cAAc,CAAE,QACxC,CACE,IAAK,iBACL,MAAO,kBACP,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,EACL,KAAM,CAAC,CAAA,MAAE,CAAK,CAAA,aAAE,CAAY,CAAE,GAC5B,EAAI,EAAwB,EAAO,EACvC,EACA,aAAc,EACd,aAAc,CAAC,CAAA,eAAE,CAAc,CAAA,MAAE,CAAK,CAAA,aAAE,CAAY,CAAE,GACpD,KAAK,KAAK,CACR,EAAiB,EAAwB,EAAO,IAEpD,aAAc,CAAA,CAChB,EACA,CACE,IAAK,MACL,MAAO,MACP,KAAM,WACN,aAAc,CAAA,EACd,KAAM,CAAC,CAAA,eAAE,CAAc,CAAE,GAAK,EAC9B,aAAc,CAAA,CAChB,EACA,CACE,IAAK,eACL,MAAO,gBACP,KAAM,WACN,aAAc,CAAA,EACd,aAAc,CAAA,CAChB,EACA,CACE,IAAK,eACL,MAAO,gBACP,KAAM,QACN,aAAc,EACd,KAAM,CACJ,IAAK,EACL,IAAK,EACL,KAAM,GACR,EACA,aAAc,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,AAAA,EAAwB,GAC5D,KAAM,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,EAC5B,aAAc,CAAA,CAChB,EACA,CACE,IAAK,oBACL,MAAO,sBACP,KAAM,WACN,aAAc,CAAA,EACd,aAAc,CAAA,EACd,KAAM,CAAC,CAAA,aAAE,CAAY,CAAE,GAAK,CAC9B,EACA,AAAA,EAAM,SAAS,CAAC,CACd,SAAU,CACR,aAAc,CAAA,EACd,gBAAiB,GACjB,gBAAiB,GACjB,sBAAuB,CAAA,EACvB,aAAc,GACd,aAAc,GACd,WAAY,IACZ,WAAY,CACd,EACA,eAAgB,CACd,CACE,IAAK,cACL,MAAO,eACP,aAAc,CAAA,EACd,KAAM,UACR,EACD,CACD,cAAe,EACjB,GACD,AAAC,AAEF,CAAA,cAAgB,CACd,WAAY,SACd,CAAE,AAEF,EAAA,CAAK,AAAQ,AACb,EAAA,CAAM,AAAQ,AAEd,CAAA,SAAiB,CACf,GAAM,CAAA,MACJ,CAAK,CAAA,QACL,CAAO,CAAA,OACP,CAAM,CAAA,SACN,CAAQ,CAAA,eACR,CAAc,CAAA,IACd,CAAG,CACH,aAAc,CAAmB,CAAA,aACjC,CAAY,CACb,CAAG,IAAI,CAAC,MAAM,CAET,EAAO,IAAI,CAAC,OAAO,GACrB,EAAS,AAFH,GAEG,KAAM,GAAG,IAAI,GAAa,EAEjC,EAAY,AAAA,EAAM,EAClB,EAAmB,EAAc,GACjC,EAAiC,CACrC,EAAG,EACH,OAAQ,CAAC,EAAG,EAAE,CACd,KAAM,CAAC,EAAG,EAAE,CACZ,OAAQ,EACR,SAAU,CACZ,EAEI,EAAwB,EAE5B,GAAI,EAAgB,CAClB,IAAM,EAA2B,EAC/B,EACA,GAOI,EAAa,EALnB,CAAA,EAAwB,KAAK,GAAG,CAC9B,EACA,KAAK,KAAK,CAAC,EAAiB,GAF9B,EAOA,GAAI,EAAK,CAMP,IAAM,EACJ,EAAI,EAAS,KAAK,GAAG,CAAC,AAAC,CAAA,KAAK,EAAE,CAAG,CAAA,EAAc,GAC3C,EAAiB,AAAC,CAAA,EAAI,EAAS,CAAA,EAAU,CAC/C,CAAA,EAAiB,CAAC,CAAG,EACnB,EAAc,EAAU,GACxB,GAEF,GAAU,CACZ,MAEE,EAAiB,CAAC,CAAG,EACnB,EACA,GAIJ,OAAO,MAAM,CAAC,EAAkB,CAC9B,WAAA,EACA,SAAU,AAAA,EAAM,CAClB,EACF,CAEA,OAAO,MAAM,CAAC,EAAkB,CAC9B,KAAM,CAAC,EAAS,EAAS,EAAG,EAAS,EAAS,EAAE,CAChD,OAAQ,EAAS,EAAS,CAC5B,GAGA,IAAM,EAAe,IAAI,EAAO,CAC9B,EAAG,EACH,KAAM,EAAK,GAAG,CAAC,AAAA,GAAK,AAhEZ,GAgEY,EAAQ,GAC5B,OAAQ,IAAI,CAAC,MAAM,CACnB,OAAQ,EAAS,EAAS,EAC1B,SAAA,CACF,GAEM,EAAU,AAAI,MAAM,GAAO,IAAI,CAAC,MAAM,GAAG,CAC7C,CAAC,EAAG,IACF,IAAI,EAAO,CACT,GAAG,CAAgB,CACnB,OAAQ,EAAa,QAAQ,CAAC,GAC9B,SAAU,EAAW,EAAI,CAC3B,IAGE,EAAc,CAClB,QAAA,EACA,iBAAkB,EAAiB,CAAC,CACpC,UAAA,EACA,SAAU,EAAiB,GAC3B,gBAAiB,EACjB,gBAAiB,KAAK,KAAK,CACzB,EAAiB,CAAC,CAAI,CAAA,EAAQ,EAAI,CAAA,GAEpC,eAAgB,EAAiB,CAAC,AACpC,EAEA,GAAI,GAAgB,EAAqB,CACvC,IAAM,EAAc,EAAK,QAAQ,CAAG,EAAI,EAAK,eAAe,CACtD,EAAuB,CAAO,CAAC,EAAE,CAAC,QAAQ,CAC9C,EAAc,EAAK,eAAe,EAQ9B,EAAqB,EANH,KAAK,KAAK,CAChC,KAAK,IAAI,CACP,KAAK,GAAG,CAAC,EAAa,MAAM,CAAC,EAAE,CAAG,CAAoB,CAAC,EAAE,GAAK,EAC5D,KAAK,GAAG,CAAC,EAAa,MAAM,CAAC,EAAE,CAAG,CAAoB,CAAC,EAAE,GAAK,GAIpE,CAAA,EAAK,YAAY,CAAG,IAAI,EAAO,CAC7B,EAAG,EACH,OAAQ,EAAa,MAAM,CAC3B,KAAM,CAAC,EAAoB,EAAmB,CAC9C,OAAQ,EACR,SAAU,CAAC,KAAK,IAAI,CAAE,AAAA,CAAA,EAAQ,CAAA,EAAK,GAAK,EAAI,CAC9C,EACF,CAEA,OAAO,EAEP,SAAS,EAAc,CAAkB,EACvC,OAAO,KAAK,GAAG,CAAC,EAAO,EAAc,EAAa,EACpD,CAEA,SAAS,EACP,CAA2B,CAC3B,CAAwB,EAExB,OAAO,KAAK,KAAK,CACf,EAAuB,CAAA,EAAK,EAAI,EAAoB,CAAA,EAAS,EAEjE,CACF,CAEA,gBAAiB,CACf,KAAK,CAAC,iBAEN,IAAI,CAAC,CAAA,CAAK,CAAG,IACf,CAEA,WAAY,CACV,KAAK,CAAC,YAEF,AAAC,IAAI,CAAC,CAAA,CAAK,EACb,CAAA,IAAI,CAAC,CAAA,CAAK,CAAG,IAAI,CAAC,OAAO,EAD3B,EAGA,IAAI,EAAa,IAAI,CAAC,MAAM,CAAC,WAAW,CACpC,IAAI,CAAC,CAAA,CAAK,CAAC,QAAQ,CAAG,IAAI,CAAC,CAAA,CAAK,CAAC,eAAe,CAAG,EACnD,IAAI,CAAC,MAAM,CAAC,UAAU,AAEtB,EAAC,IAAI,CAAC,MAAM,CAAC,YAAY,EAAI,IAAI,CAAC,MAAM,CAAC,WAAW,EACtD,IAGF,IAAI,CAAC,CAAA,CAAM,CAAG,IAAI,EAAM,CACtB,GAAG,IAAI,CAAC,MAAM,CACd,WAAA,CACF,EACF,CAEA,CAAA,CAAc,CAAC,CAAmB,CAAE,CAAe,EACjD,GAAM,CAAA,YAAE,CAAW,CAAE,CAAG,IAAI,CAAC,MAAM,CAC7B,CAAA,gBAAE,CAAe,CAAE,CAAG,IAAI,CAAC,CAAA,CAAK,CAEtC,OAAO,IAAI,CAAC,CAAA,CAAM,CAAC,QAAQ,CACzB,EAAc,EAAU,EAAkB,EAE9C,CAEA,CAAC,CAAA,CAAU,CAAC,CAAmB,CAAE,CAAe,EAC9C,GAAM,CAAA,MAAE,CAAK,CAAE,CAAG,IAAI,CAAC,MAAM,CACvB,CAAA,QACJ,CAAO,CAAA,SACP,CAAQ,CAAA,gBACR,CAAe,CAAA,eACf,CAAc,CAAA,gBACd,CAAe,CAChB,CAAG,IAAI,CAAC,CAAA,CAAK,CAER,EAAQ,IAAI,CAAC,CAAA,CAAc,CAAC,EAAa,GACzC,EAAS,CAAO,CAAC,EAAY,CAEnC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAEvB,IAAM,EACJ,IAAI,CAAC,CAAA,CAAK,CAAC,OAAO,CAAC,AAAgB,IAAhB,EAAoB,EAAQ,EAAI,EAAc,EAAE,CAErE,GAAI,AAAY,IAAZ,EAAe,CAEjB,IAAM,EAA4B,EAAW,QAAQ,CACnD,AAAkB,EAAlB,GAEF,IAAK,IAAI,EAAI,EAAiB,EAAiB,EAAI,EAAgB,IACjE,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAO,QAAQ,CAAC,GAAI,GAC9C,MAEF,IAAK,IAAI,EAAI,EAAG,GAAK,EAAiB,IACpC,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAO,QAAQ,CAAC,GAAI,GAC9C,KAEJ,KAAO,CAIL,IAAM,EACJ,AAFoB,IAAY,EAAW,GAE1B,IAAI,CAAC,CAAA,CAAK,CAAC,YAAY,CACpC,IAAI,CAAC,CAAA,CAAK,CAAC,YAAY,CAAC,QAAQ,CAAC,GACjC,EAAW,QAAQ,CACjB,EAAmB,CAAA,EAAU,EAAI,CAAA,EAC9B,CAAA,EAAQ,GAAK,IAAY,EAAW,EACjC,EAAkB,EAClB,CAAA,GAER,EAAc,CAAO,CAAE,AAAA,CAAA,EAAc,CAAA,EAAW,EAAM,CACtD,EACJ,EACA,AAAC,CAAA,EAAU,EAAI,CAAA,EAAmB,IACjC,EAEH,IAAK,IAAI,EAAI,EAAG,GAAK,EAAiB,IACpC,IAAI,CAAC,QAAQ,CAAC,WAAW,CACvB,EAAY,QAAQ,CAAC,EAAmB,GACxC,GAEF,MAGF,IAAM,EAAa,AAAC,CAAA,EAAU,CAAA,EAAmB,EAAkB,EACnE,IAAK,IAAI,EAAI,EAAY,EAAI,EAAa,EAAiB,IACzD,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAO,QAAQ,CAAC,GAAI,GAC9C,KAEJ,CACF,CAEA,CAAC,iBAAmC,CAClC,IAAK,GAAM,CAAA,KAAE,CAAI,CAAA,QAAE,CAAO,CAAE,GAAI,IAAI,CAAC,CAAA,CAAgB,GACnD,MAAO,IAAI,CAAC,CAAA,CAAU,CAAC,EAAM,EAEjC,CAEA,CAAC,CAAA,CAAgB,GACf,GAAM,CAAA,YAAE,CAAW,CAAA,MAAE,CAAK,CAAA,aAAE,CAAY,CAAE,CAAG,IAAI,CAAC,MAAM,CAClD,CAAA,SAAE,CAAQ,CAAA,gBAAE,CAAe,CAAE,CAAG,IAAI,CAAC,CAAA,CAAK,CAE1C,EAAc,EAAY,CAAA,EAAe,EAAI,CAAA,EAEnD,GAAI,EACF,IAAK,IAAI,EAAU,EAAiB,EAAU,EAAa,IACzD,IAAK,IAAI,EAAO,EAAG,EAAO,EAAO,IAC/B,KAAM,CAAE,KAAA,EAAM,QAAA,CAAQ,OAI1B,IAAK,IAAI,EAAO,EAAG,EAAO,EAAO,IAC/B,IAAK,IAAI,EAAU,EAAiB,EAAU,EAAa,IACzD,KAAM,CAAE,KAAA,EAAM,QAAA,CAAQ,CAI9B,CAEA,WAAY,CACV,GAAM,CAAA,aAAE,CAAY,CAAA,kBAAE,CAAiB,CAAE,CAAG,IAAI,CAAC,MAAM,CACjD,CAAA,QAAE,CAAO,CAAA,iBAAE,CAAgB,CAAA,aAAE,CAAY,CAAE,CAAG,IAAI,CAAC,CAAA,CAAK,CAE9D,EAAQ,OAAO,CAAC,CAAC,EAAQ,KACvB,EAAO,SAAS,CAAC,IAAI,CAAC,KAAK,CAAE,CAC3B,UAAW,AAAA,GAAK,CAAA,EAAG,EAAc,EAAE,CAAC,EAAE,EAAA,CAAG,CACzC,mBAAoB,EAChB,KACA,IAAI,CAAC,CAAA,CAAuB,EAClC,EACF,GAEI,IACE,EACF,EAAa,SAAS,CAAC,IAAI,CAAC,KAAK,CAAE,CAAE,UAAW,AAAA,GAAK,CAAC,EAAE,EAAE,EAAI,EAAA,CAAG,AAAC,GAElE,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAE,MAAO,IAAI,CAAC,MAAM,CAAE,OAAQ,GAAI,GAG3D,CAEA,CAAA,CAAuB,GACrB,GAAM,CAAA,aAAE,CAAY,CAAE,CAAG,IAAI,CAAC,MAAM,CAC9B,CAAA,SAAE,CAAQ,CAAA,gBAAE,CAAe,CAAA,eAAE,CAAc,CAAA,gBAAE,CAAe,CAAE,CAClE,IAAI,CAAC,CAAA,CAAK,CAEN,EACH,AAAA,CAAA,EAAW,EAAI,GAAmB,CAAmB,EACpD,EACF,EAGF,MAAO,CAAC,CAAC,EAFoB,EAAiB,EAEQ,CAAC,AACzD,CAEA,cAAe,CACb,GAAM,CAAA,gBAAE,CAAe,CAAA,SAAE,CAAQ,CAAA,gBAAE,CAAe,CAAE,CAAG,IAAI,CAAC,OAAO,GAC7D,CAAA,MAAE,CAAK,CAAE,CAAG,IAAI,CAAC,MAAM,CAK7B,MAAO,AAHY,CAAA,EAAI,EAAkB,CAAA,EACL,CAAA,EAAW,EAAkB,CAAA,EAE1D,CACT,CAEA,OAAO,gBAAkB,CAAC,CAAE,AAC9B,CAEA,SAAS,EAAiB,CAAa,EACrC,OAAO,EAAQ,EAAI,KAAK,IAAI,CAAC,EAAQ,GAAK,EAAQ,CACpD,CAEA,SAAS,EAAwB,CAAa,CAAE,CAAqB,EACnE,OAAO,EAAiB,GAAU,CAAA,EAAe,EAAI,CAAA,CACvD,C3BvcA,MAAM,EAAe,CACnB,EACA,EACA,EACA,EWwJa,EXtJb,EeiRa,Ef/Qb,EACA,EACA,EACA,EwBgDa,cAA2B,EACxC,OAAO,KAAO,gBAAiB,AAE/B,CAAA,KAAO,gBAAiB,AACxB,CAAA,GAAK,gBAAiB,AACtB,CAAA,KACE,4GAA6G,AAC/G,CAAA,SAA+C,CAC7C,CACE,IAAK,SACL,MAAO,SACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,GACL,KAAM,CACR,EACA,aAAc,CAAA,CAChB,EACA,CACE,IAAK,UACL,MAAO,UACP,aAAc,GACd,KAAM,QACN,KAAM,CACJ,IAAK,EAEL,IAAK,GACL,KAAM,CACR,EACA,aAAc,CAAA,CAChB,EACA,CACE,IAAK,iBACL,MAAO,WACP,aAAc,EACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,GACL,KAAM,CACR,EACA,aAAc,CAAC,CAAA,eAAE,CAAc,CAAE,GAAK,CAAA,EAAG,EAAe,IAAC,CAAC,CAC1D,aAAc,CAAA,EACd,iBAAkB,CAAA,CACpB,EACA,CACE,IAAK,YACL,MAAO,OACP,KAAM,QACN,SAAU,CACR,CACE,IAAK,OACL,MAAO,YACP,aAAc,CAAA,EACd,KAAM,WACN,aAAc,CAAA,CAChB,EACA,CACE,IAAK,YACL,MAAO,aACP,aAAc,UACd,KAAM,QACN,KAAM,CAAC,CAAA,KAAE,CAAI,CAAE,GAAK,CACtB,EACD,AACH,EACA,CACE,IAAK,YACL,MAAO,OACP,KAAM,QACN,SAAU,CACR,CACE,IAAK,aACL,MAAO,kBACP,KAAM,WACN,aAAc,CAAA,EACd,aAAc,CAAA,CAChB,EACA,CACE,IAAK,gBACL,MAAO,kBACP,aAAc,IACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,IACL,KAAM,CACR,EACA,KAAM,CAAC,CAAA,WAAE,CAAU,CAAE,GAAK,EAC1B,aAAc,CAAA,CAChB,EACA,CACE,IAAK,WACL,MAAO,kBACP,aAAc,IACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,GACL,KAAM,GACR,EACA,KAAM,CAAC,CAAA,WAAE,CAAU,CAAE,GAAK,EAC1B,aAAc,CAAC,CAAA,SAAE,CAAQ,CAAE,GAAK,AAAA,EAAwB,GACxD,aAAc,CAAA,CAChB,EACA,CACE,IAAK,cACL,MAAO,eACP,aAAc,IACd,KAAM,QACN,KAAM,CACJ,IAAK,EACL,IAAK,GACL,KAAM,GACR,EACA,KAAM,CAAC,CAAA,WAAE,CAAU,CAAE,GAAK,EAC1B,aAAc,CAAA,EACd,aAAc,CAAC,CAAA,YAAE,CAAW,CAAE,GAC5B,AAAA,EAAwB,EAC5B,EACA,CACE,IAAK,YACL,MAAO,aACP,aAAc,UACd,KAAM,QACN,KAAM,CAAC,CAAA,WAAE,CAAU,CAAE,GAAK,CAC5B,EACD,AACH,EACA,CACE,IAAK,kBACL,MAAO,iBACP,aAAc,CAAA,EACd,KAAM,WACN,aAAc,CAAA,CAChB,EACA,CACE,IAAK,aACL,MAAO,YACP,aAAc,CAAA,EACd,KAAM,WACN,KAAM,CAAC,CAAA,gBAAE,CAAe,CAAE,GAAK,EAC/B,aAAc,CAAA,CAChB,EACA,EACD,AAAC,AAEF,CAAA,cAAgB,CACd,WAAY,SACd,CAAE,AAEF,EAAA,CAAK,AAAQ,AACb,CAAA,MAAe,AACf,CAAA,KAAa,AACb,CAAA,QAAmB,AACnB,EAAA,CAAO,AAAS,AAEhB,CAAA,SAAiB,CACf,GAAM,CAAA,OACJ,CAAM,CAAA,QACN,CAAO,CAAA,OACP,CAAM,CAAA,eACN,CAAc,CAAA,WACd,CAAU,CAAA,WACV,CAAU,CAAA,cACV,CAAa,CAAA,SACb,CAAQ,CAAA,YACR,CAAW,CACZ,CAAG,IAAI,CAAC,MAAM,CACT,EACH,EAAiB,KAAK,EAAE,CAAI,IAAM,KAAK,EAAE,CAAG,EAEzC,EAAS,EACX,KAAK,GAAG,IAAI,AAAC,CAAA,IAAI,CAAC,IAAI,EAAI,IAAI,CAAC,OAAO,EAAA,EAAI,GAAG,CAAC,AAAA,GAAK,EAAI,EAAI,IAC3D,KACE,EAAe,EACjB,KAAK,KAAK,CAAC,EAAY,EAAiB,GACxC,EACE,EAAY,EACd,EAAU,CAAA,EAAI,KAAK,GAAG,CAAE,AAAO,EAAe,EAAtB,EAAwC,EAAA,EAChE,EAcE,EAAW,AAZD,IAAI,EAAQ,CAC1B,MAAO,EACP,KAAM,IAAI,CAAC,OAAO,GAClB,OACE,EACA,EACC,CAAA,GAAc,EAAW,EAAc,EAAS,CAAA,EACnD,SAAU,EACV,QAAS,CAAA,EACT,aAAc,CAChB,GAEyB,QAAQ,CAAG,EAC9B,EAAc,EAAY,CAAA,EAAI,KAAK,GAAG,CAAC,KAAK,EAAE,CAAG,EAAA,EAEjD,EAAoB,AAAI,MAAM,GAAU,GAAA,GAC3C,IAAI,CAAC,MACL,GAAG,CAAC,CAAC,EAAG,IAAU,AAAQ,EAAR,EAAY,GAEjC,MAAO,CACL,SAAA,EACA,eAAiB,EAAW,KAAK,IAAI,CAAC,GAAM,EAC5C,YAAA,EACA,uBAAwB,EAAW,EACnC,aAAc,EAAc,EAC5B,cAAe,EAAI,GAAU,EAC7B,kBAAA,EACA,sBAAA,EACA,OAAA,CACF,CACF,CAEA,gBAAiB,CACf,KAAK,CAAC,iBAEN,IAAI,CAAC,MAAM,CAAG,KACd,IAAI,CAAC,CAAA,CAAK,CAAG,IACf,CAEA,WAAY,CACV,KAAK,CAAC,YAEN,GAAM,CAAA,aACJ,CAAY,CAAA,OACZ,CAAM,CAAA,cACN,CAAa,CAAA,WACb,CAAU,CAAA,WACV,CAAU,CAAA,SACV,CAAQ,CAAA,cACR,CAAa,CACb,GAAG,EACJ,CAAG,IAAI,CAAC,MAAM,CAMf,GAJI,AAAC,IAAI,CAAC,CAAA,CAAK,EACb,CAAA,IAAI,CAAC,CAAA,CAAK,CAAG,IAAI,CAAC,OAAO,EAD3B,EAII,GAAc,EAAU,CAC1B,IAAM,EAA6B,CACjC,KAAM,IAAI,CAAC,IAAI,CACf,EAAG,EACH,OAAQ,EAAO,MAAM,CACrB,SAAU,EAAO,cAAc,AACjC,CAEI,CAAA,IAAI,CAAC,CAAA,CAAO,CACd,IAAI,CAAC,CAAA,CAAO,CAAC,SAAS,CAAC,GAEvB,IAAI,CAAC,CAAA,CAAO,CAAG,IAAI,EAAO,EAE9B,MACE,IAAI,CAAC,CAAA,CAAO,CAAG,IAGb,AAAC,CAAA,IAAI,CAAC,MAAM,EACd,CAAA,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,SAAS,EAD9B,EAII,AAAC,IAAI,CAAC,SAAS,EACjB,CAAA,IAAI,CAAC,SAAS,CAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAA,CAAK,CAAA,EAG/C,IAAM,EAAiB,EACnB,EACE,EACA,KAAK,GAAG,CAAC,EAAY,GACvB,CAEJ,CAAA,IAAI,CAAC,KAAK,CAAG,IAAI,EAAM,CACrB,GAAG,CAAM,CACT,aAAA,EACA,WAAY,CACd,GAEI,EACF,IAAI,CAAC,QAAQ,CAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CACrC,UAAW,EACX,WAAY,CACd,GAEA,IAAI,CAAC,QAAQ,CAAG,IAEpB,CAEA,kBAAkB,CAAA,OAChB,CAAM,CAAA,SACN,CAAQ,CAAA,WACR,CAAU,CAAA,oBACV,CAAmB,CAMpB,CAAmB,KACd,EACA,GAEF,CAAA,EAAc,IAAI,CAAC,CAAA,CAAuB,CADpB,AAAC,CAAA,EAAsB,CAAA,EAAK,EAClD,EAIF,IAAM,EAAiB,KAAU,CAC9B,IAAI,CAAC,MACL,GAAG,CAAC,CAAC,EAAG,IAAO,IAAM,EAAc,EAAE,CAAG,CAAC,EAAO,EAEnD,IAAK,IAAI,EAAO,EAAG,EAAO,EAAG,IAAQ,CACnC,GAAI,GAAc,IAAS,EACzB,SAEF,IAAM,EAAY,EAAW,AAAQ,EAAM,EAAd,EACvB,EAAqB,CAAc,CAAC,EAAK,CAEzC,EAAe,KAAK,GAAG,CAAC,GACxB,EAAe,KAAK,GAAG,CAAC,GAE9B,IAAK,IAAI,EAAI,EAAG,GAAK,IAAI,CAAC,MAAM,CAAC,OAAO,CAAE,IAAK,CAC7C,IAAM,EAAgB,EAAI,IAAI,CAAC,CAAA,CAAK,CAAC,YAAY,CAEjD,EAAmB,IAAI,CAAC,CACtB,CAAM,CAAC,EAAE,CAAG,EAAgB,EAC5B,CAAM,CAAC,EAAE,CAAG,EAAgB,EAC7B,CACH,CACF,CAEA,OAAO,CACT,CAEA,WAAoB,CAClB,GAAI,IAAI,CAAC,MAAM,CACb,OAAO,IAAI,CAAC,MAAM,CAGpB,GAAM,CAAA,OAAE,CAAM,CAAA,WAAE,CAAU,CAAE,CAAG,IAAI,CAAC,MAAM,CAEpC,EAAgB,IAAI,CAAC,CAAA,CAAK,CAAC,WAAW,CACtC,EAAgB,IAAI,CAAC,CAAA,CAAK,CAAC,cAAc,CAAG,EAC5C,EAAuB,EAAE,CAEzB,EAAc,EAAa,EAAS,EAAI,EAE9C,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAa,IAAS,CAChD,IAAM,EAAa,GAAc,IAAU,EAErC,EAA0C,EAAE,CAClD,EAAa,IAAI,CAAC,GAElB,IAAM,EAAyB,IAAI,CAAC,CAAA,CAAK,CAAC,iBAAiB,CAAC,EAAM,CAG5D,EAAiB,AAAI,MAAM,GAC9B,IAAI,CAAC,MACL,GAAG,CAAC,CAAC,EAAG,KACP,IAAM,EAAY,EAAI,GAAM,EACtB,EAAmB,CACvB,IAAI,CAAC,CAAA,CAAK,CAAC,sBAAsB,CAAI,CAAA,EAAI,CAAA,EACzC,EAAQ,IAAI,CAAC,CAAA,CAAK,CAAC,cAAc,CAC9B,CAAA,EAAY,EAAgB,CAAA,EAChC,CAED,MAAO,CACL,SAAU,KAAK,IAAI,CAAC,CAAgB,CAAC,EAAE,CAAG,CAAgB,CAAC,EAAE,EAC7D,mBAAoB,KAAK,IAAI,CAC3B,CAAgB,CAAC,EAAE,EAAI,EAAI,CAAgB,CAAC,EAAE,EAAI,EAEtD,CACF,GAEF,IAAK,IAAI,EAAO,EAAG,EAAO,EAAG,IAAQ,CACnC,IAAM,EAAe,CAAW,CAAC,EAAK,CAEtC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAwB,IAAK,CAC/C,GAAI,GAAc,EAAI,GAAM,EAAG,CAE7B,EAAqB,IAAI,CAAC,MAC1B,QACF,CAEA,GAAM,CAAA,mBAAE,CAAkB,CAAA,SAAE,CAAQ,CAAE,CAAG,CAAc,CAAC,EAAE,CAEpD,EACJ,EAAe,EAAW,IAAI,CAAC,CAAA,CAAK,CAAC,qBAAqB,CAEtD,EAA0B,CAC9B,IAAI,CAAC,MAAM,CAAC,EAAE,CAAG,EAAqB,KAAK,GAAG,CAAC,GAC/C,IAAI,CAAC,MAAM,CAAC,EAAE,CAAG,EAAqB,KAAK,GAAG,CAAC,GAChD,CAEK,EAAiB,IAAI,CAAC,iBAAiB,CAAC,CAC5C,OAAQ,EACR,SACE,EACA,EAAQ,EAAO,EACf,EAAI,EACJ,IAAI,CAAC,CAAA,CAAK,CAAC,qBAAqB,CAClC,WAAA,EACA,oBAAqB,CACvB,GAEA,EAAqB,IAAI,CAAC,EAC5B,CACF,CACF,CAEA,OAAO,CACT,CAEA,CAAC,wBAAwB,CAAA,OACvB,CAAM,CAAA,MACN,CAAK,CAAA,YACL,CAAW,CAKZ,CAAmB,CAClB,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAC3C,GAAM,CAAA,QAAE,CAAO,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,MAAM,CACjC,EAAa,IAAU,EAEvB,EAAc,EAChB,IAAI,CAAC,CAAA,CAAuB,CAAC,EAAc,GAC3C,EACE,EAAW,EAAa,EAAc,EACtC,EAAY,EAAa,EAAU,EAAU,EAEnD,IAAK,IAAI,EAAO,EAAa,GAAQ,EAAU,IAAQ,CACrD,IAAM,EAAW,IAAI,CAAC,CAAA,CAAuB,CAAC,GAC1C,EAAY,CAAM,CAAC,EAAK,CAAC,EAAE,CAE/B,IAAK,IAAI,EAAI,EAAG,GAAK,EAAW,IAAK,CACnC,IAAM,EAAa,EAAI,GAAM,EAEvB,EAAY,EAAE,CACd,EAAgB,EAAa,IAAI,CAAC,MAAM,CAAC,OAAO,CAAG,EAAI,EACvD,EAAa,EAAa,EAAW,EAC3C,EAAU,IAAI,CAAC,CAAM,CAAC,EAAW,CAAC,EAAc,EAE5C,EAAI,GACN,EAAU,IAAI,CACZ,CAAM,CAAC,EAAW,CAChB,EAAa,EAAgB,EAAI,EAAgB,EAClD,EAIL,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,KAAc,GACxC,EAAY,CAAS,CAAC,EAAU,MAAM,CAAG,EAAE,CAE3C,KACF,CACF,CACF,CAEA,CAAC,gCAAgC,CAAA,UAC/B,CAAS,CAAA,UACT,CAAS,CAAA,MACT,CAAK,CAAA,cACL,CAAa,CAAA,oBACb,CAAmB,CAAA,YACnB,CAAW,CAQZ,CAAmB,CAClB,GAAM,CAAA,QAAE,CAAO,CAAA,UAAE,CAAS,CAAE,CAAG,IAAI,CAAC,MAAM,CACpC,EAAiB,IAAI,CAAC,CAAA,CAAK,CAAC,iBAAiB,CAAC,EAAM,CACpD,EAAc,EAAgB,EAAkB,EAEtD,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAEvB,IAAM,EAAuB,IAAwB,EAAiB,EAGhE,EAAY,EACd,CACE,IAAI,CAAC,CAAA,CAAuB,CAAC,GAC7B,IAAI,CAAC,CAAA,CAAuB,CAAC,EAAY,IAC1C,CACD,CAPc,EASZ,IAAI,CAAC,CAAA,CAAuB,CAThB,EAWV,EAAsB,EAAI,EAAI,IAEjC,CAEL,IAAK,IAAI,EAAI,EAAG,EAAI,EAAG,IAGrB,IAAK,GAAM,CAAA,WAAE,CAAU,CAAA,gBAAE,CAAe,CAAA,gBAAE,CAAe,CAAE,GAF7C,EAAoB,IAAI,CAAC,IAAI,CAAE,GAG3C,IAAI,CAAC,QAAQ,CAAC,WAAW,CACvB,CAAe,CAAC,EAAW,CAC3B,CAAe,CAAC,EAAW,EAG7B,MAIJ,SAAU,EAAoB,CAAY,EAKxC,IAAM,EAAS,CAAS,CAAC,EAAK,CACxB,EAAS,AAiBf,CAAA,kBACE,AAAI,EACK,IAAI,CAAC,CAAA,CAAuB,CAAC,GAEhC,AAAS,IAAT,GAAc,EACT,EAEH,AAAS,IAAT,GAAc,EACT,EAEA,IAAI,CAAC,CAAA,CAAuB,CAAC,EAAQ,EAIpD,CAAA,EA/BmC,IAAI,CAAC,IAAI,EAEtC,EAAkB,CAAS,CAAC,EAAO,CACnC,EAAkB,CAAS,CAAC,EAAO,CAEnC,EAAO,EAAO,EAAU,EAAU,EAExC,GAAI,AAAS,IAAT,EACF,IAAK,IAAI,EAAI,EAAG,GAAK,EAAM,IACzB,KAAM,CAAE,WAAY,EAAU,EAAG,gBAAA,EAAiB,gBAAA,CAAgB,OAGpE,IAAK,IAAI,EAAI,EAAM,GAAK,EAAG,IACzB,KAAM,CAAE,WAAY,EAAU,EAAG,gBAAA,EAAiB,gBAAA,CAAgB,CAmBxE,CACF,CAEA,CAAA,CAAuB,CAAC,CAAa,CAAE,EAAY,CAAC,EAClD,IAAM,EAAS,EAAQ,SACvB,AAAI,EAAS,EACJ,EAEL,EAAS,EACJ,EAEF,CACT,CAEA,CAAC,iBAAmC,CAClC,GAAM,CAAA,KACJ,CAAI,CAAA,gBACJ,CAAe,CAAA,WACf,CAAU,CAAA,OACV,CAAM,CAAA,WACN,CAAU,CAAA,SACV,CAAQ,CAAA,UACR,CAAS,CACV,CAAG,IAAI,CAAC,MAAM,CAET,EAAiB,IAAI,CAAC,SAAS,GAEjC,EAAa,GAEjB,IAAK,IAAM,KAAS,EAAgB,CAElC,IAAM,EAAa,EAAA,IAAe,EAE9B,EAAgB,GACd,EAAmB,EAAM,MAAM,CAAG,EAExC,IAAK,IAAM,KAAY,EAAO,CAC5B,IACA,IAAM,EAAiB,IAAI,CAAC,CAAA,CAAK,CAAC,iBAAiB,CAAC,EAAW,CACzD,EAAsB,EAAgB,EAE5C,GAAI,GAAQ,CAAC,IACP,AAAkB,IAAlB,GACF,CAAA,MAAO,IAAI,CAAC,+BAA+B,CAAC,CAC1C,UAAW,CAAK,CAAC,EAAiB,CAClC,UAAW,EACX,MAAO,EACP,cAAe,EACf,oBAAqB,EAAmB,CAC1C,EAAA,EAEE,IAAkB,GACpB,CAAA,MAAO,IAAI,CAAC,+BAA+B,CAAC,CAC1C,UAAW,EACX,UAAW,CAAK,CAAC,EAAgB,EAAE,CACnC,MAAO,EACP,cAAA,EACA,oBAAA,CACF,EAAA,EAIA,EAAsB,GAAM,GAC3B,CAAA,GAAc,EAAa,EAAS,CAAA,GACrC,CAIA,IAAM,EACJ,AAJW,KAAK,KAAK,CAAC,EAAgB,GAEtC,IAAI,CAAC,CAAA,CAAK,CAAC,iBAAiB,CAAC,EAAa,EAAE,CAEhB,EAAsB,CAEpD,OAAO,IAAI,CAAC,+BAA+B,CAAC,CAC1C,UAAW,EACX,UAAW,CAAc,CAAC,EAAa,EAAE,CAAC,EAAuB,CACjE,MAAO,EACP,cAAA,EACA,oBAAA,EACA,YAAa,CAAA,CACf,EACF,CAGF,IAAM,EACJ,EAAgB,IAAI,CAAC,CAAA,CAAK,CAAC,iBAAiB,CAAC,EAAW,AAEtD,CAAA,GAAoB,CAAA,CAAC,GAAc,EAAc,CAAA,GACnD,CAAA,MAAO,IAAI,CAAC,uBAAuB,CAAC,CAClC,OAAQ,EACR,MAAO,EACP,YAAA,CACF,EAAA,CAEJ,CACF,CAEI,GAAc,GAChB,CAAA,MAAO,IAAI,CAAC,CAAA,CAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAE,CAC1C,SAAU,EAAW,EACrB,MAAO,CACT,EAAA,CAEJ,CAEA,aAAa,CAAY,CAAU,CACjC,GAAI,IAAI,CAAC,SAAS,CAChB,OAAO,IAAI,CAAC,SAAS,AAGnB,CAAC,GACH,CAAA,EAAO,IAAI,CAAC,OAAO,EADrB,EAIA,GAAM,CAAA,OACJ,CAAM,CAAA,QACN,CAAO,CAAA,KACP,CAAI,CAAA,gBACJ,CAAe,CAAA,WACf,CAAU,CAAA,cACV,EAAgB,CAAA,CACjB,CAAG,IAAI,CAAC,MAAM,CACT,CAAA,cAAE,CAAa,CAAE,CAAG,EAEpB,EAAuB,EAAO,AAAU,EAAV,EAAc,EAK5C,EAAwB,GAAU,GAAA,EAWxC,OACE,EAduB,CAAA,AAFH,CAAA,EAAkB,AAAU,EAAV,EAAc,CAAA,EAEb,CAAzC,EAWE,CAAA,GAAmB,EAAa,EAAI,EAFlB,CAAA,EAAU,CAAA,EAE+B,CAAA,EAP3D,EACG,CAAA,EAAwB,CAAA,EACzB,EACA,EACF,EASA,CAEJ,CAEA,WAAY,CACV,IAAM,EAAiB,IAAI,CAAC,SAAS,GACjC,EAAQ,EACZ,IAAK,IAAM,KAAS,EAClB,IAAK,IAAM,KAAY,EACrB,GAAI,AAAY,MAAZ,EAEF,IAAK,IAAM,KAAgB,EACzB,IAAK,IAAM,KAAS,EAClB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAE,MAAA,EAAO,OAAQ,GAAQ,EAOlD,CAAA,IAAI,CAAC,CAAA,CAAO,EACd,IAAI,CAAC,CAAA,CAAO,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAErC,CAEA,OAAO,gBAAkB,CACvB,OAAQ,EACR,QAAS,EACT,KAAM,CAAA,EACN,WAAY,CAAA,CACd,CAAE,AACJ,ExB9vBE,EACA,EACA,EACD,A6B1Bc,OAAA,UAAgC,YAC7C,OAAO,eAAiB,CAAA,CAAK,AAC7B,CAAA,SAA4B,AAE5B,CAAA,MAAgB,CAAE,AAClB,CAAA,WAAsB,CAAA,CAAM,AAC5B,CAAA,QAAmB,CAAA,CAAM,AACzB,CAAA,KAAwB,KAAM,AAE9B,EAAA,CAAM,CAAwB,IAAK,AAEnC,cAAc,CACZ,KAAK,GACL,IAAI,CAAC,YAAY,CAAC,CAAE,KAAM,OAAQ,eAAgB,CAAA,CAAK,GAEvD,IAAI,CAAC,UAAU,CAAC,SAAS,CAAG;A;AAE5B,IAAA,CAAC,CAED,IAAI,CAAC,CAAA,CAAM,CAAG,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,0BAC5C,IAAI,CAAC,SAAS,CAAG,IAAI,CAAC,eAAe,EACvC,CAEA,WAAW,oBAAqB,CAC9B,MAAO,CAAC,QAAS,aAAc,QAAS,UAAW,OAAO,AAC5D,CAEA,yBAAyB,CAAY,CAAE,CAAc,CAAE,CAAc,CAAE,CACjE,AAAS,UAAT,GACF,CAAA,IAAI,CAAC,KAAK,CAAG,CADf,EAIa,UAAT,IACF,IAAI,CAAC,KAAK,CAAG,SAAS,EAAQ,IAC9B,IAAI,CAAC,CAAA,CAAc,IAGR,YAAT,IACF,IAAI,CAAC,OAAO,CAAG,CAAC,CAAC,EACjB,IAAI,CAAC,CAAA,CAAc,IAGR,eAAT,IACF,IAAI,CAAC,UAAU,CAAG,CAAC,CAAC,EACpB,IAAI,CAAC,CAAA,CAAc,IAIR,SAAT,IACF,IAAI,CAAC,IAAI,CAAG,AAAW,UAAX,EAAqB,QAAU,MAC3C,IAAI,CAAC,CAAA,CAAc,GAEvB,CAEA,IAAI,OAAgB,CAClB,OAAO,IAAI,CAAC,CAAA,CAAM,CAAC,KAAK,AAC1B,CAEA,IAAI,MAAM,CAAkB,CAAE,CAC5B,IAAI,CAAC,CAAA,CAAM,CAAC,KAAK,CAAG,EACpB,IAAI,CAAC,CAAA,CAAc,GAEf,IAAI,CAAC,UAAU,EACjB,IAAI,CAAC,CAAA,CAAc,EAEvB,CAEA,mBAAoB,CACd,IAAI,CAAC,YAAY,CAAC,UACpB,CAAA,IAAI,CAAC,KAAK,CAAG,SAAS,IAAI,CAAC,YAAY,CAAC,SAD1C,EAII,IAAI,CAAC,YAAY,CAAC,eACpB,CAAA,IAAI,CAAC,UAAU,CAAG,CAAA,CADpB,EAGA,IAAI,CAAC,CAAA,CAAc,GAEnB,IAAI,CAAC,CAAA,CAAM,CAAC,gBAAgB,CAAC,QAAS,AAAA,GAAK,IAAI,CAAC,CAAA,CAAY,CAAC,GAC/D,CAEA,CAAA,CAAY,CAAC,CAAQ,EACnB,IAAM,EAAQ,IAAI,CAAC,KAAK,CAExB,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,OAAO,IAEnC,IAAI,CAAC,aAAa,CAChB,IAAI,YAAY,QAAS,CACvB,OAAQ,CAAE,MAAA,CAAM,CAClB,IAGF,IAAI,CAAC,CAAA,CAAc,GACnB,IAAI,CAAC,CAAA,CAAc,EACrB,CACA,sBAAuB,CAEvB,CAEA,OAAQ,CAAC,CAET,MAAO,CAAC,CAER,CAAA,CAAc,GACZ,IAAM,EACJ,AAAc,UAAd,IAAI,CAAC,IAAI,CACL,CAAC,mBAAmB,EAAE,IAAI,CAAC,OAAO,CAAG,OAAS,QAAQ,QAAQ,EAC5D,IAAI,CAAC,KAAK,EAAI,IAAM,SAAW,UAChC,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,cAAc,EAEpC,IAAI,CAAC,KAAK,CAAI,CAAA,AAAe,MAAf,IAAI,CAAC,KAAK,CAAW,IAAM,IAAI,CAAC,KAAI,AAAJ,EAC/C,SAAS,CAAC,CAhHnB,8EAmHE,IAAI,CAAC,CAAA,CAAM,CAAC,YAAY,CAAC,aAAc,EACzC,CAEA,CAAA,CAAc,GACZ,IAAM,EAAa,IAAI,CAAC,UAAU,CAC9B,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CA1HV,QA6HxB,IAAI,CAAC,CAAA,CAAM,CAAC,YAAY,CAAC,aAAc,EACzC,CACF,CAEA,eAAe,MAAM,CAAC,uBAAwB,GChI9C,MAAM,EAAa,gBAGJ,OAAA,UAAkC,YAC/C,OAAO,eAAiB,CAAA,CAAK,AAC7B,CAAA,SAA4B,AAE5B,CAAA,GAAY,AACZ,CAAA,GAAY,AAEZ,EAAA,CAAM,CAAqB,IAAK,AAChC,EAAA,CAAgB,CAAqB,IAAK,AAC1C,EAAA,CAAK,CAfuB,GAeU,AACtC,EAAA,CAAU,CAAW,IAAK,AAC1B,EAAA,CAAc,CAAW,IAAK,AAC9B,EAAA,CAAW,CAAkB,IAAK,AAClC,EAAA,CAAa,CAAW,IAAK,AAC7B,EAAA,CAAW,CAAW,IAAK,AAC3B,EAAA,CAAW,CAAW,IAAK,AAC3B,EAAA,CAAiB,CAAW,IAAK,AACjC,EAAA,CAAe,AAAiB,AAEhC,cAAc,CACZ,KAAK,GACL,IAAI,CAAC,YAAY,CAAC,CAAE,KAAM,OAAQ,eAAgB,CAAA,CAAK,GAEvD,IAAI,CAAC,UAAU,CAAC,SAAS,CAAG;A/BxBjB;AAAA;AACb;AASA;AAEA;AAGe;AAEX;AAAe;AACf;AAAA;AAAA;AAAA;AACgB;AAAhB;AAGkB;AAClB;AAAU;AACV;AAAA;AAEG;AACA;AAED;AAAyB;AAC3B;AAAA;AAAI;AAKN;AAAA;AACE;AAAA;AAGsC;AAG1C;AAEA;AAAA;AAEI;AAAc;AACd;AAAK;AAAL;AAIJ;AAAiD;AACjC,S+BcT,CAEL,IAAI,CAAC,CAAA,CAAM,CAAG,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,uBAC5C,IAAI,CAAC,CAAA,CAAgB,CAAG,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,eACtD,IAAI,CAAC,CAAA,CAAK,CA3EgB,IA4E1B,IAAI,CAAC,CAAA,CAAc,CAAG,KAEtB,IAAI,CAAC,SAAS,CAAG,IAAI,CAAC,eAAe,EACvC,CAEA,WAAW,oBAAqB,CAC9B,MAAO,CAAC,MAAO,MAAO,QAAS,OAAQ,OAAQ,aAAc,aAAa,AAC5E,CAEA,yBAAyB,CAAI,CAAE,CAAM,CAAE,CAAM,CAAE,KAWzC,EAaJ,GAvBI,AAAS,SAAT,EACF,IAAI,CAAC,CAAA,CAAW,CAAG,IAAI,CAAC,aAAa,GAC5B,IAAI,CAAC,CAAA,CAAM,EACpB,CAAA,IAAI,CAAC,CAAA,CAAM,CAAC,EAAK,CAAG,CADf,EAIH,CAAA,AAAS,QAAT,GAAkB,AAAS,QAAT,CAAS,GAC7B,CAAA,IAAI,CAAC,EAAK,CAAG,OAAO,EADtB,EAKI,AAAS,UAAT,GACF,CAAA,EAAQ,OAAO,EADjB,EAII,AAAS,eAAT,GACF,CAAA,IAAI,CAAC,CAAA,CAAW,CAAG,CADrB,EAII,AAAS,eAAT,GACF,CAAA,IAAI,CAAC,CAAA,CAAW,CAAG,CADrB,EAIgB,MAAZ,IAAI,CAAC,GAAG,EAAY,AAAY,MAAZ,IAAI,CAAC,GAAG,GAC1B,IAAI,CAAC,GAAG,CAAG,IAAI,CAAC,GAAG,GACrB,IAAI,CAAC,GAAG,CAAG,IAAI,CAAC,GAAG,CACnB,IAAI,CAAC,CAAA,CAAM,CAAC,GAAG,CAAG,OAAO,IAAI,CAAC,GAAG,GAGnC,IAAI,CAAC,CAAA,CAAa,CAChB,AAAC,CAAA,IAAI,CAAC,GAAG,CAAG,IAAI,CAAC,GAAG,AAAH,EAAO,IAAI,CAAC,CAAA,CAAK,EApHZ,IAsHpB,IAAI,CAAC,CAAA,CAAW,EAAI,AAAc,MAAd,IAAI,CAAC,KAAK,EAAU,CAC1C,IAAM,EAAe,IAAI,CAAC,cAAc,CAAC,EACrC,AAAgB,OAAhB,GACF,CAAA,IAAI,CAAC,CAAA,CAAc,CAAG,CADxB,CAGF,CAGF,IAAI,CAAC,CAAA,CAAS,EAChB,CAEA,IAAI,OAAgB,CAClB,OAAO,OAAO,IAAI,CAAC,CAAA,CAAM,CAAC,KAAK,CACjC,CAEA,IAAI,MAAM,CAAkB,CAAE,CAC5B,IAAI,CAAC,CAAA,CAAM,CAAC,KAAK,CAAG,OAAO,GAC3B,IAAI,CAAC,CAAA,CAAS,EAChB,CAEA,mBAAoB,CAClB,CAAC,MAAO,MAAO,QAAS,OAAO,CAAC,OAAO,CAAC,AAAA,IAClC,IAAI,CAAC,YAAY,CAAC,IACpB,CAAA,IAAI,CAAC,CAAA,CAAM,CAAC,EAAK,CAAG,IAAI,CAAC,YAAY,CAAC,EADxC,CAGF,GAEA,IAAI,CAAC,CAAA,CAAW,CAAG,IAAI,CAAC,aAAa,GACrC,IAAI,CAAC,CAAA,CAAe,CAAG,IAAI,eAAe,AAAA,IACxC,IAAK,IAAI,KAAS,EACF,EAAM,WAAW,CAAC,KAAK,CACrC,IAAI,CAAC,CAAA,CAAS,EAElB,GACA,IAAI,CAAC,CAAA,CAAe,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,CAAM,EAExC,IAAI,CAAC,CAAA,CAAM,CAAC,gBAAgB,CAAC,QAAS,IAAM,IAAI,CAAC,WAAW,IAC5D,IAAI,CAAC,CAAA,CAAM,CAAC,gBAAgB,CAAC,UAAW,AAAA,GAAK,IAAI,CAAC,aAAa,CAAC,IAChE,IAAI,CAAC,CAAA,CAAM,CAAC,gBAAgB,CAC1B,SACA,IAAO,IAAI,CAAC,CAAA,CAAiB,CAAG,MAGlC,IAAI,CAAC,QAAQ,CAAG,CAClB,CAEA,sBAAuB,CACrB,IAAI,CAAC,CAAA,CAAe,CAAC,SAAS,CAAC,IAAI,CACrC,CAEA,eAAgB,CACd,IAAM,EAAQ,IAAI,CAAC,YAAY,CAAC,QAC1B,EAAa,GAAO,MAAM,uBAChC,AAAK,EACE,EACJ,GAAG,CAAC,QACJ,MAAM,CAAC,AAAA,GAAK,CAAC,MAAM,IACnB,IAAI,GAJiB,EAAE,AAK5B,CAEA,CAAA,CAAgB,CAAC,CAAQ,CAAE,CAAW,EAKpC,GAJI,AAAe,MAAf,GACF,CAAA,EAAc,IAAI,CAAC,cAAc,CAAC,EADpC,EAII,AAAe,MAAf,EACF,MAAO,CAAA,EAIT,IAAM,EAAmB,KAAK,GAAG,CAAC,EAAW,WAG3C,CAAA,GAAoB,IAAI,CAAC,CAAA,CAAa,CAAG,GACzC,EAAmB,KAAK,GAAG,CAAC,IAAI,CAAC,CAAA,CAAU,CAAG,EAAA,CAMlD,CAGA,CAAA,CAAa,CAAC,CAAc,CAAE,CAAc,EAE1C,OAAO,AADU,KAAK,GAAG,CAAC,EAAS,GAAW,CAAA,IAAI,CAAC,GAAG,CAAG,IAAI,CAAC,GAAG,AAAH,GAtMtC,EAwM1B,CAEA,OAAQ,CACN,IAAI,CAAC,CAAA,CAAM,CAAC,KAAK,EACnB,CAEA,MAAO,CACL,IAAI,CAAC,CAAA,CAAM,CAAC,IAAI,EAClB,CAEA,aAAc,CACZ,IAAM,EAAQ,OAAO,IAAI,CAAC,CAAA,CAAM,CAAC,KAAK,EAChC,EAAc,IAAI,CAAC,cAAc,CAAC,GAExC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAA,CAAM,CAAC,KAAK,EAG3C,AAAe,MAAf,GACA,IAAI,CAAC,CAAA,CAAiB,GAAK,GAC3B,IAAI,CAAC,CAAA,CAAgB,CAAC,EAAO,IAE7B,CAAA,IAAI,CAAC,CAAA,CAAiB,CAAG,CAL3B,EAQI,IAAgB,IAAI,CAAC,CAAA,CAAiB,GACpC,AAAgB,OAAhB,GACF,IAAI,CAAC,CAAA,CAAM,CAAC,KAAK,CAAG,OAAO,GACvB,IAAgB,IAAI,CAAC,CAAA,CAAc,GACrC,IAAI,CAAC,CAAA,CAAQ,GACb,IAAI,CAAC,CAAA,CAAc,CAAG,IAEf,AAAuB,MAAvB,IAAI,CAAC,CAAA,CAAc,EAC5B,CAAA,IAAI,CAAC,CAAA,CAAc,CAAG,IADxB,GAMA,AAA0B,MAA1B,IAAI,CAAC,CAAA,CAAiB,EACtB,AAAe,MAAf,GACA,IAAI,CAAC,CAAA,CAAa,CAAC,EAAO,IAAI,CAAC,CAAA,CAAiB,GAEhD,CAAA,IAAI,CAAC,CAAA,CAAiB,CAAG,IAL3B,EAQA,IAAI,CAAC,CAAA,CAAS,GACd,IAAI,CAAC,CAAA,CAAU,CAAG,EAElB,IAAI,CAAC,aAAa,CAChB,IAAI,YAAY,QAAS,CACvB,OAAQ,CAAE,MAAO,IAAI,CAAC,CAAA,CAAM,CAAC,KAAK,AAAC,CACrC,GAEJ,CAEA,cAAc,CAAoB,CAAE,KAK9B,EAJJ,EAAM,cAAc,GACpB,IAAM,EAAO,OAAO,IAAI,CAAC,CAAA,CAAM,CAAC,IAAI,EAAI,GAClC,EAAQ,OAAO,IAAI,CAAC,CAAA,CAAM,CAAC,KAAK,EAItC,GAAI,AAAc,cAAd,EAAM,GAAG,CACX,EAAW,KAAK,GAAG,CAAC,IAAI,CAAC,GAAG,CAAE,EAAQ,QACjC,GAAI,AAAc,eAAd,EAAM,GAAG,CAClB,EAAW,KAAK,GAAG,CAAC,IAAI,CAAC,GAAG,CAAE,EAAQ,QACjC,GAAI,AAAc,YAAd,EAAM,GAAG,CAAgB,CAClC,IAAM,EAAO,IAAI,CAAC,CAAA,CAAW,CAAC,IAAI,CAAC,AAAA,GAAK,EAAI,EACxC,AAAS,MAAA,IAAT,EACF,EAAW,EACF,IAAU,IAAI,CAAC,GAAG,EAE3B,CAAA,EAAW,IAAI,CAAC,GAAG,AAAH,CAEpB,MAAO,GAAI,AAAc,cAAd,EAAM,GAAG,CAAkB,CAEpC,IAAM,EAAO,AADI,IAAI,IAAI,CAAC,CAAA,CAAW,CAAC,CAAC,OAAO,GACxB,IAAI,CAAC,AAAA,GAAK,EAAI,EAChC,AAAS,MAAA,IAAT,EACF,EAAW,EACF,IAAU,IAAI,CAAC,GAAG,EAC3B,CAAA,EAAW,IAAI,CAAC,GAAG,AAAH,CAEpB,CAeA,OAbgB,MAAZ,IACF,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,CAAA,CAAU,CAAG,EAElB,IAAI,CAAC,aAAa,CAChB,IAAI,YAAY,QAAS,CACvB,OAAQ,CAAE,MAAO,CAAS,EAC1B,QAAS,CAAA,EACT,SAAU,CAAA,CACZ,KAIG,CAAA,CACT,CAEA,eAAe,CAAa,CAAU,CACpC,GAAI,CAAC,IAAI,CAAC,CAAA,CAAW,EAAI,AAA4B,IAA5B,IAAI,CAAC,CAAA,CAAW,CAAC,MAAM,CAAQ,OAAO,KAE/D,IAAK,IAAM,KAAa,IAAI,CAAC,CAAA,CAAW,CAEtC,GAAI,AADa,KAAK,GAAG,CAAC,EAAQ,IAClB,IAAI,CAAC,CAAA,CAAa,CAChC,OAAO,EAIX,OAAO,IACT,CAEA,CAAA,CAAQ,GACF,YAAa,WACf,UAAU,OAAO,CAAC,GAEtB,CAEA,CAAA,CAAS,GACP,IAAM,EAAa,IAAI,CAAC,CAAA,CAAM,CAAC,WAAW,CAC1C,GAAI,CAAC,EACH,OAGF,IAAM,EAAe,IAAI,CAAC,KAAK,CAAG,IAAI,CAAC,GAAG,CACpC,EAAQ,IAAI,CAAC,GAAG,CAAG,IAAI,CAAC,GAAG,CAC3B,EAAiB,EAAa,GAC9B,EAAa,AA1UF,EA0UiB,EAAkB,EAAgB,EAI9D,EAAgB,IAAI,CAAC,CAAA,CAAW,EAClC,OAAO,AAAA,GAAK,IAAM,IAAI,CAAC,GAAG,EAAI,IAAM,IAAI,CAAC,GAAG,EAC7C,IACC,AAAA,GACE,AAlVW,EAmVV,EAAkB,CAAA,EAAI,IAAI,CAAC,GAAE,AAAF,EAAQ,EACpC,GAGA,EAA0B,GAC5B,IACA,AAAA,GACE,CAAC,YAAY,EAAE,EAAE,IAAI,EAAE,EAAW,CAAC,EAAE,EAAE,IAAI,EAAE,EAAW,CAAC,EACvD,EA1VO,EA2VR,gBAAgB,EAAE,EA3VV,EA2VyB,EAAE,CAAC,EAExC,KAAK,MACF,EAAkB,GAAe,OACnC,CAAC,0BAA0B,EAAE,EAAwB,GAAG,CAAC,CACzD,KAEE,EAAS,CACb,CAAC;AACa,oBAAA,EAAE,GAAoC,GAAA,EAClD,IAAI,CAAC,CAAA,CAAW,EAChB,CAAC,6CAA6C,EAAE,EAAW,SAAS,EAAE,EAAW,GAAG,CAAC,CACtF;AACA,OAAA,EACC,IAAI,CAAC,CAAA,CAAW,CACZ,GACA;A;AAEQ,oBAAA,EACV,GAAoC,GACrC,mDAAmD,EAAE,EAAW,SAAS,EAAE,EAAW;A;A;AAG3E,oBAAA,EACV,GAAoC,GACrC,oDAAoD,EAAE,EAAW,SAAS,EAAE,EAAW;AACzF,OAAA,CAAC,CAAA,CACA,CACH,AAEG,AAAoB,OAApB,IAAI,CAAC,CAAA,CAAW,EAClB,EAAO,IAAI,CACT,CAAC,wDAAwD,EACvD,IAAI,CAAC,CAAA,CAAW,CACjB,YAAY,CAAC,EAGlB,IAAI,CAAC,CAAA,CAAgB,CAAC,SAAS,CAAG,EAAO,IAAI,CAAC,KAChD,CACF,CAEA,eAAe,MAAM,CAAC,yBAA0B,GF3XhD,MAAM,GAAW,CACf,SAAU,SAAS,aAAa,CAAC,aACjC,cAAe,SAAS,aAAa,CAAC,mBACtC,YAAa,SAAS,aAAa,CAAC,gBACtC,EAGM,GAAS,IAAI,IAAyB,CAAC,QAAS,SAAS,EACzD,GAA0B,gBAwCjB,OAAA,GACb,MAAwB,AACxB,CAAA,cAAwC,AACxC,CAAA,KAAmB,AACnB,CAAA,aAGE,AACF,CAAA,gBAAoE,CAAC,CAAE,AAEvE,EAAA,CAAmB,CAAY,CAAA,CAAM,AACrC,EAAA,CAA0B,AAAS,AACnC,EAAA,CAAe,AAAC,AAChB,EAAA,CAAoB,AAAC,AACrB,EAAA,CAAkB,AAAC,AACnB,EAAA,CAAqB,AAAC,AACtB,EAAA,CAAkB,AAA0C,AAC5D,EAAA,CAAuB,AAAS,AAChC,EAAA,CAAiB,AAAS,AAC1B,EAAA,CAAU,CAAY,CAAA,CAAM,AAC5B,EAAA,CAAoB,AAAC,AAErB,aACE,CAAuC,CACvC,CAAuB,CACvB,CACA,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,cAAc,CAAG,EAEtB,IAAI,CAAC,KAAK,CAAG,IAAI,CAAC,SAAS,IAAM,CAAE,OAAQ,CAAC,CAAE,EAE9C,IAAI,CAAC,aAAa,CAAG,CACnB,MAAO,IAAI,IACX,OAAQ,IAAI,GACd,EAEA,IAAI,CAAC,CAAA,CAAe,CAAG,IAAI,CAAC,CAAA,EAAQ,CAAC,IAAI,CAAC,IAAI,EAC9C,GAAS,QAAQ,CAAC,gBAAgB,CAAC,QAAS,IAAI,CAAC,CAAA,CAAe,EAChE,IAAI,CAAC,CAAA,CAAoB,CAAG,IAAI,CAAC,CAAA,EAAa,CAAC,IAAI,CAAC,IAAI,EACxD,GAAS,QAAQ,CAAC,gBAAgB,CAAC,aAAc,IAAI,CAAC,CAAA,CAAoB,EAC1E,GAAS,QAAQ,CAAC,gBAAgB,CAAC,YAAa,IAAI,CAAC,CAAA,EAAY,EACjE,IAAI,CAAC,CAAA,CAAoB,CAAG,IAAI,CAAC,CAAA,EAAe,CAAC,IAAI,CAAC,IAAI,EAC1D,GAAS,WAAW,CAAC,gBAAgB,CAAC,QAAS,IAAI,CAAC,CAAA,CAAoB,EACxE,GAAS,WAAW,CAAC,gBAAgB,CACnC,UACA,IAAI,CAAC,CAAA,EAAsB,EAE7B,IAAI,CAAC,eAAe,CAAG,CAAC,EACxB,IAAI,CAAC,cAAc,EACrB,CAEA,SAAU,CACR,GAAS,QAAQ,CAAC,mBAAmB,CAAC,QAAS,IAAI,CAAC,CAAA,CAAe,EACnE,GAAS,WAAW,CAAC,mBAAmB,CACtC,QACA,IAAI,CAAC,CAAA,CAAoB,EAE3B,GAAS,WAAW,CAAC,mBAAmB,CACtC,UACA,IAAI,CAAC,CAAA,EAAsB,EAE7B,GAAS,QAAQ,CAAC,mBAAmB,CACnC,aACA,IAAI,CAAC,CAAA,CAAoB,EAE3B,GAAS,QAAQ,CAAC,mBAAmB,CAAC,YAAa,IAAI,CAAC,CAAA,EAAY,EACpE,GAAS,QAAQ,CAAC,SAAS,CAAG,EAChC,CAEA,CAAA,EAAe,CAAgC,CAAC,EAC9C,GAAI,AAAsB,WAAtB,EAAE,MAAM,CAAC,QAAQ,CAAe,CAClC,EAAE,MAAM,CAAC,aAAa,CAAC,SAAS,CAAC,MAAM,CAAC,aACxC,IAAM,EAAU,EAAE,MAAM,CAAC,aAAa,CAAC,OAAO,CAAC,KAAK,AACpD,CAAA,IAAI,CAAC,KAAK,CAAG,CACX,GAAG,IAAI,CAAC,KAAK,CACb,OAAQ,CACN,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CACpB,CAAC,EAAQ,CAAE,CAAC,EAAE,MAAM,CAAC,aAAa,CAAC,SAAS,CAAC,QAAQ,CAAC,YACxD,CACF,EACA,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAC9B,CACF,CAEA,CAAA,EAAsB,CAAC,CAAC,EAClB,AAAsB,WAAtB,EAAE,MAAM,CAAC,QAAQ,EAAiB,AAAU,UAAV,EAAE,GAAG,EACzC,IAAI,CAAC,CAAA,EAAe,CAAC,EAEzB,CAEA,iBACE,CAA0B,CAC1B,CAAwD,CACxD,CACA,GAAI,CAAC,GAAO,GAAG,CAAC,GACd,MAAM,AAAI,MAAM,CAAC,uCAAuC,EAAE,EAAM,EAAE,CAAC,EAGrE,GAAI,CAAE,CAAA,aAAwB,QAAA,EAC5B,MAAM,AAAI,MAAM,0BAGlB,IAAI,CAAC,aAAa,CAAC,EAAM,CAAC,GAAG,CAAC,EAChC,CAEA,cAAc,CAAK,CAAE,CAAS,CAAE,CAC9B,IAAK,IAAM,KAAgB,IAAI,CAAC,aAAa,CAAC,EAAM,CAClD,EAAa,EAEjB,CAEA,CAAA,EAAY,GAGV,IAAM,EAAY,OAAO,YAAY,EACjC,CAAA,GACF,EAAU,eAAe,EAE7B,CAOA,CAAA,EAAa,CAAC,CAAa,EACrB,GAAa,EAAE,MAAM,IACvB,IAAI,CAAC,CAAA,CAAmB,CAAG,CAAA,EAC3B,IAAI,CAAC,CAAA,CAAkB,CAAG,EAAE,MAAM,CAClC,IAAI,CAAC,CAAA,CAAuB,CAAG,EAAE,MAAM,CAAC,KAAK,CAC7C,IAAI,CAAC,CAAA,CAAiB,CAAG,OAAO,UAAU,CAAC,KACzC,IAAI,CAAC,CAAA,CAAmB,CAAG,CAAA,CAC7B,EA3K4B,KA4K5B,IAAI,CAAC,CAAA,CAAkB,CAAG,IAAI,CAAC,CAAA,EAAW,CAAC,IAAI,CAAC,IAAI,EACpD,SAAS,IAAI,CAAC,gBAAgB,CAAC,WAAY,IAAI,CAAC,CAAA,CAAkB,EAClE,IAAI,CAAC,CAAA,CAAqB,CAAG,IAAI,CAAC,CAAA,EAAc,CAAC,IAAI,CAAC,IAAI,EAC1D,GAAS,aAAa,CAAC,gBAAgB,CACrC,SACA,IAAI,CAAC,CAAA,CAAqB,EAGhC,CAEA,CAAA,EAAW,GACT,SAAS,IAAI,CAAC,mBAAmB,CAAC,WAAY,IAAI,CAAC,CAAA,CAAkB,EACrE,GAAS,aAAa,CAAC,mBAAmB,CACxC,SACA,IAAI,CAAC,CAAA,CAAqB,EAGxB,IAAI,CAAC,CAAA,CAAU,GACjB,IAAI,CAAC,CAAA,CAAU,CAAG,CAAA,EACd,IAAI,CAAC,CAAA,CAAkB,EACzB,CAAA,IAAI,CAAC,CAAA,CAAkB,CAAC,KAAK,CAAG,IAAI,CAAC,CAAA,CAAuB,AAAvB,GAIzC,IAAI,CAAC,CAAA,CAAkB,CAAG,IAAI,CAAC,CAAA,CAAuB,CAAG,IAC3D,CAEA,CAAA,EAAc,GACZ,IAAI,CAAC,CAAA,CAAU,CAAG,CAAA,CACpB,CAEA,CAAA,EAAQ,CAAC,CAAa,QAIpB,CAHA,aAAa,GACb,aAAa,IAAI,CAAC,CAAA,CAA0B,EAExC,IAAI,CAAC,CAAA,CAAmB,EAAI,GAAa,EAAE,MAAM,IACnD,EAAE,cAAc,GAChB,IAAI,CAAC,CAAA,CAA0B,CAAG,OAAO,UAAU,CAAC,KAClD,IAAI,CAAC,CAAA,EAAQ,CAAC,EAChB,EAnN4B,KAoNrB,CAAA,GAEL,IAAI,CAAC,CAAA,CAAU,EACjB,EAAE,cAAc,GACT,CAAA,OAIP,CAAA,CAAA,EAAE,MAAM,YAAY,kBACpB,GAAa,EAAE,MAAM,GACrB,EAAE,MAAM,YAAY,iBAAA,GAEpB,IAAI,CAAC,WAAW,CAAC,CACf,aAAc,EAAE,MAAM,CACtB,cAAe,EACf,YAAa,CAAA,CACf,EANoB,CAQxB,CAEA,0BAA0B,CAAyB,CAAE,CACnD,GAAM,CAAA,OAAE,CAAM,CAAA,oBAAE,CAAmB,CAAA,MAAE,CAAK,CAAE,CAAG,IAAI,CAAC,eAAe,CACjE,EACD,CACG,GAIF,CAAA,EAAoB,SAAS,CAAG,OAHT,EAAO,YAAY,CACtC,EAAO,YAAY,CAAC,IAAI,CAAC,MAAM,EAC/B,EAAM,KAAK,CACf,CAEJ,CAEA,YAAY,CAAA,aACV,CAAY,CAAA,cACZ,CAAa,CAAA,YACb,EAAc,CAAA,CAAA,CAKf,CAAE,CACD,IAAM,EAAa,AAmRvB,SAAuB,CAAyB,EAC9C,GAAI,GAAa,GACf,OAAO,OAAO,EAAa,KAAK,EAGlC,GAAI,aAAwB,iBAG1B,OAFa,EAAa,IAAI,EAG5B,IAAK,QAML,IAAK,SALH,OAAO,WAAW,EAAa,KAAK,CACtC,KAAK,MAML,QALE,OAAO,EAAa,KAAK,AAC3B,KAAK,WACH,OAAO,EAAa,OAAO,AAK/B,CACK,GAAI,aAAwB,kBACjC,OAAO,EAAa,KAAK,AAE7B,EA1SqC,GAC3B,EAAa,EAAa,EAAE,CAAC,OAAO,CAAC,WAAY,IAEvD,GAAI,IAAI,CAAC,MAAM,CAAC,EAAW,GAAK,EAC9B,OAGF,IAAM,EAAY,OAAO,MAAM,CAAC,CAC9B,QAAS,EACT,MAAO,EACP,cAAA,CACF,GAEA,IAAI,CAAC,aAAa,CAAC,QAAS,GAE5B,IAAM,EAAgB,KACpB,IAAI,CAAC,aAAa,CAAC,SAAU,GAC7B,IAAI,CAAC,wBAAwB,EAC/B,EAEA,IAAI,CAAC,wBAAwB,GAC7B,IAAI,CAAC,yBAAyB,CAAC,GAE3B,EACF,EAAe,OAAO,UAAU,CAAC,EAAe,KAEhD,GAEJ,CAEA,WAAgC,CAC9B,IAAM,EAAQ,aAAa,OAAO,CAAC,IACnC,GAAI,EACF,GAAI,CACF,OAAO,KAAK,KAAK,CAAC,EACpB,CAAE,MAAO,EAAG,CAEZ,CAGF,OAAO,IACT,CAEA,aAAa,CAAQ,CAAE,CACjB,EACF,aAAa,OAAO,CAAC,GAAyB,KAAK,SAAS,CAAC,IAE7D,aAAa,UAAU,CAAC,GAE5B,CAEA,yBAAyB,CAAwC,CAAE,CAC7D,AAAC,GACH,CAAA,EAAiB,IAAI,CAAC,cAAc,AAAd,EAExB,EAAe,OAAO,CAAC,AAAA,IACrB,GAAI,AAAiB,UAAjB,EAAQ,IAAI,CACd,IAAI,CAAC,wBAAwB,CAAC,EAAQ,QAAQ,OACzC,GAAI,EAAQ,IAAI,CAAE,CACvB,IAAM,EAAgB,OAAO,OAAO,CAAC,EAAQ,IAAI,EAAE,MAAM,CACvD,CAAC,CAAC,EAAG,EAAM,GAAK,aAAiB,UAEnC,GAAI,EAAc,MAAM,CAAE,CACxB,IAAM,EAAU,IAAI,CAAC,eAAe,CAAC,EAAQ,GAAG,CAAC,CAAC,KAAK,AACnD,CAAA,GACF,EAAc,OAAO,CAAC,CAAC,CAAC,EAAM,EAAiB,IAC7C,IAAM,EAAe,IAAI,CAAC,cAAc,CACtC,EACA,IAAI,CAAC,MAAM,EAET,GAAgB,EAAQ,YAAY,CAAC,KACvC,EAAQ,YAAY,CAAC,EAAM,OAAO,IAGhC,AAAU,QAAV,GAAmB,EAAQ,KAAK,CAAG,GAClC,AAAS,QAAT,GAAkB,EAAQ,KAAK,CAAG,GAEnC,EAAQ,KAAK,CAAG,OAAO,GACvB,aAAa,EAAQ,aAAa,EAClC,EAAQ,aAAa,CAAG,OAAO,UAAU,CAAC,KACxC,IAAI,CAAC,WAAW,CAAC,CAAE,aAAc,CAAQ,EAC3C,EAAG,MAEH,IAAI,CAAC,yBAAyB,CAAC,EAAQ,GAAG,EAGhD,EAEJ,CACF,CACF,EACF,CAEA,yBAAyB,CAAwC,CAAE,CAChE,AAAA,CAAA,GAAkB,IAAI,CAAC,cAAc,AAAd,EAAgB,OAAO,CAAC,AAAA,IAC9C,GAAI,EAAQ,IAAI,CAAE,CAChB,IAAM,EAAoB,EAAQ,IAAI,CAAC,IAAI,CAAC,MAAM,EAC5C,EAAY,IAAI,CAAC,eAAe,CAAC,EAAQ,GAAG,CAAC,CAAC,OAAO,CACvD,IACE,EACF,EAAU,eAAe,CAAC,UAE1B,EAAU,YAAY,CAAC,SAAU,UAGvC,CAEA,GAAI,EAAQ,UAAU,CAAE,CACtB,IAAM,EAAuB,EAAQ,UAAU,CAAC,IAAI,CAAC,MAAM,EACrD,EAAU,IAAI,CAAC,eAAe,CAAC,EAAQ,GAAG,CAAC,CAAC,KAAK,CACnD,IACE,EACF,EAAQ,YAAY,CAAC,WAAY,YAEjC,EAAQ,eAAe,CAAC,YAG9B,CAEI,EAAQ,QAAQ,EAClB,IAAI,CAAC,wBAAwB,CAAC,EAAQ,QAAQ,CAElD,EACF,CAEA,eACE,EAAuC,GAAS,QAAQ,CACxD,CAAyC,CACzC,CAAmB,CACnB,CACA,IAAM,EAAiB,GAAmB,IAAI,CAAC,cAAc,AAC7D,CAAA,EAAY,SAAS,CAAG,GACxB,IAAM,EAAmB,SAAS,sBAAsB,GACxD,EAAa,GAAc,EAE3B,EAAe,OAAO,CAAC,CAAC,EAAe,KACrC,IAEI,EACA,EACA,EAJE,EAAY,CAAC,OAAO,EAAE,OAAO,EAAc,GAAG,EAAA,CAAG,CAMvD,GAAI,AAAuB,UAAvB,EAAc,IAAI,CAAc,CAElC,AADA,CAAA,EAAY,SAAS,aAAa,CAAC,WAAnC,EACU,YAAY,CAAC,aAAc,OAAO,EAAc,GAAG,GAC7D,IAAM,EAAe,SAAS,aAAa,CAAC,UAC5C,EAAa,YAAY,CAAC,WAAY,KACtC,EAAa,SAAS,CAAG,EAAc,KAAK,CAC5C,EAAU,WAAW,CAAC,GACtB,EAAU,SAAS,CAAG,wBACa,cAA/B,EAAc,YAAY,GAC5B,EAAU,SAAS,CAAC,GAAG,CAAC,aACxB,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,OAAO,EAAc,GAAG,EAAE,CAAG,CAAA,GAEjD,IAAM,EAAoB,SAAS,aAAa,CAAC,OACjD,EAAU,WAAW,CAAC,GACtB,IAAI,CAAC,cAAc,CAAC,EAAmB,EAAc,QAAQ,CAC/D,KAAO,CAEL,AADA,CAAA,EAAY,SAAS,aAAa,CAAC,MAAnC,EACU,SAAS,CAAG,UAEtB,IAAM,EAAQ,SAAS,aAAa,CAAC,QACrC,CAAA,EAAM,SAAS,CAAG,EAAc,KAAK,CACrC,EAAM,YAAY,CAAC,MAAO,GAKtB,GAHJ,EAAU,SAAS,aAAa,CAC9B,AAsIV,SAAyC,CAAwB,EAC/D,OAAQ,GACN,IAAK,SACH,MAAO,QACT,KAAK,QACH,MAAO,wBACT,KAAK,MACH,MAAO,sBACT,SACE,MAAO,OACX,CACF,EAjJ0C,EAAc,IAAI,KAGlD,EAAQ,SAAS,CAAC,GAAG,CAAC,eAExB,EAAQ,YAAY,CAAC,WAAY,OAAO,IACxC,IAAM,EACJ,IAAI,CAAC,MAAM,CAAC,EAAc,GAAG,CAAC,EAC9B,IAAI,CAAC,cAAc,CAAC,EAAc,YAAY,CAAE,IAAI,CAAC,MAAM,EAE7D,GAAI,AAAuB,WAAvB,EAAc,IAAI,CAAe,CACnC,IAAM,EAAgB,SAAS,sBAAsB,GACrD,EAAc,OAAO,CAAC,OAAO,CAAC,AAAA,IAC5B,GAAM,CAAA,MAAE,CAAK,CAAA,MAAE,CAAK,CAAE,CACpB,AAAmB,UAAnB,OAAO,EACH,CAAE,MAAO,EAAS,MAAO,CAAQ,EACjC,EACA,EAAW,SAAS,aAAa,CAAC,UACxC,EAAS,YAAY,CAAC,QAAS,GAC/B,EAAS,SAAS,CAAG,EACrB,EAAc,WAAW,CAAC,EAC5B,GACA,EAAQ,WAAW,CAAC,GACnB,EAA8B,KAAK,CAAG,OAAO,GAC9C,EAAU,WAAW,CAAC,GACtB,EAAU,WAAW,CAAC,EACxB,KACM,AAAuB,UAAvB,EAAc,IAAI,EACpB,EAAQ,YAAY,CAAC,OAAQ,EAAc,IAAI,EAG7C,AAAuB,aAAvB,EAAc,IAAI,EACnB,EAA6B,OAAO,CAAG,CAAC,CAAC,EAC1C,EAAU,WAAW,CAAC,GACtB,EAAU,WAAW,CAAC,KAEtB,EAAU,WAAW,CAAC,GACtB,EAAU,WAAW,CAAC,GACtB,WAAW,KACT,EAAQ,KAAK,CAAG,OAAO,EACzB,GAEA,AADA,CAAA,EAAsB,SAAS,aAAa,CAAC,OAA7C,EACoB,EAAE,CAAG,CAAC,OAAO,EAAE,OACjC,EAAc,GAAG,EACjB,MAAM,CAAC,CACT,EAAoB,SAAS,CAAG,OAC9B,EAAc,YAAY,CACtB,EAAc,YAAY,CAAC,IAAI,CAAC,MAAM,EACtC,GAEN,EAAoB,SAAS,CAAG,sBAChC,EAAU,WAAW,CAAC,GAItB,CAAA,EAAc,IAAI,EACpB,OAAO,OAAO,CAAC,EAAc,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC,EAAM,EAAM,IACvD,IAAM,EAAY,IAAI,CAAC,cAAc,CAAC,EAAO,IAAI,CAAC,MAAM,EACxD,EAAQ,YAAY,CAAC,EAAM,OAAO,GACpC,GAGF,EAAQ,EAAE,CAAG,CACf,CAEA,IAAI,CAAC,eAAe,CAAC,EAAc,GAAG,CAAC,CAAG,CACxC,OAAQ,EACR,oBAAA,EACA,MAAO,EACP,QAAS,CACX,EACA,EAAU,EAAE,CAAG,CAAC,QAAQ,EAAE,OAAO,EAAc,GAAG,EAAA,CAAG,CACrD,EAAiB,WAAW,CAAC,EAC/B,GAEA,EAAY,WAAW,CAAC,GACxB,IAAI,CAAC,iBAAiB,GACtB,sBAAsB,IAAM,IAAI,CAAC,wBAAwB,GAC3D,CAEA,mBAAoB,CAElB,AADe,GAAS,WAAW,CAAC,gBAAgB,CAAC,gBAC9C,OAAO,CAAC,AAAA,IACb,GAAI,aAAmB,oBAAqB,CAC1C,IAAM,EAAU,EAAQ,OAAO,CAAC,KAAK,CAC/B,EAAa,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAAQ,AACnB,CAAA,WAAtB,OAAO,IACL,EACF,EAAQ,SAAS,CAAC,MAAM,CAAC,aAEzB,EAAQ,SAAS,CAAC,GAAG,CAAC,aAG5B,CACF,EACF,CAEA,eACE,CAAyC,CACzC,CAAuB,CACP,QAChB,AAAI,aAAqB,SAChB,EAAU,GAGZ,CACT,CACF,CAwCA,SAAS,GACP,CAAoB,EAEpB,OACE,aAAmB,GACnB,aAAmB,CAEvB,CG/kBA,MAAM,GAAe,SAAS,aAAa,CAAC,kBAEtC,GAAW,CACf,WAAY,GAAa,aAAa,CAAC,gBACvC,WAAY,GAAa,aAAa,CAAC,gBACvC,MAAO,GAAa,aAAa,CAAC,sBAClC,OAAQ,GAAa,aAAa,CAAC,uBACnC,kBAAmB,GAAa,aAAa,CAAC,2BAChD,EAEA,SAAS,GAAW,CAAE,CAAE,EAAM,GAAG,EAC/B,OAAO,KAAK,KAAK,CAAC,EAAM,KAAQ,EAClC,CAEA,MAAM,GAAc,CAClB,KAAK,KAAK,CAAC,OAAO,MAAM,CAAC,KAAK,EAC9B,KAAK,KAAK,CAAC,OAAO,MAAM,CAAC,MAAM,EAChC,CAEK,GAAQ,CACZ,CAAE,GAAI,MAAO,KAAM,eAAgB,EACnC,CACE,GAAI,KACJ,MAAO,CAAC,GAAI,GAAG,CAAC,GAAG,CAAC,AAAA,GAAK,GAAW,IACpC,kBAAmB,CAAA,CACrB,EACA,CACE,GAAI,KACJ,MAAO,CAAC,GAAI,GAAG,CAAC,GAAG,CAAC,AAAA,GAAK,GAAW,IACpC,kBAAmB,CAAA,CACrB,EACA,CACE,GAAI,SACJ,KAAM,CAAC,aAAa,EAAE,GAAY,IAAI,CAAC,KAAK,CAAC,CAAC,CAC9C,MAAO,EACT,EACA,CAAE,GAAI,SAAU,KAAM,WAAY,EACnC,AAEc,OAAA,GACb,QAAU,SAAS,aAAa,CAAC,iBAAkB,AAEnD,aAAY,CAAA,eAAE,CAAc,CAAE,CAAE,CAC9B,IAAM,EAAsB,SAAS,sBAAsB,GAC3D,GAAM,OAAO,CAAC,AAAA,IACZ,IAAM,EAAe,SAAS,aAAa,CAAC,UAC5C,EAAa,YAAY,CAAC,QAAS,EAAK,EAAE,EAC1C,EAAa,SAAS,CAAG,EAAK,IAAI,EAAI,EAAK,EAAE,CAC7C,EAAoB,WAAW,CAAC,EAClC,GACA,GAAS,UAAU,CAAC,WAAW,CAAC,GAChC,IAAI,CAAC,YAAY,CAAG,EAAK,CAAC,EAAE,CAE5B,GAAS,UAAU,CAAC,gBAAgB,CAAC,SAAU,AAAA,IAC7C,IAAM,EAAiB,EAAE,MAAM,CAAC,KAAK,CAC/B,EAAO,GAAM,IAAI,CAAC,CAAC,CAAA,GAAE,CAAE,CAAE,GAAK,IAAO,GAG3C,GAFA,IAAI,CAAC,YAAY,CAAG,EAEhB,AAAY,WAAZ,EAAK,EAAE,CAAe,CACxB,GAAS,UAAU,CAAC,eAAe,CAAC,UACpC,GAAM,CAAC,EAAO,EAAO,CAAG,GACxB,CAAA,GAAS,KAAK,CAAC,KAAK,CAAG,EACvB,GAAS,MAAM,CAAC,KAAK,CAAG,CAC1B,MACE,GAAS,UAAU,CAAC,YAAY,CAAC,SAAU,UAC3C,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,QAAQ,GAGhC,CAAA,EAAK,iBAAiB,CACxB,GAAS,iBAAiB,CAAC,eAAe,CAAC,UAE3C,GAAS,iBAAiB,CAAC,YAAY,CAAC,SAAU,SAEtD,GAEA,GAAS,iBAAiB,CAAC,gBAAgB,CAAC,SAAU,AAAA,IACpD,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,QAAQ,GACpC,GAEA,GAAS,UAAU,CAAC,gBAAgB,CAAC,UAAW,AAAA,IAC9C,EAAE,MAAM,CAAC,MAAM,EACjB,GAEA,GAAS,UAAU,CAAC,gBAAgB,CAAC,QAAS,KAC5C,IAAI,CAAC,eAAe,CAAC,CACnB,GAAS,KAAK,CAAC,KAAK,CAAG,SAAS,GAAS,KAAK,CAAC,KAAK,EAAI,KACxD,GAAS,MAAM,CAAC,KAAK,CAAG,SAAS,GAAS,MAAM,CAAC,KAAK,EAAI,KAC3D,CACH,EACF,CAEA,gBAAgB,CAAC,EAAO,EAAO,CAAG,EAAE,CAAE,CACpC,IAAI,CAAC,OAAO,CAAC,aAAa,CACxB,IAAI,YAA+B,aAAc,CAC/C,OAAQ,GAAS,EAAS,CAAC,EAAO,EAAO,CAAG,IAC9C,GAEJ,CAEA,UAAW,CACT,GAAI,AAAyB,WAAzB,IAAI,CAAC,YAAY,CAAC,EAAE,CACtB,MAAO,CACL,SAAS,GAAS,KAAK,CAAC,KAAK,CAAE,IAC/B,SAAS,GAAS,MAAM,CAAC,KAAK,CAAE,IACjC,AACI,EACL,IAAI,EAAQ,IAAI,CAAC,YAAY,CAAC,KAAK,CAOnC,OALE,IAAI,CAAC,YAAY,CAAC,iBAAiB,EACnC,AAAqC,eAArC,GAAS,iBAAiB,CAAC,KAAK,EAEhC,CAAA,EAAQ,MAAM,IAAI,CAAC,GAAO,OAAO,EAJnC,EAMO,CACT,CACF,CACF,CGlHe,MAAA,GACb,aAA2B,AAC3B,CAAA,KAAmB,AACnB,CAAA,IAAiB,AAEjB,aAAY,CAA0B,CAAE,CACtC,IAAI,CAAC,aAAa,CAAG,CACvB,CAEA,SAAU,CACR,IAAI,CAAC,OAAO,CAAC,MAAM,EACrB,CAEA,IAAI,SAAmB,CACrB,MAAM,AAAI,MAAM,kCAClB,CAEA,SAAS,CAAiB,CAAE,CAC1B,IAAI,CAAC,KAAK,CAAG,CACf,CAeA,cAAc,CAAiB,CAAE,CAAC,CAElC,SAAsB,CACpB,GAAM,CAAA,MAAE,CAAK,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAAC,aAAa,CAAC,qBAAqB,GAClE,MAAO,CAAC,EAAO,EAAO,AACxB,CAEA,QAAQ,CAAuB,CAAE,CAC/B,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,SAC7B,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,UAEzB,IAAI,CAAC,OAAO,YAAY,cACtB,GACF,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAG,CAAA,EAAG,CAAI,CAAC,EAAE,CAAC,EAAE,CAAC,CACzC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,CAAG,CAAA,EAAG,CAAI,CAAC,EAAE,CAAC,EAAE,CAAC,EAE1C,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,SAGnC,CACF,CDpDe,MAAA,WAA6B,GAC1C,MAA0B,AAC1B,CAAA,GAA8B,AAC9B,CAAA,UAAmB,AAEnB,aAAY,CAA0B,CAAE,CACtC,KAAK,CAAC,GAEN,IAAI,CAAC,MAAM,CAAG,SAAS,aAAa,CAAC,UACrC,IAAI,CAAC,GAAG,CAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,MAElC,IAAM,EAAM,OAAO,gBAAgB,EAAI,CACvC,CAAA,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,GAAG,CAAC,wBAAwB,CAAG,cAEpC,EAAc,WAAW,CAAC,IAAI,CAAC,MAAM,CACvC,CAEA,IAAI,SAAU,CACZ,OAAO,IAAI,CAAC,MAAM,AACpB,CAKA,OAAQ,CACN,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,EAAG,KAAM,IAAI,CAAC,OAAO,IACxC,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,SAC5B,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,UAE5B,GAAM,CAAC,EAAO,EAAO,CAAG,IAAI,CAAC,OAAO,GACpC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,QAAS,OAAO,IACzC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,SAAU,OAAO,GAC5C,CAEA,SAAS,CAAiB,CAAE,CAC1B,IAAI,CAAC,GAAG,CAAC,WAAW,CAAG,CACzB,CAEA,aAAa,CAAa,CAAE,CAC1B,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,CACvB,CAEA,cAAc,CAAiB,CAAE,CAC/B,IAAI,CAAC,GAAG,CAAC,wBAAwB,CAAG,mBACpC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,EACrB,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAG,KAAM,IAAI,CAAC,OAAO,IACvC,IAAI,CAAC,GAAG,CAAC,wBAAwB,CAAG,aACtC,CAEA,SAAsB,CACpB,MAAO,CACL,IAAI,CAAC,MAAM,CAAC,WAAW,CAAG,IAAI,CAAC,UAAU,CACzC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAG,IAAI,CAAC,UAAU,CAC3C,AACH,CAEA,YAAY,CAA0B,CAAE,GAAG,CAA6B,CAAE,CAIxE,IAAK,IAAM,KAHX,IAAI,CAAC,GAAG,CAAC,SAAS,GAClB,IAAI,CAAC,GAAG,CAAC,MAAM,IAAI,GAEI,GACrB,IAAI,CAAC,GAAG,CAAC,MAAM,IAAI,GAGrB,IAAI,CAAC,GAAG,CAAC,MAAM,EACjB,CAEA,YACE,CAA0B,CAC1B,CAAA,MACE,CAAK,CAAA,SACL,CAAQ,CAAA,OACR,CAAM,CAAA,cACN,CAAa,CAAA,OACb,EAAS,CAAA,CAOV,CACD,CACA,IAAM,EAAU,IAAI,CAAC,MAAM,CAAC,KAAK,CAAG,CAEpC,CAAA,IAAI,CAAC,GAAG,CAAC,wBAAwB,CAAG,cACpC,IAAI,CAAC,GAAG,CAAC,SAAS,GAClB,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,EACrB,IAAI,CAAC,GAAG,CAAC,YAAY,CAAG,SACxB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAG,CAAA,EAAG,EAAS,aAAa,CAAC,CAC1C,IAAM,EAAmB,EAAS,EAElC,EAAM,OAAO,CAAC,CAAC,CAAE,MAAO,CAAC,EAAG,EAAE,CAAA,OAAE,CAAM,CAAE,IAGtC,GAFA,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAI,EAAQ,GAC5B,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAG,EAAG,EAAQ,EAAG,GAC1B,GAAiB,AAAU,MAAV,EAAgB,CACnC,IAAM,EAAe,EAAI,EAEnB,EAA8B,CAClC,EAAe,EAAI,EAAmB,EAAI,EAC1C,EACD,AAED,CAAA,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,EAAe,QAAU,OAC9C,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,OAAO,MAAY,EACvC,CACF,GAEA,IAAI,CAAC,GAAG,CAAC,IAAI,EACf,CAEA,OAAQ,CACN,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,EAAG,EAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAE,IAAI,CAAC,MAAM,CAAC,MAAM,CAChE,CAEA,WAAoB,CAClB,OAAO,IAAI,CAAC,MAAM,CAAC,SAAS,EAC9B,CACF,CG7He,MAAA,GACb,CAAA,EAAc,CAEV,CAAC,CAAS,AAEd,CAAA,iBACE,CAAQ,CACR,CAAsC,CACtC,CACA,IAAM,EAAY,IAAI,CAAC,CAAA,EAAc,CAAC,EAAM,GAAK,EAAE,AAC/C,CAAC,EAAS,QAAQ,CAAC,IACrB,EAAS,IAAI,CAAC,EAElB,CAEA,oBACE,CAAQ,CACR,CAAsC,CACtC,CACA,IAAM,EAAW,IAAI,CAAC,CAAA,EAAc,CAAC,EAAM,CAC3C,GAAI,CAAC,EAAU,OAEf,IAAM,EAAQ,EAAS,OAAO,CAAC,EAC3B,AAAU,CAAA,KAAV,GACF,EAAS,MAAM,CAAC,EAAO,EAE3B,CAEU,KAA8B,CAAQ,CAAE,CAAmB,CAAE,CACrE,IAAI,CAAC,CAAA,EAAc,CAAC,EAAM,EAAE,QAAQ,AAAA,GAAW,EAAQ,GACzD,CACF,CChBA,MAAM,GAAiB,gBAChB,SAAS,GAAO,CAAA,MAAE,CAAK,CAAE,GAAG,EAAwB,EACzD,IAAI,EAAsB,SAAS,aAAa,CAAC,CAAC,CAAC,EAAE,GAAA,CAAgB,EAerE,OAdK,IAEH,AADA,CAAA,EAAS,SAAS,aAAa,CAAC,eAAhC,EACO,EAAE,CAAG,GACZ,SAAS,IAAI,CAAC,WAAW,CAAC,IAG5B,CAAC,QAAS,cAAe,SAAU,SAAU,OAAO,CAAC,OAAO,CAAC,AAAA,IACvD,AAAiB,MAAjB,CAAO,CAAC,EAAK,EAAY,AAAkB,KAAlB,CAAO,CAAC,EAAK,CACxC,EAAO,YAAY,CAAC,EAAM,CAAO,CAAC,EAAK,EAEvC,EAAO,eAAe,CAAC,EAE3B,GAEO,EAAO,IAAI,CAAC,EACrB,CAEA,MAAM,GAAoB,iBAEnB,SAAS,GAAQ,CAAuB,EAC7C,IAAI,EAAwB,SAAS,aAAa,CAAC,CAAC,CAAC,EAAE,GAAA,CAAmB,EAe1E,OAdK,IAEH,AADA,CAAA,EAAS,SAAS,aAAa,CAAC,iBAAhC,EACO,EAAE,CAAG,GACZ,SAAS,IAAI,CAAC,WAAW,CAAC,IAG5B,CAAC,QAAS,cAAe,SAAU,SAAU,OAAO,CAAC,OAAO,CAAC,AAAA,IACvD,AAAiB,MAAjB,CAAO,CAAC,EAAK,EAAY,AAAkB,KAAlB,CAAO,CAAC,EAAK,CACxC,EAAO,YAAY,CAAC,EAAM,CAAO,CAAC,EAAK,EAEvC,EAAO,eAAe,CAAC,EAE3B,GAEO,EAAO,IAAI,EACpB,CF/CA,MAAM,GAAuB,qBAEd,OAAA,WAA0B,GAKvC,QAEE,AAEF,CAAA,cAA+B,AAE/B,cAAc,CACZ,KAAK,GAEL,IAAI,CAAC,QAAQ,CAAG,CACd,WAAY,SAAS,aAAa,CAAC,eACrC,EAEA,SAAS,aAAa,CAAC,iBAAiB,gBAAgB,CAAC,SAAU,AAAA,IAEjE,OAAQ,EAAE,MAAM,CAAC,KAAK,EACpB,IAAK,UACH,IAAI,CAAC,CAAA,EAAiB,GACtB,KACF,KAAK,SACH,IAAI,CAAC,aAAa,GAClB,KACF,KAAK,OACH,IAAI,CAAC,kBAAkB,GACvB,KACF,KAAK,SACH,IAAI,CAAC,oBAAoB,EAE7B,CACF,GAEA,SAAS,aAAa,CAAC,aAAa,gBAAgB,CAAC,QAAS,KACxD,IAAI,CAAC,cAAc,CAAC,UAAU,CAChC,IAAI,CAAC,CAAA,EAAiB,GAEtB,IAAI,CAAC,kBAAkB,EAE3B,EACF,CAEA,CAAA,EAAiB,GACf,IAAM,EAAS,IAAI,CAAC,CAAA,EAAmB,GACjC,EAAc,CAAC,SAAS,EAAE,EAAA,CAAQ,CAExC,AAAA,GAAO,CACL,MAAO,eACP,YAAa,qBACb,OAAQ,OACR,MAAO,CACT,GAAG,IAAI,CACL,AAAA,IACE,IAAI,CAAC,cAAc,CAAC,CAClB,KAAM,IAAI,CAAC,cAAc,CAAC,IAAI,CAC9B,OAAQ,IAAI,CAAC,cAAc,CAAC,MAAM,CAClC,KACE,AAAe,MAAf,GAAuB,AAAgB,KAAhB,EACnB,EACA,CACR,EACF,EACA,KAAO,EAEX,CAEA,WAAW,CAAuB,CAAE,CAClC,IAAI,CAAC,cAAc,CAAG,CACxB,CAEA,OAAO,uBAAuB,CAC5B,KAAM,CAAW,CACjB,GAAG,EACS,CAAkB,CAC9B,IAAM,EAAU,AnCpDL,EmCoDkB,IAAI,CAAC,CAAC,CAAA,KAAE,CAAI,CAAE,GAAK,IAAS,GACzD,GAAI,AAAW,MAAX,EACF,MAAM,AAAI,MAAM,CAAC,oBAAoB,EAAE,EAAY,QAAQ,CAAC,EAG9D,IAAM,EAAU,IAAI,EAGpB,OAFA,OAAO,MAAM,CAAC,EAAS,GAEhB,CACT,CAEA,OAAO,kBAAqC,CAC1C,GAAM,CAAA,SAAE,CAAQ,CAAE,CAAG,IAAI,CAAC,WAAW,GACrC,OAAO,EAAS,GAAG,CAAC,IAAI,CAAC,sBAAsB,CACjD,CAEA,OAAO,eAAe,CAAiB,CAAyB,CAC9D,IAAM,EAAc,IAAI,CAAC,mBAAmB,CAAC,GAC7C,OAAO,EAAc,IAAI,CAAC,sBAAsB,CAAC,GAAe,IAClE,CAEA,OAAO,oBAAoB,CAAiB,CAAsB,CAChE,GAAM,CAAA,SAAE,CAAQ,CAAE,CAAG,IAAI,CAAC,WAAW,GACrC,OAAO,EAAS,IAAI,CAAC,CAAC,CAAA,GAAE,CAAE,CAAE,GAAK,IAAO,EAC1C,CAEA,CAAA,EAAmB,GACjB,IAAM,EAAU,GAAY,WAAW,GACjC,EAAS,GAAS,UAAU,OAC9B,OAAO,EAAQ,QAAQ,CAAC,EAAQ,QAAQ,CAAC,MAAM,CAAG,EAAE,CAAC,EAAE,EACvD,EAEJ,OAAO,OADQ,MAAM,GAAU,EAAI,EAAS,EAE9C,CAEA,eAAe,CAAoC,CAAe,CAChE,IAAM,EAAU,GAAY,WAAW,GACjC,EAAS,IAAI,CAAC,CAAA,EAAmB,GAEjC,EAA8B,CAClC,GAAG,CAAW,CACd,GAAI,CACN,EASA,OAPA,EAAQ,QAAQ,CAAC,IAAI,CAAC,GACtB,IAAI,CAAC,WAAW,CAAC,GAEjB,IAAI,CAAC,IAAI,CAAC,aAAc,CACtB,QAAS,GAAY,sBAAsB,CAAC,EAC9C,GAEO,CACT,CAEA,YAAY,CAAwB,CAAE,CACpC,IAAM,EAAU,GAAY,WAAW,GAEjC,EAAe,EAAQ,QAAQ,CAAC,SAAS,CAC7C,CAAC,CAAA,GAAE,CAAE,CAAE,GAAK,IAAO,IAAI,CAAC,cAAc,CAAC,EAAE,CAEtB,CAAA,KAAjB,IACF,EAAQ,QAAQ,CAAC,EAAa,CAAG,EACjC,IAAI,CAAC,WAAW,CAAC,GAEjB,IAAI,CAAC,IAAI,CAAC,OAAQ,CAChB,QAAS,GAAY,sBAAsB,CAAC,EAC9C,GAEJ,CAEA,oBAAqB,CACnB,IAAM,EAA8B,CAClC,GAAI,IAAI,CAAC,cAAc,CAAC,EAAE,CAC1B,KAAM,IAAI,CAAC,cAAc,CAAC,IAAI,CAC9B,KAAM,IAAI,CAAC,cAAc,CAAC,IAAI,CAC9B,OAAQ,IAAI,CAAC,cAAc,CAAC,MAAM,AACpC,EAGA,OADA,IAAI,CAAC,WAAW,CAAC,GACV,CACT,CAEA,sBAAuB,CACrB,AAAA,GAAO,CACL,MAAO,SACP,YAAa,qBACb,OAAQ,OACR,MAAO,IAAI,CAAC,cAAc,CAAC,IAAI,AACjC,GAAG,IAAI,CAAC,AAAA,IACN,GAAI,IAAmB,IAAI,CAAC,cAAc,CAAC,IAAI,CAAE,CAC/C,IAAM,EAAc,GAAY,mBAAmB,CACjD,IAAI,CAAC,cAAc,CAAC,EAAE,CAExB,CAAA,EAAY,IAAI,CAAG,EACnB,IAAI,CAAC,WAAW,CAAC,EACnB,CAEA,IAAI,CAAC,cAAc,CAAC,IAAI,CAAG,CAC7B,EACF,CAEA,eAAgB,CACd,AAAA,GAAQ,CACN,MAAO,iBACP,YAAa,gDACb,OAAQ,SACR,KAAM,OACR,GAAG,IAAI,CACL,KACE,IAAM,EAAU,GAAY,WAAW,GACjC,EAAe,EAAQ,QAAQ,CAAC,SAAS,CAC7C,CAAC,CAAA,GAAE,CAAE,CAAE,GAAK,IAAO,IAAI,CAAC,cAAc,CAAC,EAAE,EAE3C,GAAI,AAAiB,KAAjB,EACF,MAAM,AAAI,MACR,CAAC,8BAA8B,EAAE,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC,kBAAkB,CAAC,EAI/E,IAAM,EAAU,EAAQ,QAAQ,CAAC,MAAM,CAAC,EAAc,EAAE,CAAC,EAAE,CAC3D,IAAI,CAAC,WAAW,CAAC,GAEjB,IAAI,CAAC,IAAI,CAAC,gBAAiB,CACzB,QAAS,GAAY,sBAAsB,CAAC,EAC9C,EACF,EACA,KAAO,EAEX,CAEA,OAAO,aAAuB,CAC5B,IAAM,EAAU,aAAa,OAAO,CAAC,IACrC,GAAI,CACF,OAAO,EAAU,KAAK,KAAK,CAAC,GAAW,CAAE,SAAU,EAAE,AAAC,CACxD,CAAE,MAAO,EAAO,CACd,MAAM,AAAI,MACR,6CAA+C,EAAM,OAAO,CAEhE,CACF,CAEA,YAAY,CAAgB,CAAQ,CAClC,aAAa,OAAO,CAAC,GAAsB,KAAK,SAAS,CAAC,GAC5D,CACF,CH/NA,MAAM,GAAkB,WAEjB,OAAM,WAAmB,GAC9B,SAAwC,CACtC,KAAM,SAAS,aAAa,CAAC,yBAC7B,WAAY,SAAS,aAAa,CAAC,eACnC,UAAW,SAAS,aAAa,CAAC,uBAClC,SAAU,SAAS,aAAa,CAAC,4BACjC,YAAa,SAAS,aAAa,CAAC,gBACtC,CAAE,AAEF,CAAA,OAAwB,AACxB,CAAA,mBAAqB,CAAA,CAAM,AAC3B,CAAA,eAAyC,AAEzC,aAAY,CAAwB,CAAE,CACpC,KAAK,GAEL,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,gBAAgB,CAAC,QAAS,IAAM,IAAI,CAAC,MAAM,IAEnE,EAAY,gBAAgB,CAAC,aAAc,CAAC,CAAA,QAAE,CAAO,CAAE,IACjD,IAAI,CAAC,MAAM,CACf,IAAI,CAAC,gBAAgB,GAEnB,IAAI,CAAC,kBAAkB,CAAG,CAAA,EAG5B,IAAI,CAAC,iBAAiB,CAAC,GACvB,IAAI,CAAC,IAAI,CAAC,SAAU,CAAE,UAAW,EAAQ,EAAE,AAAC,EAC9C,GAEA,EAAY,gBAAgB,CAAC,OAAQ,CAAC,CAAA,QAAE,CAAO,CAAE,IAC3C,IAAI,CAAC,MAAM,CACf,IAAI,CAAC,gBAAgB,GAEnB,IAAI,CAAC,kBAAkB,CAAG,CAAA,EAG5B,IAAI,CAAC,iBAAiB,CAAC,EACzB,GAEA,EAAY,gBAAgB,CAAC,gBAAiB,CAAC,CAAA,QAAC,CAAO,CAAC,IAClD,IAAI,CAAC,MAAM,CAEb,AADkB,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC,eAAe,EAAE,EAAQ,EAAE,CAAC,EAAE,CAAC,EAC/E,MAAM,GAEhB,IAAI,CAAC,kBAAkB,CAAG,CAAA,CAE9B,GAEA,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,gBAAgB,CAAC,QAAS,AAAA,IACjD,EAAE,cAAc,GAChB,EAAE,eAAe,GAEjB,IAAM,EACJ,EAAE,MAAM,YAAY,aACnB,EAAE,MAAM,CAAC,OAAO,CAAC,kBAEpB,GAAI,CAAC,EACH,MAAO,CAAA,EAGT,IAAI,CAAC,IAAI,CAAC,SAAU,CAAE,UAAW,EAAK,OAAO,CAAC,OAAO,AAAC,GAEtD,IAAI,CAAC,MAAM,EACb,EACF,CAEA,IAAI,QAAkB,CACpB,MAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAChD,CAEA,QAAS,CACF,IAAI,CAAC,MAAM,CAEL,IAAI,CAAC,OAAO,EACrB,IAAI,CAAC,KAAK,GAFV,IAAI,CAAC,IAAI,EAIb,CAEA,MAAO,CACA,IAAI,CAAC,MAAM,GACd,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAC/B,IAAI,CAAC,kBAAkB,GAC1B,IAAI,CAAC,gBAAgB,GACrB,IAAI,CAAC,kBAAkB,CAAG,CAAA,GAG5B,IAAI,CAAC,eAAe,CAAG,AAAA,IAEnB,EAAE,MAAM,YAAY,aACpB,CAAC,EAAE,MAAM,CAAC,OAAO,CAAC,0BAElB,IAAI,CAAC,MAAM,EAEf,EAEA,SAAS,IAAI,CAAC,gBAAgB,CAAC,YAAa,IAAI,CAAC,eAAe,EAEpE,CAEA,OAAQ,CACF,IAAI,CAAC,MAAM,GACb,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IACjC,SAAS,IAAI,CAAC,mBAAmB,CAAC,YAAa,IAAI,CAAC,eAAe,EACnE,IAAI,CAAC,eAAe,CAAG,KAE3B,CAEA,kBAAkB,CAAuB,CAAE,CACzC,IAAI,CAAC,OAAO,CAAG,EACf,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,SAAS,CAAG,GAAS,MAAQ,kBACzD,CAEA,CAAA,EAAwB,CAAC,CAAa,CAAE,CAA0B,EAChE,IAAM,EAAU,SAAS,aAAa,CAAC,WAEjC,EAAe,SAAS,aAAa,CAAC,KAC5C,CAAA,EAAa,SAAS,CAAG,kCACzB,EAAa,SAAS,CAAG,EACzB,EAAQ,WAAW,CAAC,GAEpB,IAAM,EAAiB,SAAS,aAAa,CAAC,KAC9C,CAAA,EAAe,SAAS,CAAG,4BAC3B,EAAQ,WAAW,CAAC,GAEpB,IAAM,EAAqB,SAAS,sBAAsB,GAC1D,EAAS,OAAO,CAAC,AAAA,IACf,IAAM,EAAc,SAAS,aAAa,CAAC,IAE3C,CAAA,EAAY,KAAK,CAAC,KAAK,CAAG,EAAY,KAAK,CAAC,MAAM,CAnI7B,QAoIrB,EAAQ,QAAQ,CAAG,IAAI,GAAe,GAEtC,EAAQ,YAAY,CAAC,CACnB,OAAQ,EACR,iBAAkB,CAAA,EAClB,WAAY,GACZ,GAAG,EAAS,WAAW,CAA2B,eAAe,AACnE,GAEA,IAAM,EAAK,SAAS,aAAa,CAAC,MAClC,EAAmB,WAAW,CAAC,GAE/B,EAAY,IAAI,CAAG,CAAC,SAAS,EAAE,EAAQ,EAAE,CAAA,CAAE,CAC3C,EAAY,YAAY,CAAC,eAAgB,EAAQ,EAAE,EACnD,EAAY,KAAK,CAAG,EAAQ,IAAI,CAChC,EAAG,WAAW,CAAC,EACjB,GAEA,EAAe,WAAW,CAAC,GAE3B,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,WAAW,CAAC,GAErC,EAAS,OAAO,CAAC,AAAA,GAAW,EAAQ,IAAI,GAC1C,CAEA,kBAAmB,CACjB,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,SAAS,CAAG,GAGjC,AADkB,AAAA,GAAY,gBAAgB,GAChC,MAAM,EACtB,IAAI,CAAC,CAAA,EAAwB,CAAC,cAAe,AAAA,GAAY,gBAAgB,IAE3E,IAAM,EAAW,AhCxIN,EgCwImB,GAAG,CAAC,AAAA,GAAe,IAAI,GACrD,IAAI,CAAC,CAAA,EAAwB,CAAC,oBAAqB,EACrD,CACF,CMxIA,MAAM,GAAe,mBACf,GAAgB,gBC9Bf,eAAe,GAAM,CAAiB,EAC3C,GAAI,CACF,UAAU,KAAK,CAAC,MAAM,GAAa,GACrC,CAAE,MAAO,EAAO,CACd,MAAM,UAAY,EAAM,OAAO,CACjC,CACF,CAEO,eAAe,GAAiB,CAAiB,EACtD,GAAI,CAAC,UAAU,KAAK,CAClB,MAAO,CAAA,EAGT,IAAM,EAAY,MAAM,GAAa,GACrC,OAAO,UAAU,QAAQ,CAAC,EAC5B,CAEA,eAAe,GAAa,CAAA,SAAE,CAAQ,CAAA,QAAE,CAAO,CAAc,EAC3D,IAAM,EAAU,EAAS,SAAS,GAC5B,EAAO,MAAO,AAAA,CAAA,MAAM,MAAM,EAAA,EAAU,IAAI,GACxC,EAAQ,CACZ,IAAI,KAAK,CAAC,EAAK,CAAE,EAAQ,IAAI,CAAG,OAAQ,CACtC,KAAM,EAAK,IAAI,CACf,aAAc,IAAI,OAAO,OAAO,EAClC,GACD,CACD,MAAO,CACL,IAAK,OAAO,QAAQ,CAAC,IAAI,CACzB,MAAA,EACA,MAAO,SAAS,KAAK,CACrB,KAAM,uBAAyB,EAAQ,IAAI,AAC7C,CACF,CCtCO,eAAe,KACpB,GAAI,AAAC,UAAU,aAAa,EAAI,AAA+B,cAA/B,SAAS,QAAQ,CAAC,QAAQ,CAI1D,GAAI,CACF,IAAM,EAAe,MAAM,UAAU,aAAa,CAAC,QAAQ,CAR5C,oBASf,CAAA,EAAa,aAAa,CAAG,KAC3B,IAAM,EAAmB,EAAa,UAAU,AACxB,OAApB,GAGJ,CAAA,EAAiB,aAAa,CAAG,KACA,cAA3B,EAAiB,KAAK,GACpB,UAAU,aAAa,CAAC,UAAU,CACpC,QAAQ,GAAG,CACT,iHAIF,QAAQ,GAAG,CAAC,sCAGlB,CAAA,CACF,CACF,CAAE,MAAO,EAAO,CACd,QAAQ,KAAK,CAAC,4CAA6C,EAC7D,CACF,CCzBA,MAAM,GAAS,4BAEA,OAAA,WAA0B,GACvC,GAAgB,AAChB,CAAA,eAA6B,AAC7B,CAAA,WAA6B,IAAK,AAClC,CAAA,UAAwB,AACxB,CAAA,UAAwB,AACxB,CAAA,iBAA+B,AAC/B,CAAA,cAA4B,AAC5B,CAAA,aAAkC,IAAK,AACvC,CAAA,UAA6B,CAAE,AAC/B,CAAA,iBAAgC,IAAK,AAErC,aAAY,CAAa,CAAE,CACzB,KAAK,CAAC,GAEN,IAAI,CAAC,GAAG,CAAG,SAAS,eAAe,CAAC,GAAQ,OAC5C,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,WAAW,CAAC,UAAW,SACtC,IAAI,CAAC,eAAe,CAAG,SAAS,eAAe,CAAC,GAAQ,KACxD,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,UAAW,cAC7C,IAAI,CAAC,UAAU,CAAG,SAAS,eAAe,CAAC,GAAQ,KACnD,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,UAAW,SACxC,IAAI,CAAC,UAAU,CAAG,SAAS,eAAe,CAAC,GAAQ,KACnD,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,UAAW,SAExC,IAAI,CAAC,iBAAiB,CAAG,SAAS,eAAe,CAAC,GAAQ,KAC1D,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,UAAW,gBAE/C,IAAI,CAAC,cAAc,CAAG,SAAS,eAAe,CAAC,GAAQ,KACvD,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,UAAW,aAE5C,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,iBAAiB,EAClD,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,cAAc,EAE/C,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,eAAe,EACzC,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,EACpC,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,EAEpC,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,QAAS,IAE/B,EAAc,WAAW,CAAC,IAAI,CAAC,GAAG,CACpC,CAEA,IAAI,SAAU,CACZ,OAAO,IAAI,CAAC,GAAG,AACjB,CAEA,OAAQ,CACN,IAAI,CAAC,UAAU,CAAC,SAAS,CAAG,GAC5B,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAG,GACnC,IAAI,CAAC,cAAc,CAAC,SAAS,CAAG,GAEhC,GAAM,CAAC,EAAO,EAAO,CAAG,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC,KAAK,KAAK,EACrD,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,GAAQ,UAAW,CAAC,IAAI,EAAE,EAAM,CAAC,EAAE,EAAA,CAAQ,EACnE,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,GAAQ,QAAS,OAAO,IAChD,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,GAAQ,SAAU,OAAO,IACjD,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAG,EAAQ,KAC/B,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,CAAG,EAAS,KACjC,IAAI,CAAC,YAAY,CAAG,KACpB,IAAI,CAAC,SAAS,CAAG,IACnB,CAEA,SAAS,CAAiB,CAAE,CACtB,IAAU,IAAI,CAAC,YAAY,GAC7B,IAAI,CAAC,gBAAgB,CAAG,SAAS,eAAe,CAAC,GAAQ,KACzD,IAAI,CAAC,gBAAgB,CAAC,YAAY,CAAC,SAAU,GAC7C,IAAI,CAAC,gBAAgB,CAAC,YAAY,CAChC,eACA,OAAO,IAAI,CAAC,SAAS,GAEvB,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,gBAAgB,EACjD,IAAI,CAAC,YAAY,CAAG,EAExB,CAEA,aAAa,CAAK,CAAE,CAClB,IAAI,CAAC,SAAS,CAAG,GAAS,IAC1B,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,GAAQ,eAAgB,GAAS,KAChE,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,OAAO,CAAC,AAAA,IAC7B,aAAiB,aACnB,EAAM,cAAc,CAAC,GAAQ,eAAgB,GAAS,IAE1D,EACF,CAEA,cAAc,CAAiB,CAAE,CAC3B,GACG,IAAI,CAAC,UAAU,GAClB,IAAI,CAAC,UAAU,CAAG,SAAS,eAAe,CAAC,GAAQ,QACnD,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,QAAS,QACtC,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,SAAU,QACvC,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,GAGlD,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,OAAQ,KAErC,IAAI,CAAC,UAAU,CAAG,KAClB,IAAI,CAAC,eAAe,CAAC,SAAS,CAAG,GAErC,CAEA,SAAsB,CACpB,MAAO,CAAC,IAAI,CAAC,GAAG,CAAC,WAAW,CAAE,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,AACtD,CAEA,QAAQ,CAAuB,CAAE,CAG/B,GAFA,KAAK,CAAC,QAAQ,GAEV,EAAM,CACR,GAAM,CAAC,EAAO,EAAO,CAAG,EAAK,GAAG,CAAC,KAAK,KAAK,EAE3C,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,GAAQ,UAAW,CAAC,IAAI,EAAE,EAAM,CAAC,EAAE,EAAA,CAAQ,EACnE,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,GAAQ,QAAS,OAAO,IAChD,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,GAAQ,SAAU,OAAO,GACnD,CACF,CACA,YAAY,CAAa,CAAE,GAAG,CAAS,CAAE,CACvC,IAAI,EAAgB,EACd,EAAW,SAAS,sBAAsB,GAEhD,IAAK,IAAM,KAAY,EAAW,CAChC,IAAM,EAAO,SAAS,eAAe,CAAC,GAAQ,QAC9C,EAAK,YAAY,CAAC,KAAM,OAAO,KAAK,KAAK,CAAC,CAAa,CAAC,EAAE,IAC1D,EAAK,YAAY,CAAC,KAAM,OAAO,KAAK,KAAK,CAAC,CAAa,CAAC,EAAE,IAC1D,EAAK,YAAY,CAAC,KAAM,OAAO,KAAK,KAAK,CAAC,CAAQ,CAAC,EAAE,IACrD,EAAK,YAAY,CAAC,KAAM,OAAO,KAAK,KAAK,CAAC,CAAQ,CAAC,EAAE,IACrD,EAAgB,EAEhB,EAAS,WAAW,CAAC,EACvB,CAEA,IAAI,CAAC,gBAAgB,CAAC,WAAW,CAAC,EACpC,CAEA,YAAY,CAAK,CAAE,CAAA,MAAE,CAAK,CAAA,SAAE,CAAQ,CAAA,OAAE,CAAM,CAAA,cAAE,CAAa,CAAA,OAAE,EAAS,CAAA,CAAG,CAAE,CACzE,IAAM,EAAU,IAAI,CAAC,OAAO,EAAE,CAAC,EAAE,CAAG,CACpC,CAAA,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAG,IAAI,CAAC,cAAc,CAAC,SAAS,CAAG,GACnE,IAAM,EAAkB,SAAS,sBAAsB,GACjD,EAAe,SAAS,sBAAsB,GACpD,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,OAAQ,GACrC,IAAM,EAAmB,EAAS,CAElC,CAAA,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,QAAQ,CAAG,EACrC,EAAM,OAAO,CAAC,CAAC,CAAE,MAAO,CAAC,EAAG,EAAE,CAAA,OAAE,CAAM,CAAE,IACtC,IAAM,EAAS,SAAS,eAAe,CAAC,GAAQ,UAMhD,GALA,EAAO,YAAY,CAAC,KAAM,GAC1B,EAAO,YAAY,CAAC,KAAM,GAC1B,EAAO,YAAY,CAAC,IAAK,GACzB,EAAgB,WAAW,CAAC,GAExB,GAAiB,AAAU,MAAV,EAAgB,CACnC,IAAM,EAAe,EAAI,EAEnB,EAAiB,CACrB,EAAe,EAAI,EAAmB,EAAI,EAC1C,EACD,CAEK,EAAS,SAAS,eAAe,CAAC,GAAQ,OAChD,CAAA,EAAO,SAAS,CAAG,OAAO,GAC1B,EAAO,YAAY,CAAC,IAAK,CAAc,CAAC,EAAE,EAC1C,EAAO,YAAY,CAAC,IAAK,CAAc,CAAC,EAAE,EACtC,GACF,EAAO,YAAY,CAAC,cAAe,OAErC,EAAa,WAAW,CAAC,EAC3B,CACF,GAEA,IAAI,CAAC,iBAAiB,CAAC,WAAW,CAAC,GACnC,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,EAClC,CAEA,OAAQ,CACN,IAAI,CAAC,UAAU,CAAC,SAAS,CAAG,GAC5B,IAAI,CAAC,UAAU,CAAC,SAAS,CAAG,EAC9B,CAEA,WAAY,CACV,MAAO,EACT,CACF,CE3LO,SAAS,GAAa,CAAO,CAAE,CAAQ,EAC5C,IAAM,EAAe,SAAS,aAAa,CAAC,IAC5C,CAAA,EAAa,IAAI,CAAG,EACpB,EAAa,QAAQ,CAAG,EACxB,SAAS,IAAI,CAAC,WAAW,CAAC,GAC1B,EAAa,KAAK,GAClB,SAAS,IAAI,CAAC,WAAW,CAAC,EAC5B,CEPO,MAAM,WAAqB,YACxB,MAA2B,AACnC,EAAA,EAAY,AAAS,AAErB,cAAc,CACZ,KAAK,GACL,IAAI,CAAC,YAAY,CAAC,CAAE,KAAM,MAAO,GACjC,IAAI,CAAC,UAAU,CAAE,SAAS,CAAG;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;AAkD7B,IAAA,CAAC,AACH,CAEA,mBAA0B,CACxB,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,UAAU,CAAE,aAAa,CAAC,UAC7C,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,QAAS,IAAM,IAAI,CAAC,MAAM,IAEnD,IAAI,CAAC,CAAA,EAAY,EACnB,CAAA,IAAI,CAAC,MAAM,CAAC,KAAK,CAAG,IAAI,CAAC,CAAA,EAAY,AAAZ,EAE3B,SAAS,gBAAgB,CAAC,QAAS,AAAA,IAE/B,AAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,GACtB,IAAI,CAAC,UAAU,CAAE,QAAQ,CAAC,EAAE,MAAM,GAEnC,IAAI,CAAC,KAAK,EAEd,GAEA,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,UAAW,AAAC,IACzB,WAAV,EAAE,GAAG,GACP,IAAI,CAAC,KAAK,GACV,IAAI,CAAC,MAAM,CAAC,KAAK,GAErB,GAGA,IAAI,CAAC,gBAAgB,CAAC,gBAAiB,AAAC,IAEtC,IAAI,CAAC,aAAa,CAChB,IAAI,YAAY,SAAU,CACxB,OAAQ,CAAE,MAAO,AAHD,EAGa,MAAM,CAAC,KAAK,AAAC,EAC1C,QAAS,CAAA,EACT,SAAU,CAAA,CACZ,IAEF,IAAI,CAAC,KAAK,EACZ,EACF,CAEA,WAAW,oBAAqB,CAC9B,MAAO,CAAC,eAAe,AACzB,CAEA,yBAAyB,CAAY,CAAE,CAAc,CAAE,CAAc,CAAE,CACxD,iBAAT,IACE,IAAI,CAAC,MAAM,CACb,IAAI,CAAC,MAAM,CAAC,KAAK,CAAG,EAEpB,IAAI,CAAC,CAAA,EAAY,CAAG,EAG1B,CAEQ,QAAe,CACrB,IAAM,EAAS,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QACrC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,gBAAiB,OAAO,GACnD,CAEQ,OAAc,CACpB,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QACtB,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,gBAAiB,QAC5C,CACF,CAEA,eAAe,MAAM,CAAC,gBAAiB,GC1HvC,OAAM,WAAyB,YAC7B,WAAW,oBAAqB,CAC9B,MAAO,CAAC,QAAQ,AAClB,CAEA,MAAgB,EAAG,AAEnB,cAAc,CACZ,KAAK,GACL,IAAI,CAAC,YAAY,CAAC,CAAE,KAAM,MAAO,GACjC,IAAI,CAAC,UAAU,CAAE,SAAS,CAAG;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;AA0B7B,IAAA,CAAC,AACH,CAEA,mBAA0B,CAExB,AADa,IAAI,CAAC,UAAU,CAAE,aAAa,CAAC,MACvC,gBAAgB,CAAC,QAAS,AAAA,IAC7B,EAAE,cAAc,GAChB,IAAI,CAAC,aAAa,CAChB,IAAI,YAAY,gBAAiB,CAC/B,OAAQ,CAAE,MAAO,IAAI,CAAC,KAAK,AAAC,EAC5B,QAAS,CAAA,EACT,SAAU,CAAA,CACZ,GAEJ,EACF,CAEA,yBAAyB,CAAY,CAAE,CAAiB,CAAE,CAAgB,CAAE,CACtE,AAAS,UAAT,GACF,CAAA,IAAI,CAAC,KAAK,CAAG,CADf,CAGF,CACF,CAEA,eAAe,MAAM,CAAC,qBAAsB,I,I,G,C,EE5D5C,GAAiB,q6CDGjB,MAAM,GAAQ,IAAI,cAClB,GAAM,WAAW,CAAC,OAAO,IAEV,OAAA,WAA0B,YAC/B,MAAsB,AACtB,CAAA,KAAwB,AAEhC,YAAW,oBAAqB,CAC9B,MAAO,CAAC,QAAS,cAAe,QAAS,SAAU,SAAU,OAAO,AACtE,CAEA,aAAc,CACZ,KAAK,GAEL,IAAM,EAAS,IAAI,CAAC,YAAY,CAAC,CAAE,KAAM,MAAO,EAEhD,CAAA,EAAO,kBAAkB,CAAG,CAAC,GAAM,CACnC,IAAI,CAAC,UAAU,CAAE,SAAS,CAAG;A;A;A;A;A;A;A;A;AAS7B,IAAA,CAAC,CAED,IAAI,CAAC,MAAM,CAAG,EAAO,aAAa,CAAC,kBACnC,IAAI,CAAC,KAAK,CAAG,EAAO,aAAa,CAAC,SAClC,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,WAAY,AAAA,IAClC,AAAW,UAAX,EAAE,IAAI,EACR,IAAI,CAAC,MAAM,CAAC,MAAM,EAEtB,EACF,CAEA,mBAAoB,CAClB,IAAI,CAAC,cAAc,EACrB,CAEA,0BAA2B,CACzB,IAAI,CAAC,cAAc,EACrB,CAEQ,gBAAiB,CACvB,GAAY,kBAAkB,CAC3B,MAAM,CAAC,AAAA,GAAQ,AAAS,UAAT,GACf,OAAO,CAAC,AAAA,IACH,IAAI,CAAC,YAAY,CAAC,GACpB,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,EAAM,IAAI,CAAC,YAAY,CAAC,IAEjD,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,EAEhC,GAEE,IAAI,CAAC,YAAY,CAAC,UACpB,CAAA,IAAI,CAAC,KAAK,CAAC,KAAK,CAAG,IAAI,CAAC,YAAY,CAAC,UAAY,EADnD,CAGF,CAKA,KAAK,CAAqB,CAA0B,CAOlD,OANI,AAAiB,KAAA,IAAjB,EACF,IAAI,CAAC,KAAK,CAAC,KAAK,CAAG,EACV,IAAI,CAAC,YAAY,CAAC,UAC3B,CAAA,IAAI,CAAC,KAAK,CAAC,KAAK,CAAG,IAAI,CAAC,YAAY,CAAC,UAAY,EAD5C,EAGP,IAAI,CAAC,KAAK,CAAC,MAAM,GACV,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,IAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CACvD,CAMA,UAA0B,CACxB,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,AACzB,CACF,CAEA,eAAe,MAAM,CAAC,eAAgB,I,I,G,C,EGtFtC,GAAiB,q6CDEjB,MAAM,GAAQ,IAAI,cAClB,GAAM,WAAW,CAAC,OAAO,IAIV,OAAA,WAA4B,YACjC,MAA0B,AAC1B,CAAA,SAA6B,AAC7B,CAAA,SAA6B,AAC7B,CAAA,OAAqB,AACrB,CAAA,MAAoB,AAE5B,YAAW,oBAAqB,CAC9B,MAAO,CAAC,QAAS,cAAe,SAAU,QAAS,OAAO,AAC5D,CAEA,aAAc,CACZ,KAAK,GAEL,IAAM,EAAS,IAAI,CAAC,YAAY,CAAC,CAAE,KAAM,MAAO,EAEhD,CAAA,EAAO,kBAAkB,CAAG,CAAC,GAAM,CACnC,IAAI,CAAC,UAAU,CAAE,SAAS,CAAG;A;A;A;A;A;A;A;A;A;A;A;A;A;AAc7B,IAAA,CAAC,CAED,IAAI,CAAC,MAAM,CAAG,EAAO,aAAa,CAAC,UACnC,IAAI,CAAC,SAAS,CAAG,EAAO,aAAa,CAAC,eACtC,IAAI,CAAC,SAAS,CAAG,EAAO,aAAa,CAAC,eACtC,IAAI,CAAC,OAAO,CAAG,EAAO,aAAa,CAAC,iBACpC,IAAI,CAAC,MAAM,CAAG,EAAO,aAAa,CAAC,eACrC,CAEA,mBAAoB,CAClB,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,QAAS,KACvC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAG,GAC1B,IAAI,CAAC,MAAM,CAAC,KAAK,EACnB,GAGA,IAAI,CAAC,cAAc,EACrB,CAEA,0BAA2B,CACzB,IAAI,CAAC,cAAc,EACrB,CAEQ,gBAAiB,CACnB,IAAI,CAAC,YAAY,CAAC,UACpB,CAAA,IAAI,CAAC,OAAO,CAAC,WAAW,CAAG,IAAI,CAAC,YAAY,CAAC,QAD/C,EAGI,IAAI,CAAC,YAAY,CAAC,gBACpB,CAAA,IAAI,CAAC,MAAM,CAAC,WAAW,CAAG,IAAI,CAAC,YAAY,CAAC,cAD9C,EAGA,IAAI,CAAC,SAAS,CAAC,WAAW,CAAG,IAAI,CAAC,YAAY,CAAC,WAAa,SAC5D,IAAI,CAAC,SAAS,CAAC,WAAW,CAAG,IAAI,CAAC,YAAY,CAAC,WAAa,SAExD,IAAI,CAAC,YAAY,CAAC,SAAW,AAA8B,UAA9B,IAAI,CAAC,YAAY,CAAC,QACjD,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,SAE1B,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,QAEjC,CAKA,MAAsB,CAEpB,OADA,IAAI,CAAC,MAAM,CAAC,SAAS,GACd,IAAI,QAAQ,CAAC,EAAS,KAC3B,IAAM,EAAc,KAClB,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC,QAAS,GACrC,AAA4B,YAA5B,IAAI,CAAC,MAAM,CAAC,WAAW,CACzB,IAEA,GAEJ,EACA,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,QAAS,EACxC,EACF,CAEA,QAAS,CACP,IAAI,CAAC,SAAS,CAAC,KAAK,EACtB,CACF,CAEA,eAAe,MAAM,CAAC,iBAAkB,InD1ExC,OAAO,gBAAgB,CAAC,QAAS,SAAU,CAAK,EAC9C,MAAM,UAAY,EAAM,OAAO,CACjC,GAEA,MAAM,GAA2C,CAC/C,KAAM,SAAS,aAAa,CAAC,QAC7B,OAAQ,SAAS,aAAa,CAAC,iBAC/B,YAAa,SAAS,aAAa,CAAC,iBACpC,eAAgB,SAAS,aAAa,CAAC,qBACvC,iBAAkB,SAAS,aAAa,CAAC,uBACzC,SAAU,SAAS,aAAa,CAAC,cACjC,SAAU,SAAS,aAAa,CAAC,cACjC,UAAW,SAAS,aAAa,CAAC,eAClC,QAAS,SAAS,aAAa,CAAC,YAChC,iBAAkB,SAAS,aAAa,CACtC,wCAEJ,EAIM,GAAS,IC3CA,MACb,QAOE,AACF,CAAA,SAAkB,AAClB,EAAA,EAAU,AAAU,AACpB,CAAA,SAAqB,AACrB,EAAA,EAAY,AAAS,AAErB,aAAY,CAAqB,CAAE,CACjC,IAAI,CAAC,QAAQ,CAAG,CACd,OAAQ,EACR,KAAM,EAAS,aAAa,CAAC,SAE7B,eAAgB,EAAS,aAAa,CACpC,oBAEF,QAAS,EAAS,aAAa,CAAC,aAChC,SAAU,EAAS,aAAa,CAAC,cACjC,KAAM,EAAS,aAAa,CAAC,eAC/B,EACA,IAAI,CAAC,SAAS,CAAG,EACjB,IAAI,CAAC,CAAA,EAAU,CAAG,CAAA,EAElB,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,gBAAgB,CAAC,QAAS,CAAC,CAAA,OAAE,CAAM,CAAE,IAC5D,UAAW,GACb,IAAI,CAAC,IAAI,CAAC,CAAC,EAAO,KAAK,CAE3B,GAEA,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,gBAAgB,CAAC,QAAS,KAC9C,IAAI,CAAC,IAAI,EACX,GAEA,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,gBAAgB,CAAC,QAAS,KAC/C,IAAI,CAAC,KAAK,EACZ,EACF,CAEA,aAAa,CAAkB,CAAE,CAC3B,IAAI,CAAC,CAAA,EAAU,GAAK,IACtB,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,WACtC,IAAI,CAAC,CAAA,EAAU,CAAG,EAEtB,CAEA,OAAO,CAAyB,CAAE,CAAA,KAAE,EAAO,CAAA,CAAA,CAAM,CAAG,CAAC,CAAC,CAAE,CACtD,IAAI,CAAC,SAAS,CAAG,EACjB,IAAI,CAAC,SAAS,CAAG,EAAU,YAAY,GACvC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY,CAAC,MAAO,OAAO,IAAI,CAAC,SAAS,GACtE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAG,CAAA,EAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,SAAS,CAAA,CAAE,CACpE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,SACxC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAC3B,AAAA,CAAA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,EAAI,EAAA,EAAM,KAC3C,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAE,CAAE,gBAAiB,CAAK,EACpD,CAEA,eAAe,CAAgB,CAAE,CAC/B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAG,CAAA,EAAG,EAAS,CAAC,EAAE,IAAI,CAAC,SAAS,CAAA,CAAE,CAC9D,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,KAAK,CAAG,OAAO,EAC9C,CAEA,KAAK,CAAgB,CAAE,CAAA,gBAAE,EAAkB,CAAA,CAAA,CAAM,CAAG,CAAC,CAAC,CAAE,CAClD,EAAW,IAAI,CAAC,SAAS,EAAI,EAAW,IAI5C,IAAI,CAAC,KAAK,GACV,IAAI,CAAC,cAAc,CAAC,GAChB,GACF,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAExB,CAEA,QAAQ,EAAQ,CAAC,CAAE,CACO,AAAO,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,KAA5D,CAEA,IAAI,CAAC,IAAI,CACP,KAAK,GAAG,CACN,EACA,KAAK,GAAG,CACN,IAAI,CAAC,SAAS,CACd,OAAO,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,KAAK,EAAI,IAIrD,CAEA,gBAAgB,CAAY,CAAE,CAE9B,CAEA,MAAO,CACL,IAAI,CAAC,YAAY,CAAC,CAAA,GAClB,qBAAqB,IAAI,CAAC,CAAA,EAAY,EAElC,IAAI,CAAC,SAAS,CAAC,QAAQ,GAAK,IAAI,CAAC,SAAS,EAC5C,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAGtB,IAAM,EAAO,IAAI,EAEjB,AAEA,SAAS,IACF,EAAK,SAAS,CAAC,QAAQ,GAAG,IAAI,CAGjC,EAAK,YAAY,CAAC,CAAA,GAFlB,EAAK,CAAA,EAAY,CAAG,sBAAsB,GAI5C,EAAK,cAAc,CAAC,EAAK,SAAS,CAAC,QAAQ,CAC7C,GACF,CAEA,OAAQ,CACN,qBAAqB,IAAI,CAAC,CAAA,EAAY,EACtC,IAAI,CAAC,YAAY,CAAC,CAAA,EACpB,CAEA,QAAS,CACH,IAAI,CAAC,CAAA,EAAU,CACjB,IAAI,CAAC,KAAK,GAEV,IAAI,CAAC,IAAI,EAEb,CACF,EDxF0B,SAAS,aAAa,CAAC,YAC3C,GAAe,IAAI,GAAmB,CAC1C,eAAgB,IAAM,CACpB,GAAS,MAAM,CAAC,WAAW,CAC3B,GAAS,MAAM,CAAC,YAAY,CAC7B,AACH,GAEM,GAAc,IAAI,GAClB,GAAa,IAAI,GAAW,IAIlC,eAAe,SACT,EAiBA,EA8GF,OAAO,gBAAgB,CAAC,WAAY,CAAC,CAAA,MAAE,CAAK,CAAE,IAC5C,EAAY,EACd,GA7HF,MAAM,AAAA,KAEN,SAAS,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,OAAO,CAAC,IACxD,GAAO,SAAS,aAAa,CAAC,SAE9B,IAAM,EAAc,IAAI,gBAAgB,SAAS,QAAQ,CAAC,MAAM,EAChE,EACE,AAAgC,QAAhC,EAAY,GAAG,CAAC,YACZ,IAAI,GAAY,GAAS,MAAM,EAC/B,IAAI,GAAe,GAAS,MAAM,EAExC,IAAM,EAAW,AE3CJ,EF2CiB,GAAG,CAAC,AAAA,GAAW,IAAI,EAAQ,IAIzD,GAAI,QAAQ,KAAK,EAAE,QACjB,EAAY,QAAQ,KAAK,MACpB,CACL,IAAM,EAAe,EAAY,GAAG,CAAC,WAEjC,EAEF,EAAY,CAAE,QAAS,EAAc,OADtB,EAAY,GAAG,CAAC,SACa,GAE5C,GAAW,MAAM,EAErB,CAsGA,SAAS,EAAY,CAAwC,EAC3D,GAAI,GAAO,QAAS,CAClB,IAAM,EAAU,EAAgB,EAAM,OAAO,EACzC,GACF,EAAQ,QAAQ,CAAG,EACnB,EAAc,EAAS,CACrB,KAAM,CAAA,EACN,OAAQ,EAAM,MAAM,CAChB,AwClKP,SACL,CAA2B,CAC3B,CAAuB,EAEvB,IAAM,EAAyB,EAC5B,OAAO,CAAC,mBAAoB,CAAC,EAAG,IAC/B,AAAI,MAAM,CAAC,GAAY,IAAI,CAAC,KAAK,IAAI,CAAC,KAEvC,KAAK,CAAC,KACN,GAAG,CAAC,AAAA,IACH,GAAI,AAAM,KAAN,EACF,OAAO,KAGT,GAAI,GAAa,IAAI,CAAC,GACpB,OAAO,WAAW,GAGpB,IAAM,EAAe,EAAE,KAAK,CAAC,WAC7B,AAAI,EACK,AAAoB,MAApB,CAAY,CAAC,EAAE,CAGjB,CACT,GAEI,EAAa,OAAO,IAAI,CAAC,EAAQ,aAAa,EAEpD,OAAO,EAAuB,MAAM,CAAC,CAAC,EAAQ,EAAiB,KAC7D,GAAI,AAAoB,OAApB,EAA0B,CAC5B,IAAM,EAAM,CAAU,CAAC,EAAE,CACzB,MAAO,CAAE,GAAG,CAAM,CAAE,CAAC,EAAI,CAAE,CAAgB,CAC7C,CAEA,OAAO,CACT,EAAG,CAAC,EACN,ExC8HgC,EAAS,EAAM,MAAM,EACvC,IACN,GAEA,GAAW,KAAK,GAChB,EAAe,IAAI,IAEnB,GAAW,IAAI,EAEnB,MACE,IACA,GAAW,IAAI,EAEnB,CAEA,SAAS,EAAgB,CAAiB,EACxC,IAAI,EAA0B,EAAS,IAAI,CAAC,CAAC,CAAA,GAAE,CAAE,CAAE,GAAK,IAAO,GAM/D,OAJI,AAAC,GAEH,CAAA,EAAU,AAAA,GAAY,cAAc,CAAC,EAArC,EAEK,CACT,CAEA,eAAe,IACb,GAAI,CAAC,EACH,MAAM,AAAI,MAAM,sDAkHlB,GAAa,OAAO,CAAC,gBAAgB,CACnC,aACA,CAAC,CAAA,OAAE,CAAM,CAAkC,QAM9B,CACX,EADW,EALH,IAMA,AAAgB,IAAhB,EAAK,MAAM,EACrB,EAAgB,OAAO,CAAC,GACpB,AAAC,GAAS,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,aACtC,GAAS,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,cAGhC,GAAS,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,YACjC,EAAgB,OAAO,CAAC,OAG1B,EAAe,IAAI,EAfjB,GAjHF,OAAO,gBAAgB,CACrB,SACA,IAAM,GAAkB,EAAe,IAAI,IAG7C,GAAS,WAAW,CAAC,gBAAgB,CAAC,QAAS,GAC/C,GAAS,gBAAgB,CAAC,gBAAgB,CAAC,QAAS,GACpD,GAAS,QAAQ,CAAC,gBAAgB,CAAC,QAAS,GAKxC,AAJc,MAAM,AAAA,GAAiB,CACvC,SAAU,EACV,QAAS,CACX,IAEE,GAAO,GAAS,QAAQ,CAE5B,CAEA,SAAS,IACP,AAAA,GAAa,EAAgB,SAAS,GAAI,EAAe,IAAI,CAAG,OAClE,CAMA,SAAS,IACP,IAAM,EAAgB,EAAe,MAAM,AAC3C,CAAA,EAAe,MAAM,CAAG,CACtB,GAAG,CAAa,CAChB,SAAU,CAAA,EACV,UAAW,CAAA,EACX,gBAAiB,CAAA,EACjB,YAAa,CAAA,EACb,WAAY,SACd,EACA,EAAe,IAAI,GACnB,IAGA,EAAe,MAAM,CAAG,EACxB,EAAe,IAAI,EACrB,CAEA,SAAS,IACP,AAAA,GAAQ,CACN,MAAO,gBACP,YAAa,EAAe,UAAU,CAClC,sDACA,8DACJ,OAAQ,OACV,GAAG,IAAI,CACL,KAEE,EADgB,EAAgB,EAAe,EAAE,EAG/C,EAAe,UAAU,CAAG,CAAE,OAAQ,CAAC,CAAE,EAAI,CAAC,EAElD,EACA,KAAO,EAEX,CAEA,SAAS,IACP,GAAO,MAAM,CAAC,GACd,IAAM,EAAc,AwCtSjB,SAAyB,CAAuB,EACrD,GAAM,CAAA,cAAE,CAAa,CAAA,OAAE,CAAM,CAAE,CAAG,EAE5B,EAAyB,OAAO,OAAO,CAAC,GAAQ,GAAG,CAAC,CAAC,CAAC,EAAK,EAAM,GACrE,AAAI,IAAU,CAAa,CAAC,EAAI,CACvB,KAGL,AAAiB,WAAjB,OAAO,EACF,CAAC,CAAC,EAAE,GAAA,EAAY,CAAG,CAGxB,AAAiB,UAAjB,OAAO,EACF,WAAW,EAAM,OAAO,CAfV,IAkBhB,GAGT,KAAO,AAA8D,OAA9D,CAAsB,CAAC,EAAuB,MAAM,CAAG,EAAE,EAC9D,EAAuB,GAAG,UAG5B,AAAK,EAAuB,MAAM,CAIH,EAC5B,IAAI,CAAC,KACL,OAAO,CAAC,UAAW,AAAA,GAAS,IAAM,EAAM,MAAM,CAAG,KAL3C,EAOX,ExCuQwC,GACpC,QAAQ,YAAY,CAClB,CACE,QAAS,EAAe,EAAE,CAC1B,OAAQ,CACV,EACA,EAAe,IAAI,CACnB,CAAC,SAAS,EAAE,EAAe,EAAE,CAAA,EAC3B,EAAc,CAAC,QAAQ,EAAE,mBAAmB,GAAA,CAAc,CAAG,GAAA,CAC7D,EAGJ,AAGF,SAA4B,CAAe,EAEzC,IAAM,EACJ,AAHwB,CAAA,KAAA,CAAA,GAGf,EAAe,UAAU,CAC9B,AAAA,EAAe,EAAe,MAAM,CAAE,EAAe,aAAa,EAClE,AAAA,EACE,EAAe,MAAM,CACrB,EAAgB,EAAe,EAAE,EAAE,MAAM,CAGjD,CAAA,GAAS,IAAI,CAAC,OAAO,CAAC,eAAe,CAAG,OAAO,EACjD,GAbA,CAeA,SAAS,EACP,CAAgB,CAChB,CAAqC,EAErC,EAAc,EAAS,GACvB,QAAQ,SAAS,CACf,CAAE,QAAS,EAAQ,EAAE,AAAC,EACtB,EAAQ,IAAI,CACZ,YAAc,EAAQ,EAAE,EAG1B,GAAS,IAAI,CAAC,OAAO,CAAC,eAAe,CAAG,OACtC,GAAmB,kBAAoB,CAAA,EAE3C,CAyBA,SAAS,EACP,CAAgB,CAChB,CAAA,OAAE,CAAM,CAAA,KAAE,EAAO,CAAA,CAAA,CAAyB,CAAG,CAAC,CAAC,EAE/C,IAAM,EAAc,CAAC,CAGrB,CADA,CAAA,EAAiB,CAAjB,EACe,QAAQ,CAAG,EACtB,GAEF,EAAe,SAAS,CAAC,GAEvB,GACF,EAAS,OAAO,GAGlB,GAAY,UAAU,CAAC,GAEvB,AADA,CAAA,EAAW,IAAI,GAAoB,EAAQ,cAAc,CAAE,EAAQ,MAAM,CAAA,EAChE,gBAAgB,CAAC,QAAS,CAAC,CAAA,QAAE,CAAO,CAAA,MAAE,CAAK,CAAE,IACpD,EAAe,cAAc,CAAC,EAAS,GACvC,EAAS,MAAM,CAAG,EAAe,MAAM,CACvC,EAAe,IAAI,EACrB,GACA,EAAS,gBAAgB,CAAC,SAAU,GAEhC,GACF,sBAAsB,KACpB,EAAe,IAAI,EACrB,GAGF,GAAW,iBAAiB,CAAC,GAC7B,SAAS,KAAK,CAAG,CAAA,EAAG,EAAQ,IAAI,CAAC,oBAAoB,CAAC,CACtD,SAAS,IAAI,CAAC,YAAY,CAAC,eAAgB,EAAQ,EAAE,EAEjD,IACF,IACA,SAAS,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,OAAO,CAAC,KAG1D,GAAO,MAAM,CAAC,EAAgB,CAAE,KAAM,CAAA,CAAM,GAE5C,GAAS,IAAI,CAAC,OAAO,CAAC,UAAU,CAAG,OAAO,EAAe,UAAU,CACrE,CAEA,SAAS,IACP,EAAiB,KACjB,EAAgB,KAAK,GACrB,GAAW,iBAAiB,CAAC,MAC7B,GAAY,EAAS,OAAO,GAC5B,SAAS,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,OAAO,CAAC,IACxD,SAAS,IAAI,CAAC,eAAe,CAAC,eAChC,CAnUA,GAAS,WAAW,CAAC,gBAAgB,CAAC,QAAS,GAC/C,GAAS,cAAc,CAAC,gBAAgB,CAAC,QAgKzC,YACE,A4C7PG,SAA8B,CAAO,CAAE,CAAI,EAChD,IAAM,EAAW,SAAS,aAAa,CAAC,UACxC,CAAA,EAAS,KAAK,CAAC,KAAK,CAAG,CAAI,CAAC,EAAE,CAAG,KACjC,EAAS,KAAK,CAAC,MAAM,CAAG,CAAI,CAAC,EAAE,CAAG,KAClC,SAAS,IAAI,CAAC,WAAW,CAAC,GAC1B,IAAM,EAAc,IAAI,GAAY,GAG9B,EAAa,IADQ,EAAQ,WAAW,CACJ,GAE1C,EAAW,SAAS,CAAC,EAAQ,MAAM,EACnC,EAAW,IAAI,GAGf,IAAI,EAAU,IAAI,KAAK,CADT,EAAW,QAAQ,CAAC,GAAG,CAAC,SAAS,CACf,CAAE,CAAE,KAAM,6BAA8B,GAGxE,AAAA,GAFa,IAAI,eAAe,CAAC,GAEZ,EAAQ,IAAI,CAAG,QACpC,SAAS,IAAI,CAAC,WAAW,CAAC,EAC5B,E5C0OyB,EAAgB,EAAgB,OAAO,GAC9D,GAjKA,GAAS,gBAAgB,CAAC,gBAAgB,CAAC,QAAS,GACpD,GAAS,QAAQ,CAAC,gBAAgB,CAAC,QAAS,GAC5C,GAAS,QAAQ,CAAC,gBAAgB,CAChC,QACA,SACE,MAAM,AAAA,GAAM,CACV,SAAU,EACV,QAAS,CACX,IAgBJ,GAAS,gBAAgB,CAAC,gBAAgB,CAAC,QAAS,AAAA,IAClD,EAAE,cAAc,GAChB,QAAQ,SAAS,CAAC,CAAE,QAAS,IAAK,EAAG,oBAAqB,MAC1D,GACF,GAEA,GAAW,gBAAgB,CAAC,SAAU,CAAC,CAAA,UAAE,CAAS,CAAE,IAElD,EADgB,EAAgB,GAElC,GAEA,GAAS,MAAM,CAAC,gBAAgB,CAAC,QAAS,CAAC,CAAA,OAAE,CAAM,CAAE,IACnD,IAAM,EAAY,CAAC,EAAS,KAAK,GAAG,CAAC,GACrC,GAAO,OAAO,CAAC,EACjB,GAuBA,SAAS,IAAI,CAAC,gBAAgB,CAAC,QAAS,AAAA,IACtC,IAAM,EACJ,EAAE,MAAM,YAAY,aAAe,EAAE,MAAM,CAAC,OAAO,CAAC,qBACtD,GAAI,aAAqB,aAAe,EAAW,KArD7B,EAsDpB,IAAM,EAAW,EAAU,OAAO,CAAC,SAAS,CAtDxB,EAwDL,CAAC,EAAS,CAvD3B,SACG,gBAAgB,CAAC,qCACjB,OAAO,CAAC,AAAA,IAEL,aAAe,aACf,CAAC,GAAS,SAAS,EAAI,YAAY,CAAC,qBAEpC,EAAI,KAAK,EAEb,GA+CA,EAAU,SAAS,CAAC,MAAM,CAAC,UAE3B,IAAM,EAAiB,SAAS,aAAa,CAAC,IAAM,GAChD,IACF,EAAe,SAAS,CAAC,MAAM,CAAC,QAChC,SAAS,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,UAAY,GAC3C,GACE,EAAe,IAAI,CAAC,CAAE,SAAU,EAAe,QAAQ,AAAC,GAE9D,CACF,GAEA,GAAY,gBAAgB,CAAC,gBAAiB,CAAC,CAAA,QAAE,CAAO,CAAE,IACxD,IAAM,EAAkB,EAAgB,EAAQ,IAAI,EAChD,IACF,EAAgB,MAAM,CAAG,EAAQ,MAAM,CACvC,EAAkB,EAAiB,CAAE,gBAAiB,CAAA,CAAM,GAEhE,GAEA,GAAY,gBAAgB,CAAC,OAAQ,CAAC,CAAA,QAAE,CAAO,CAAE,IAC/C,EAAkB,EACpB,EAwOF,CAEA,SAAS,GAAO,CAAgB,EAC9B,EAAQ,eAAe,CAAC,SAC1B,CAEA,SAAS,GAAK,CAAgB,EAC5B,EAAQ,YAAY,CAAC,SAAU,SACjC,CA/WA,OAAO,gBAAgB,CAAC,OAAQ","sources":["<anon>","src/scripts/main.ts","src/scripts/editor/Player.ts","src/scripts/pattern_types.ts","src/scripts/string_art_types/Spiral.ts","src/scripts/helpers/color/Color.ts","src/scripts/helpers/config_utils.ts","src/scripts/helpers/color/color_controls.ts","src/scripts/StringArt.ts","src/scripts/Nails.ts","src/scripts/helpers/Circle.ts","src/scripts/helpers/easing.ts","src/scripts/helpers/math_utils.ts","src/scripts/helpers/object_utils.ts","src/scripts/string_art_types/Spirals.ts","src/scripts/string_art_types/Wave.ts","src/scripts/string_art_types/Mandala.ts","src/scripts/helpers/string_utils.ts","src/scripts/string_art_types/Eye.ts","src/scripts/string_art_types/Star.ts","src/scripts/helpers/StarShape.ts","src/scripts/string_art_types/Assymetry.ts","src/scripts/string_art_types/Freestyle.ts","src/scripts/string_art_types/PolygonPattern.ts","src/scripts/helpers/Polygon.ts","src/scripts/string_art_types/Flower.ts","src/scripts/string_art_types/MaurerRose.ts","src/scripts/string_art_types/FlowerOfLife.ts","src/scripts/string_art_types/Comet.ts","src/scripts/string_art_types/Sun.ts","src/scripts/string_art_types/Lotus.ts","src/scripts/editor/EditorControls.ts","src/scripts/components/StringArtHueInput.ts","src/scripts/components/StringArtRangeInput.ts","src/scripts/editor/EditorSizeControls.ts","src/scripts/thumbnails/Thumbnails.ts","src/scripts/renderers/CanvasRenderer.ts","src/scripts/renderers/Renderer.ts","src/scripts/Persistance.ts","src/scripts/helpers/EventBus.ts","src/scripts/helpers/dialogs.ts","src/scripts/Serialize.ts","src/scripts/share.ts","src/scripts/pwa.ts","src/scripts/renderers/SVGRenderer.ts","src/scripts/download/SVGDownload.ts","src/scripts/download/Download.ts","src/scripts/components/components.ts","src/scripts/components/DropdownMenu.ts","src/scripts/components/DropdownMenuItem.ts","src/scripts/components/dialogs/InputDialog.ts","node_modules/@parcel/runtime-js/lib/bundles/runtime-f124c8be16fdc81b.js","src/scripts/components/dialogs/ConfirmDialog.ts","node_modules/@parcel/runtime-js/lib/bundles/runtime-c376ef0475a71006.js"],"sourcesContent":["class $f003126099aabc1e$export$2e2bcd8739ae039 {\n    elements;\n    stepCount;\n    #isPlaying;\n    stringArt;\n    #renderRafId;\n    constructor(parentEl){\n        this.elements = {\n            player: parentEl,\n            step: parentEl.querySelector('#step'),\n            //stepInstructions: parentEl.querySelector('#step_instructions'),\n            playerPosition: parentEl.querySelector('#player_position'),\n            playBtn: parentEl.querySelector('#play_btn'),\n            pauseBtn: parentEl.querySelector('#pause_btn'),\n            text: parentEl.querySelector('#player_text')\n        };\n        this.stepCount = 0;\n        this.#isPlaying = false;\n        this.elements.playerPosition.addEventListener('input', ({ target: target })=>{\n            if ('value' in target) this.goto(+target.value);\n        });\n        this.elements.playBtn.addEventListener('click', ()=>{\n            this.play();\n        });\n        this.elements.pauseBtn.addEventListener('click', ()=>{\n            this.pause();\n        });\n    }\n    updateStatus(isPlaying) {\n        if (this.#isPlaying !== isPlaying) {\n            this.elements.player.classList.toggle('playing');\n            this.#isPlaying = isPlaying;\n        }\n    }\n    update(stringArt, { draw: draw = true } = {}) {\n        this.stringArt = stringArt;\n        this.stepCount = stringArt.getStepCount();\n        this.elements.playerPosition.setAttribute('max', String(this.stepCount));\n        this.elements.step.innerText = `${this.stepCount}/${this.stepCount}`;\n        this.elements.text.style.removeProperty('width');\n        this.elements.text.style.width = (this.elements.text.clientWidth || 70) + 'px';\n        this.goto(this.stepCount, {\n            updateStringArt: draw\n        });\n    }\n    updatePosition(position) {\n        this.elements.step.innerText = `${position}/${this.stepCount}`;\n        this.elements.playerPosition.value = String(position);\n    }\n    goto(position, { updateStringArt: updateStringArt = true } = {}) {\n        if (position > this.stepCount || position < 1) return;\n        this.pause();\n        this.updatePosition(position);\n        if (updateStringArt) this.stringArt.goto(position);\n    }\n    advance(value = 1) {\n        const currentPosition = Number(this.elements.playerPosition.value);\n        this.goto(Math.max(1, Math.min(this.stepCount, Number(this.elements.playerPosition.value) + value)));\n    }\n    setInstructions(instructions) {\n    // this.elements.stepInstructions.innerText = instructions;\n    }\n    play() {\n        this.updateStatus(true);\n        cancelAnimationFrame(this.#renderRafId);\n        if (this.stringArt.position === this.stepCount) this.stringArt.goto(0);\n        const self = this;\n        step();\n        function step() {\n            if (!self.stringArt.drawNext().done) self.#renderRafId = requestAnimationFrame(step);\n            else self.updateStatus(false);\n            self.updatePosition(self.stringArt.position);\n        }\n    }\n    pause() {\n        cancelAnimationFrame(this.#renderRafId);\n        this.updateStatus(false);\n    }\n    toggle() {\n        if (this.#isPlaying) this.pause();\n        else this.play();\n    }\n}\n\n\nfunction* $b103c63dc979d40c$export$596571ef134d4065(controlsConfig, parent) {\n    let index = 0;\n    for (const control of controlsConfig){\n        yield {\n            control: control,\n            index: index,\n            parent: parent\n        };\n        if (control.children) yield* $b103c63dc979d40c$export$596571ef134d4065(control.children, {\n            control: control,\n            parent: parent,\n            index: index\n        });\n        index++;\n    }\n}\nfunction $b103c63dc979d40c$var$findControlConfigNode(controlsConfig, findFn) {\n    for (const node of $b103c63dc979d40c$export$596571ef134d4065(controlsConfig)){\n        if (findFn(node.control)) return node;\n    }\n    return null;\n}\nfunction $b103c63dc979d40c$var$getControlConfigNodeByKey(controlsConfig, controlKey) {\n    return $b103c63dc979d40c$var$findControlConfigNode(controlsConfig, ({ key: key })=>key === controlKey);\n}\nfunction $b103c63dc979d40c$export$2d97e2da46663803(controlConfig, attributeName) {\n    const attr = controlConfig.attr;\n    if (!attr) return controlConfig;\n    const attrCopy = {\n        ...attr\n    };\n    delete attrCopy[attributeName];\n    return {\n        ...controlConfig,\n        attr: attrCopy\n    };\n}\nfunction $b103c63dc979d40c$export$68091c7c829a57b8(controlsConfig) {\n    return controlsConfig.map((control)=>{\n        const copy = {\n            ...control\n        };\n        if (control.children) copy.children = $b103c63dc979d40c$export$68091c7c829a57b8(control.children);\n        if (control.attr) copy.attr = {\n            ...control.attr\n        };\n        return copy;\n    });\n}\nfunction $b103c63dc979d40c$export$e6b0de4153cc8c78(controlsConfig, controlKey) {\n    const controlNode = $b103c63dc979d40c$var$getControlConfigNodeByKey(controlsConfig, controlKey);\n    if (controlNode) {\n        const path = [\n            controlNode.index\n        ];\n        let parentNode = controlNode.parent;\n        while(parentNode){\n            path.unshift(parentNode.index);\n            parentNode = parentNode.parent;\n        }\n        return path;\n    }\n    return null;\n}\nfunction $b103c63dc979d40c$export$c4f94c8b3850a5a9(controlsConfig, insertAfterKey, controlsConfigToInsert) {\n    const configCopy = $b103c63dc979d40c$export$68091c7c829a57b8(controlsConfig);\n    const nodeToAddAfter = $b103c63dc979d40c$var$getControlConfigNodeByKey(configCopy, insertAfterKey);\n    if (nodeToAddAfter) {\n        const { index: index, parent: parent } = nodeToAddAfter;\n        let list = parent?.control.children ?? configCopy;\n        list.splice(index + 1, 0, ...controlsConfigToInsert);\n        return configCopy;\n    }\n    return controlsConfig;\n}\nfunction $b103c63dc979d40c$export$d9fe7d5b8b296e7c(controlsConfig, controlPropMapper) {\n    return controlPropMapper ? controlsConfig.map((control)=>{\n        if (control.children) control = {\n            ...control,\n            children: $b103c63dc979d40c$export$d9fe7d5b8b296e7c(control.children, controlPropMapper)\n        };\n        return {\n            ...control,\n            ...controlPropMapper(control)\n        };\n    }) : controlsConfig;\n}\nfunction $b103c63dc979d40c$export$38c07eba5c3aa11b(configControls) {\n    const defaultValues = {};\n    for (const { control: { key: key, defaultValue: defaultValue } } of $b103c63dc979d40c$export$596571ef134d4065(configControls))if (!(defaultValue instanceof Function)) defaultValues[key] = defaultValue;\n    return defaultValues;\n}\nfunction $b103c63dc979d40c$export$ab1c0bf676278196(configControls) {\n    const configIndex = {};\n    for (const { control: control } of $b103c63dc979d40c$export$596571ef134d4065(configControls))configIndex[control.key] = control;\n    return configIndex;\n}\n\n\nconst $9e482fa80a49eb9a$var$COLOR_CONTROLS = [\n    {\n        key: 'isMultiColor',\n        label: 'Use multiple colors',\n        defaultValue: false,\n        type: 'checkbox'\n    },\n    {\n        key: 'colorCount',\n        label: 'Colors count',\n        defaultValue: 7,\n        type: 'range',\n        attr: {\n            min: 1,\n            max: 20,\n            step: 1\n        },\n        show: ({ isMultiColor: isMultiColor })=>isMultiColor\n    },\n    {\n        key: 'color',\n        label: 'String color',\n        defaultValue: '#ff4d00',\n        type: 'color',\n        show: ({ isMultiColor: isMultiColor })=>!isMultiColor\n    },\n    {\n        key: 'multicolorStart',\n        label: 'Multicolor start',\n        defaultValue: 1,\n        type: 'hue',\n        attr: {\n            colorthumb: true\n        },\n        show: ({ isMultiColor: isMultiColor })=>isMultiColor\n    },\n    {\n        key: 'multicolorRange',\n        label: 'Multicolor range',\n        defaultValue: 360,\n        type: 'hue',\n        attr: {\n            start: ({ multicolorStart: multicolorStart })=>multicolorStart,\n            type: 'range'\n        },\n        show: ({ isMultiColor: isMultiColor })=>isMultiColor\n    },\n    {\n        key: 'saturation',\n        label: 'Saturation',\n        defaultValue: 100,\n        type: 'range',\n        attr: {\n            min: 0,\n            max: 100,\n            step: 1\n        },\n        show: ({ isMultiColor: isMultiColor })=>isMultiColor\n    },\n    {\n        key: 'lightness',\n        label: 'Lightness',\n        type: 'group',\n        defaultValue: 'minimized',\n        show: ({ isMultiColor: isMultiColor })=>isMultiColor,\n        children: [\n            {\n                key: 'multicolorByLightness',\n                label: 'Multi lightness',\n                defaultValue: false,\n                type: 'checkbox',\n                show: ({ isMultiColor: isMultiColor })=>isMultiColor\n            },\n            {\n                key: 'minLightness',\n                label: 'Minimum lightness',\n                defaultValue: 0,\n                type: 'range',\n                attr: {\n                    min: 0,\n                    max: 100,\n                    step: 1,\n                    snap: '50',\n                    thumbcolor: ({ minLightness: minLightness })=>`hsl(0 0 ${minLightness})`,\n                    background: 'linear-gradient(to right, black, white)'\n                },\n                show: ({ multicolorByLightness: multicolorByLightness, isMultiColor: isMultiColor })=>multicolorByLightness && isMultiColor\n            },\n            {\n                key: 'maxLightness',\n                label: 'Maximum lightness',\n                defaultValue: 100,\n                type: 'range',\n                attr: {\n                    min: 0,\n                    max: 100,\n                    step: 1,\n                    snap: '50',\n                    thumbcolor: ({ maxLightness: maxLightness })=>`hsl(0 0 ${maxLightness})`,\n                    background: 'linear-gradient(to right, black, white)'\n                },\n                show: ({ multicolorByLightness: multicolorByLightness, isMultiColor: isMultiColor })=>multicolorByLightness && isMultiColor\n            }\n        ]\n    },\n    {\n        key: 'colorOrderGroup',\n        type: 'group',\n        label: 'Order',\n        defaultValue: 'minimized',\n        show: ({ isMultiColor: isMultiColor })=>isMultiColor,\n        children: [\n            {\n                key: 'reverseColors',\n                label: 'Reverse colors order',\n                defaultValue: false,\n                type: 'checkbox',\n                show: ({ isMultiColor: isMultiColor })=>isMultiColor\n            },\n            {\n                key: 'repeatColors',\n                label: 'Repeat colors',\n                defaultValue: true,\n                type: 'checkbox',\n                show: ({ isMultiColor: isMultiColor })=>isMultiColor\n            },\n            {\n                key: 'mirrorColors',\n                label: 'Mirror Colors',\n                defaultValue: false,\n                type: 'checkbox',\n                show: ({ isMultiColor: isMultiColor, repeatColors: repeatColors })=>isMultiColor && repeatColors\n            }\n        ]\n    }\n];\nvar $9e482fa80a49eb9a$export$2e2bcd8739ae039 = $9e482fa80a49eb9a$var$COLOR_CONTROLS;\n\n\nclass $44d9dab6555abf73$export$2e2bcd8739ae039 {\n    config;\n    multiColorStep;\n    multiColorLightnessStep;\n    colors;\n    constructor(config){\n        this.config = config;\n        const { multicolorRange: multicolorRange, colorCount: colorCount, multicolorByLightness: multicolorByLightness, minLightness: minLightness = 0, maxLightness: maxLightness = 100, multicolorStart: multicolorStart, darkMode: darkMode, saturation: saturation, reverseColors: reverseColors, repeatColors: repeatColors, mirrorColors: mirrorColors, isMultiColor: isMultiColor } = config;\n        if (isMultiColor) {\n            this.multiColorStep = multicolorRange / Math.max(1, colorCount - 1);\n            this.multiColorLightnessStep = multicolorByLightness ? (maxLightness - minLightness) / (Math.max(colorCount, 2) - 1) : 1;\n            this.colors = new Array(colorCount).fill(null).map((_, colorIndex)=>{\n                const lightness = multicolorByLightness ? minLightness + this.multiColorLightnessStep * colorIndex : darkMode ? 50 : 40;\n                return `hsl(${multicolorStart + colorIndex * this.multiColorStep}, ${saturation}%, ${lightness}%)`;\n            });\n            if (repeatColors && mirrorColors) {\n                const [_firstColor, ...restColors] = this.colors;\n                restColors.pop();\n                this.colors = [\n                    ...this.colors,\n                    ...restColors.reverse()\n                ];\n            }\n            if (reverseColors) this.colors.reverse();\n        }\n    }\n    /**\n   * Returns the color to be used in the provided layer index. If no multiColor is used, will use the 'color' config property.\n   * @param {number} colorIndex\n   * @returns string\n   */ getColor(colorIndex) {\n        const { isMultiColor: isMultiColor, colorCount: colorCount, color: color, repeatColors: repeatColors } = this.config;\n        if (!isMultiColor) return color;\n        if (colorIndex >= colorCount) colorIndex = repeatColors ? colorIndex % this.colors.length : this.colors.length - 1;\n        return this.colors[colorIndex];\n    }\n    /**\n   * Returns the color with the opposite hue to the color at this index\n   */ static getOppositeColor(hslColor) {\n        const hslMatch = hslColor.match(/^hsl\\((\\d+)(?:deg)?(?:,?\\s?)(\\d+%?)(?:,?\\s?)(\\d+%?)\\)$/);\n        if (hslMatch) {\n            const oppositeHue = (Number(hslMatch[1]) + 180) % 360;\n            return `hsl(${oppositeHue}, ${hslMatch[2]}, ${hslMatch[3]})`;\n        }\n        return null;\n    }\n    getColorMap({ stepCount: stepCount, colorCount: colorCount }) {\n        if (!colorCount) throw new Error(\"Can't get color map, no colorCount provided!\");\n        const stepsPerColor = Math.floor(stepCount / colorCount);\n        const colorMap = new Map();\n        for(let i = 0; i < colorCount; i++)colorMap.set(i * stepsPerColor, this.getColor(i));\n        return colorMap;\n    }\n    static getConfig({ include: include, exclude: exclude, defaults: defaults = {}, customControls: customControls, propMapper: propMapper, groupLabel: groupLabel, maxColorCount: maxColorCount }) {\n        const controls = (0, $b103c63dc979d40c$export$d9fe7d5b8b296e7c)(getControls(), propMapper);\n        return {\n            key: 'colorGroup',\n            label: groupLabel ?? 'Color',\n            type: 'group',\n            children: [\n                ...customControls ?? [],\n                ...controls\n            ]\n        };\n        function getControls(controlsConfig) {\n            return (controlsConfig ?? (0, $b103c63dc979d40c$export$68091c7c829a57b8)((0, $9e482fa80a49eb9a$export$2e2bcd8739ae039))).filter(({ key: key })=>(!exclude || !exclude.includes(key)) && (!include || include.includes(key))).map((control)=>{\n                const finalControl = {\n                    ...control,\n                    defaultValue: defaults[control.key] ?? control.defaultValue\n                };\n                if (control.type === 'group') finalControl.children = getControls(control.children);\n                if (control.key === 'colorCount' && maxColorCount) finalControl.attr.max = maxColorCount;\n                return Object.freeze(finalControl);\n            });\n        }\n    }\n}\n\n\n\nconst $557ca0c92a954a23$var$NUMBER_MARGIN = 4;\nconst $557ca0c92a954a23$var$DEFAULT_OPTIONS = {\n    color: '#ffffff',\n    fontSize: 10,\n    radius: 1.5,\n    renderNumbers: false,\n    margin: $557ca0c92a954a23$var$NUMBER_MARGIN\n};\nclass $557ca0c92a954a23$export$2e2bcd8739ae039 {\n    nailRadius = $557ca0c92a954a23$var$DEFAULT_OPTIONS.radius;\n    nailsColor = $557ca0c92a954a23$var$DEFAULT_OPTIONS.color;\n    nailNumbersFontSize = $557ca0c92a954a23$var$DEFAULT_OPTIONS.fontSize;\n    nails;\n    addedPoints;\n    #nailGroups = [];\n    constructor(config){\n        this.setConfig(config);\n        this.nails = [];\n        this.addedPoints = new Set();\n    }\n    setConfig({ nailRadius: nailRadius, nailsColor: nailsColor, nailNumbersFontSize: nailNumbersFontSize }) {\n        this.nailRadius = nailRadius;\n        this.nailsColor = nailsColor;\n        this.nailNumbersFontSize = nailNumbersFontSize;\n        this.nails = [];\n        if (this.addedPoints) this.addedPoints.clear();\n    }\n    // Adds a nail to be rendered. nail: { point, number }\n    addNail(nail) {\n        const nailPoint = nail.point.map(Math.round).join('_');\n        if (!this.addedPoints.has(nailPoint)) {\n            this.nails.push(nail);\n            this.addedPoints.add(nailPoint);\n        }\n    }\n    addGroup(nails, options) {\n        this.#nailGroups.push({\n            nails: nails,\n            options: options\n        });\n    }\n    #render(renderer, nails, options) {\n        renderer.renderNails(nails, {\n            ...$557ca0c92a954a23$var$DEFAULT_OPTIONS,\n            ...options\n        });\n    }\n    draw(renderer, { drawNumbers: drawNumbers = true } = {}) {\n        const options = {\n            color: this.nailsColor,\n            fontSize: this.nailNumbersFontSize,\n            radius: this.nailRadius,\n            renderNumbers: drawNumbers\n        };\n        this.#render(renderer, this.nails, options);\n        this.nails = [];\n        this.addedPoints.clear();\n        this.#nailGroups.forEach(({ nails: groupNails, options: groupConfig })=>{\n            this.#render(renderer, groupNails, {\n                ...options,\n                ...groupConfig\n            });\n        });\n        this.#nailGroups = [];\n    }\n}\n\n\nconst $a64bacef9e98af6b$var$COLORS = {\n    dark: '#0e0e0e',\n    light: '#ffffff'\n};\nconst $a64bacef9e98af6b$var$COMMON_CONFIG_CONTROLS = [\n    {\n        key: 'strings',\n        label: 'Strings',\n        type: 'group',\n        defaultValue: 'minimized',\n        children: [\n            {\n                key: 'showStrings',\n                label: 'Show strings',\n                defaultValue: true,\n                type: 'checkbox',\n                isDisabled: ({ showNails: showNails })=>!showNails\n            },\n            {\n                key: 'stringWidth',\n                label: 'String width',\n                defaultValue: 1,\n                type: 'range',\n                attr: {\n                    min: 0.2,\n                    max: 4,\n                    step: 0.1,\n                    snap: '1'\n                },\n                show: ({ showStrings: showStrings })=>showStrings\n            }\n        ]\n    },\n    {\n        key: 'nails',\n        label: 'Nails',\n        type: 'group',\n        defaultValue: 'minimized',\n        children: [\n            {\n                key: 'showNails',\n                label: 'Show nails',\n                defaultValue: true,\n                type: 'checkbox',\n                isDisabled: ({ showStrings: showStrings })=>!showStrings\n            },\n            {\n                key: 'showNailNumbers',\n                label: 'Show nail numbers',\n                defaultValue: false,\n                type: 'checkbox',\n                show: ({ showNails: showNails })=>showNails\n            },\n            {\n                key: 'nailNumbersFontSize',\n                label: 'Nail numbers font size',\n                defaultValue: 10,\n                type: 'range',\n                attr: {\n                    min: 6,\n                    max: 24,\n                    step: 0.5\n                },\n                displayValue: ({ nailNumbersFontSize: nailNumbersFontSize })=>`${nailNumbersFontSize}px`,\n                show: ({ showNails: showNails, showNailNumbers: showNailNumbers })=>showNails && showNailNumbers\n            },\n            {\n                key: 'margin',\n                label: 'Margin',\n                defaultValue: 20,\n                type: 'number',\n                attr: {\n                    min: 0,\n                    max: 500,\n                    step: 1\n                },\n                displayValue: ({ margin: margin })=>`${margin}px`\n            },\n            {\n                key: 'nailRadius',\n                label: 'Nail size',\n                defaultValue: 1.5,\n                type: 'range',\n                attr: {\n                    min: 0.5,\n                    max: 5,\n                    step: 0.25,\n                    snap: '1.5'\n                },\n                show: ({ showNails: showNails })=>showNails\n            },\n            {\n                key: 'nailsColor',\n                label: 'Nails color',\n                defaultValue: '#ffffff',\n                type: 'color',\n                show: ({ showNails: showNails })=>showNails\n            }\n        ]\n    },\n    {\n        key: 'background',\n        label: 'Background',\n        type: 'group',\n        defaultValue: 'minimized',\n        children: [\n            {\n                key: 'darkMode',\n                label: 'Dark mode',\n                defaultValue: true,\n                type: 'checkbox',\n                isDisabled: ({ enableBackground: enableBackground })=>!enableBackground\n            },\n            {\n                key: 'customBackgroundColor',\n                label: 'Custom background color',\n                defaultValue: false,\n                type: 'checkbox',\n                isDisabled: ({ enableBackground: enableBackground })=>!enableBackground\n            },\n            {\n                key: 'backgroundColor',\n                label: 'Background color',\n                defaultValue: $a64bacef9e98af6b$var$COLORS.dark,\n                type: 'color',\n                show: ({ customBackgroundColor: customBackgroundColor })=>customBackgroundColor,\n                isDisabled: ({ enableBackground: enableBackground })=>!enableBackground\n            },\n            {\n                key: 'enableBackground',\n                label: 'Enable background',\n                defaultValue: true,\n                type: 'checkbox'\n            }\n        ]\n    }\n];\nclass $a64bacef9e98af6b$var$StringArt {\n    renderer;\n    controls = [];\n    defaultValues = {};\n    stepCount = null;\n    size = null;\n    center = null;\n    nails = null;\n    position = 0;\n    stringsIterator;\n    id;\n    name;\n    link;\n    linkText;\n    #config;\n    #controlsIndex;\n    #defaultConfig;\n    // TODO: Remove renderer from here, set it only in `draw`. Then StringArt can be instantiated independently of the renderer.\n    constructor(renderer){\n        this.renderer = renderer;\n    }\n    static thumbnailConfig;\n    static type;\n    getCommonControls() {\n        return $a64bacef9e98af6b$var$COMMON_CONFIG_CONTROLS;\n    }\n    get configControls() {\n        return (this.controls ?? []).concat(this.getCommonControls());\n    }\n    get controlsIndex() {\n        if (!this.#controlsIndex) this.#controlsIndex = (0, $b103c63dc979d40c$export$ab1c0bf676278196)(this.configControls);\n        return this.#controlsIndex;\n    }\n    get type() {\n        return this.constructor.type;\n    }\n    /**\n   * A pattern is considered a template if the id is the same as the type. These are built-in patterns.\n   */ get isTemplate() {\n        return this.type === this.id;\n    }\n    get defaultConfig() {\n        if (!this.#defaultConfig) this.#defaultConfig = Object.freeze(Object.assign((0, $b103c63dc979d40c$export$38c07eba5c3aa11b)(this.configControls), this.defaultValues));\n        return this.#defaultConfig;\n    }\n    get config() {\n        return this.#config ?? this.defaultConfig;\n    }\n    set config(value) {\n        this.#config = Object.assign({}, this.defaultConfig, value);\n    }\n    /**\n   * Assigns the partial config to the current configuration of the StringArt\n   * @param config\n   */ assignConfig(config) {\n        this.#config = Object.assign({}, this.config, config);\n    }\n    /**\n   * Sets the config of the StringArt and updates using `onConfigChange`\n   * @param config\n   */ setConfig(config) {\n        const currentConfig = this.config;\n        this.config = config;\n        if (this.onConfigChange) {\n            const changedControlKeys = Object.keys(currentConfig).filter((key)=>config[key] !== currentConfig[key]);\n            this.onConfigChange(changedControlKeys.map((key)=>({\n                    control: this.controlsIndex[key],\n                    value: config[key]\n                })));\n        }\n    }\n    /**\n   * Child classes can define this method to clear any structural cache when config values for `isStructural=true` controls change.\n   */ resetStructure() {}\n    onConfigChange(controls) {\n        if (controls.some(({ control: control })=>control.isStructural)) {\n            this.resetStructure();\n            if (this.stepCount != null && controls.some(({ control: control })=>control.affectsStepCount !== false)) this.stepCount = null;\n        }\n    }\n    onResize() {\n        this.resetStructure();\n    }\n    setConfigValue(controlKey, value) {\n        if (this.#config && this.#config[controlKey] === value) return;\n        this.#config = Object.freeze({\n            ...this.#config ?? this.defaultConfig,\n            [controlKey]: value\n        });\n        if (this.onConfigChange) this.onConfigChange([\n            {\n                control: this.controlsIndex[controlKey],\n                value: value\n            }\n        ].filter(({ control: control })=>!!control));\n    }\n    getSize() {\n        this.#withRenderer();\n        return this.renderer.getSize();\n    }\n    setUpDraw() {\n        this.#withRenderer();\n        const previousSize = this.size;\n        this.renderer.reset();\n        const [width, height] = this.size = this.getSize();\n        Object.assign(this, this.size);\n        this.center = this.size.map((value)=>value / 2);\n        if (previousSize && (previousSize[0] !== width || previousSize[1] !== height)) {\n            if (this.onResize) this.onResize();\n        }\n        if (this.nails) this.nails.setConfig(this.config);\n        else this.nails = new (0, $557ca0c92a954a23$export$2e2bcd8739ae039)(this.config);\n        this.renderer.setLineWidth(this.config.stringWidth);\n    }\n    afterDraw() {\n        this.#withRenderer();\n        const { showNails: showNails, showNailNumbers: showNailNumbers } = this.config;\n        if (showNails) {\n            this.drawNails();\n            this.nails.draw(this.renderer, {\n                drawNumbers: showNailNumbers\n            });\n        }\n    }\n    initDraw() {\n        this.#withRenderer();\n        this.setUpDraw();\n        const { showNails: showNails, showNailNumbers: showNailNumbers, darkMode: darkMode, backgroundColor: backgroundColor, customBackgroundColor: customBackgroundColor, enableBackground: enableBackground } = this.config;\n        if (enableBackground) this.renderer.setBackground(customBackgroundColor ? backgroundColor : darkMode ? $a64bacef9e98af6b$var$COLORS.dark : $a64bacef9e98af6b$var$COLORS.light);\n        if (showNails) {\n            this.drawNails();\n            this.nails.draw(this.renderer, {\n                drawNumbers: showNailNumbers\n            });\n        }\n    }\n    /**\n   * Draws the string art\n   * @param { step: number } renderConfig configuration for rendering. Accepts the step to render (leave undefined or null to render all)\n   */ draw({ position: position = Infinity } = {}) {\n        this.#withRenderer();\n        this.initDraw();\n        const { showStrings: showStrings } = this.config;\n        if (showStrings) {\n            this.stringsIterator = this.generateStrings();\n            this.position = 0;\n            while(!this.drawNext().done && this.position < position);\n            this.afterDraw();\n        }\n    }\n    goto(position) {\n        if (position === this.position) return;\n        if (this.stringsIterator && position > this.position) {\n            while(!this.drawNext().done && this.position < position);\n        } else this.draw({\n            position: position\n        });\n    }\n    /**\n   *\n   * @returns Advance the strings iterator by one. If the iterator is done, calls this.afterDraw().\n   */ drawNext() {\n        const result = this.stringsIterator.next();\n        if (result.done) this.afterDraw();\n        else this.position++;\n        return result;\n    }\n    #withRenderer() {\n        if (!this.renderer) throw new Error('Missing renderer for StringArt!');\n    }\n}\nvar $a64bacef9e98af6b$export$2e2bcd8739ae039 = $a64bacef9e98af6b$var$StringArt;\n\n\nconst $6e85582323150d4b$var$easing = {\n    linear: (x)=>x,\n    inOutCirc (x) {\n        return x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2;\n    },\n    easeOutQuint (x) {\n        return 1 - Math.pow(1 - x, 5);\n    },\n    fastSlowFast (t) {\n        // Clamp t to [0,1] just to be safe\n        t = Math.max(0, Math.min(1, t));\n        // Custom easing formula: accelerates, slows in middle, then accelerates again\n        return 0.5 * (1 - Math.cos(Math.PI * t)) ** 1.5;\n    },\n    fastInOutSquare (x) {\n        return x <= 0.5 ? (1 - Math.pow(1 - x * 2, 2)) / 2 : 0.5 + Math.pow(x * 2 - 1, 2) / 2;\n    },\n    fastInOutCubic (x) {\n        return x <= 0.5 ? (1 - Math.pow(1 - x * 2, 3)) / 2 : 0.5 + Math.pow(x * 2 - 1, 3) / 2;\n    },\n    fastInOutQuint (x) {\n        return x <= 0.5 ? (1 - Math.pow(1 - x * 2, 5)) / 2 : 0.5 + Math.pow(x * 2 - 1, 5) / 2;\n    },\n    fastInOut (pow, x) {\n        return x <= 0.5 ? (1 - Math.pow(1 - x * 2, pow)) / 2 : 0.5 + Math.pow(x * 2 - 1, pow) / 2;\n    },\n    fastInOutFixed (pow, fastArea, x) {\n        if (x > fastArea && x < 1 - fastArea) {\n            const y1 = (1 - Math.pow(1 - fastArea * 2, pow)) / 2;\n            const y2 = 0.5 + Math.pow((1 - fastArea) * 2 - 1, pow) / 2;\n            return y1 + (x - fastArea) * (y2 - y1) / (1 - 2 * fastArea);\n        }\n        return x <= fastArea ? (1 - Math.pow(1 - x * 2, pow)) / 2 : 0.5 + Math.pow(x * 2 - 1, pow) / 2;\n    }\n};\n$6e85582323150d4b$var$easing.fastInOut.requirePower = true;\n$6e85582323150d4b$var$easing.fastInOutFixed.requirePower = true;\n$6e85582323150d4b$var$easing.fastInOutFixed.requireFastArea = true;\nvar $6e85582323150d4b$export$2e2bcd8739ae039 = $6e85582323150d4b$var$easing;\n\n\n/**\n * Returns the greatest common divisor of two integers\n * https://en.wikipedia.org/wiki/Euclidean_algorithm\n * @param {number} int1\n * @param {number} int2\n * @returns number\n */ function $e2b746416d2bf62b$export$f81847884871263e(int1, int2) {\n    if (!int2) return int1;\n    return $e2b746416d2bf62b$export$f81847884871263e(int2, int1 % int2);\n}\nfunction $e2b746416d2bf62b$export$18c295d7a6a8189d(size1, size2) {\n    const ratio = Math.min(size2[0] / size1[0], size2[1] / size1[1]);\n    return size1.map((v)=>v * ratio);\n}\nconst $e2b746416d2bf62b$export$f4644083ce95e7e3 = Math.PI * 2;\n\n\n/**\n * Returns true if the two objects have the same values. Deep compares the objects.\n */ function $c29d66861308df7e$export$f05027632b38f3a4(obj1, obj2, /**\n   * An array of keys to compare. If not specified, all keys are compared.\n   */ props) {\n    if (obj1 === obj2) return true;\n    if (typeof obj1 === 'object' && typeof obj2 === 'object') {\n        if (obj1 === null !== (obj2 === null)) return false;\n        if (obj1 instanceof Array && obj2 instanceof Array) {\n            if (obj1.length !== obj2.length) return false;\n            for(let i = 0; i < obj1.length; i++){\n                if (!$c29d66861308df7e$export$f05027632b38f3a4(obj1[i], obj2[i])) return false;\n            }\n            return true;\n        }\n        if (!props) {\n            props = Object.keys(obj1);\n            if (props.length !== Object.keys(obj2).length) return false;\n        }\n        if (props && props.some((p)=>!$c29d66861308df7e$export$f05027632b38f3a4(obj1[p], obj2[p]))) return false;\n        return true;\n    }\n    return obj1 === obj2;\n}\nfunction $c29d66861308df7e$export$781522908e4e76a1(obj, mapper) {\n    const mappedObj = {};\n    Object.entries(obj).forEach(([key, value])=>mappedObj[mapper(key, value)] = value);\n    return mappedObj;\n}\n\n\nclass $dd4af12b0f1337d9$export$2e2bcd8739ae039 {\n    points;\n    easingFunction;\n    config;\n    center;\n    xyRadius;\n    rotationAngle = 0;\n    indexAngle;\n    isReverse = false;\n    radius;\n    arc = (0, $e2b746416d2bf62b$export$f4644083ce95e7e3);\n    isPartialArc = false;\n    excludedNailIndexes;\n    constructor(config){\n        this.setConfig(config);\n    }\n    getPoint(index = 0) {\n        const realIndex = this.getNailIndex(index);\n        if (this.points.has(index)) return this.points.get(index);\n        const angle = this.easingFunction(realIndex / (this.config.n - (this.isPartialArc ? 1 : 0))) * this.arc + this.rotationAngle + (this.config.angleStart ?? 0);\n        const point = [\n            this.center[0] + Math.sin(angle) * this.xyRadius[0],\n            this.center[1] + Math.cos(angle) * this.xyRadius[1]\n        ];\n        this.points.set(index, point);\n        return point;\n    }\n    getNailIndex(index = 0) {\n        let realIndex = this.isReverse ? this.config.n - 1 - index : index;\n        if (realIndex > this.config.n - 1) realIndex = realIndex % this.config.n;\n        return realIndex;\n    }\n    setConfig(config) {\n        if (!(0, $c29d66861308df7e$export$f05027632b38f3a4)(config, this.config)) {\n            const { n: n, size: size, margin: margin = 0, rotation: rotation = 0, center: configCenter, radius: radius, reverse: reverse = false, angleStart: angleStart, angleEnd: angleEnd } = config;\n            const center = configCenter ?? size.map((v)=>v / 2);\n            const clampedRadius = radius ?? Math.min(...center) - margin;\n            let xyRadius = [\n                clampedRadius,\n                clampedRadius\n            ];\n            if (config.distortion) {\n                const distortedBox = config.distortion < 0 ? [\n                    clampedRadius * (1 - Math.abs(config.distortion)),\n                    clampedRadius\n                ] : [\n                    clampedRadius / (1 - config.distortion),\n                    clampedRadius\n                ];\n                xyRadius = (0, $e2b746416d2bf62b$export$18c295d7a6a8189d)(distortedBox, center.map((v)=>v - margin));\n            }\n            // Normally, the whole circle is rendered, but if angleStart and angleEnd are configured and valid, and arc between them is rendered:\n            this.isPartialArc = angleStart && angleEnd && angleEnd > angleStart;\n            const arc = this.isPartialArc ? angleEnd - angleStart : (0, $e2b746416d2bf62b$export$f4644083ce95e7e3);\n            const props = {\n                center: center,\n                radius: clampedRadius,\n                xyRadius: xyRadius,\n                indexAngle: arc / (this.isPartialArc ? n - 1 : n),\n                rotationAngle: -(0, $e2b746416d2bf62b$export$f4644083ce95e7e3) * rotation,\n                isReverse: reverse,\n                arc: arc\n            };\n            const easingFunction = config.displacementFunc ? (0, $6e85582323150d4b$export$2e2bcd8739ae039)[config.displacementFunc] : (0, $6e85582323150d4b$export$2e2bcd8739ae039).linear;\n            const easingParams = [];\n            if (easingFunction.requirePower) easingParams.push(config.displacementMag);\n            if (easingFunction.requireFastArea) easingParams.push(config.displacementFastArea);\n            const easingFunctionWithParams = easingParams.length ? easingFunction.bind(null, ...easingParams) : easingFunction;\n            this.easingFunction = easingFunctionWithParams;\n            this.config = config;\n            Object.assign(this, props);\n            if (this.points) this.points.clear();\n            else this.points = new Map();\n        }\n    }\n    *generateNails({ nailsNumberStart: nailsNumberStart = 0, getNumber: getNumber, excludedNailRanges: excludedNailRanges } = {}) {\n        const { n: n } = this.config;\n        let excludedNailIndexes;\n        if (excludedNailRanges) {\n            excludedNailIndexes = new Set();\n            excludedNailRanges.forEach(([start, end])=>{\n                const max = Math.min(end, n);\n                for(let i = Math.max(0, start); i <= max; i++)excludedNailIndexes.add(i);\n            });\n        }\n        let i = 0;\n        let j = 0;\n        while(j < this.config.n){\n            if (!excludedNailIndexes?.has(j)) {\n                yield {\n                    point: this.getPoint(j),\n                    number: getNumber ? getNumber(i) : i + nailsNumberStart\n                };\n                i++;\n            }\n            j++;\n        }\n    }\n    /**\n   * Given a Nails instance, uses it to draw the nails of this Circle\n   * @param {Nails} nails\n   * @param {{nailsNumberStart?: number, getNumber?: Function}} param1\n   */ drawNails(nails, props = {}) {\n        const arr = [];\n        const { color: color, ...restProps } = props;\n        for (const nail of this.generateNails(restProps))arr.push(nail);\n        nails.addGroup(arr, {\n            color: color\n        });\n    }\n    *drawRing(renderer, { ringSize: ringSize, color: color }) {\n        const { n: n } = this.config;\n        const ringDistance = Math.floor(ringSize * n);\n        let prevPoint;\n        let prevPointIndex = 0;\n        let isPrevSide = false;\n        renderer.setColor(color);\n        for(let i = 0; i < n; i++){\n            if (!prevPoint) prevPoint = this.getPoint(0);\n            const startPoint = prevPoint;\n            const positions = [];\n            prevPointIndex = isPrevSide ? i : prevPointIndex + ringDistance;\n            prevPoint = this.getPoint(prevPointIndex);\n            positions.push(prevPoint);\n            if (i < n - 1) {\n                prevPointIndex++;\n                prevPoint = this.getPoint(prevPointIndex);\n                positions.push(prevPoint);\n            }\n            renderer.renderLines(startPoint, ...positions);\n            yield;\n            isPrevSide = !isPrevSide;\n        }\n    }\n    static rotationConfig = {\n        key: 'rotation',\n        label: 'Rotation',\n        defaultValue: 0,\n        type: 'range',\n        attr: {\n            min: 0,\n            max: 1 + 1 / 360,\n            step: 1 / 360,\n            snap: '0.25, 0.5, 0.75'\n        },\n        displayValue: ({ rotation: rotation })=>`${Math.round(rotation * 360)}\\xb0`,\n        isStructural: true,\n        affectsStepCount: false\n    };\n    static nailsConfig = Object.freeze({\n        key: 'n',\n        label: 'Number of nails',\n        defaultValue: 144,\n        type: 'range',\n        attr: {\n            min: 3,\n            max: 300,\n            step: 1\n        },\n        isStructural: true\n    });\n    static displacementConfig = {\n        key: 'displacement',\n        label: 'Displacement',\n        type: 'group',\n        children: [\n            {\n                key: 'displacementFunc',\n                label: 'Displacement function',\n                defaultValue: 'linear',\n                type: 'select',\n                options: Object.keys((0, $6e85582323150d4b$export$2e2bcd8739ae039)),\n                isStructural: true,\n                affectsStepCount: false\n            },\n            {\n                key: 'displacementMag',\n                label: 'Displacement magnitude',\n                defaultValue: 3,\n                type: 'range',\n                attr: {\n                    min: 0,\n                    max: 10,\n                    step: 0.1\n                },\n                show: ({ displacementFunc: displacementFunc })=>(0, $6e85582323150d4b$export$2e2bcd8739ae039)[displacementFunc].requirePower,\n                isStructural: true,\n                affectsStepCount: false\n            },\n            {\n                key: 'displacementFastArea',\n                label: 'Displacement fast area',\n                defaultValue: 0.4,\n                type: 'range',\n                attr: {\n                    min: 0,\n                    max: 0.5,\n                    step: 0.01\n                },\n                show: ({ displacementFunc: displacementFunc })=>(0, $6e85582323150d4b$export$2e2bcd8739ae039)[displacementFunc].requireFastArea,\n                isStructural: true,\n                affectsStepCount: false\n            }\n        ]\n    };\n    static distortionConfig = {\n        key: 'distortion',\n        label: 'Distortion',\n        defaultValue: 0,\n        type: 'range',\n        attr: {\n            min: -0.99,\n            max: 0.99,\n            step: 0.01,\n            snap: '0'\n        },\n        isStructural: true,\n        affectsStepCount: false\n    };\n}\n\n\nconst $44064e6908c034c2$var$COLOR_CONFIG = (0, $44d9dab6555abf73$export$2e2bcd8739ae039).getConfig({\n    defaults: {\n        isMultiColor: true,\n        colorCount: 7,\n        color: '#ffbb29',\n        multicolorRange: 21,\n        multicolorStart: 32,\n        multicolorByLightness: true,\n        minLightness: 36,\n        maxLightness: 98\n    }\n});\nclass $44064e6908c034c2$export$2e2bcd8739ae039 extends (0, $a64bacef9e98af6b$export$2e2bcd8739ae039) {\n    static type = 'spiral';\n    id = 'spiral';\n    name = 'Spiral';\n    link = 'https://www.etsy.com/il-en/listing/840974781/boho-wall-decor-artwork-spiral-round';\n    controls = [\n        {\n            ...(0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).nailsConfig,\n            defaultValue: 200\n        },\n        {\n            key: 'repetition',\n            label: 'Repetition',\n            defaultValue: 5,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 20,\n                step: 1\n            }\n        },\n        {\n            key: 'innerLength',\n            label: 'Spiral thickness',\n            defaultValue: 0.5,\n            type: 'range',\n            attr: {\n                min: ({ n: n })=>1 / n,\n                max: 1,\n                step: ({ n: n })=>1 / n\n            },\n            displayValue: ({ n: n, innerLength: innerLength })=>Math.round(n * innerLength)\n        },\n        {\n            ...(0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).rotationConfig,\n            defaultValue: 0.75\n        },\n        (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).distortionConfig,\n        $44064e6908c034c2$var$COLOR_CONFIG\n    ];\n    #realRepetition;\n    #circle;\n    #color;\n    #colorMap;\n    setUpDraw() {\n        super.setUpDraw();\n        const { n: n, rotation: rotation, margin: margin, colorCount: colorCount, repetition: repetition, distortion: distortion } = this.config;\n        this.#realRepetition = repetition * 2 - 1;\n        const circleConfig = {\n            size: this.size,\n            n: n,\n            margin: margin,\n            rotation: rotation,\n            distortion: distortion\n        };\n        if (this.#circle) this.#circle.setConfig(circleConfig);\n        else this.#circle = new (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039)(circleConfig);\n        this.#color = new (0, $44d9dab6555abf73$export$2e2bcd8739ae039)({\n            ...this.config,\n            colorCount: colorCount\n        });\n        if (colorCount) this.#colorMap = this.#color.getColorMap({\n            stepCount: this.getStepCount(),\n            colorCount: colorCount\n        });\n    }\n    *drawSpiral({ shift: shift = 0, color: color = '#ffffff' } = {}) {\n        const { innerLength: innerLength, n: n } = this.config;\n        let currentInnerLength = Math.round(innerLength * n);\n        let repetitionCount = 0;\n        this.renderer.setColor(color);\n        let prevPointIndex = shift;\n        let prevPoint = this.#circle.getPoint(prevPointIndex);\n        let isPrevPoint = false;\n        for(let i = 0; currentInnerLength > 0; i++){\n            if (this.#colorMap) {\n                const stepColor = this.#colorMap.get(i);\n                if (stepColor) this.renderer.setColor(stepColor);\n            }\n            prevPointIndex = isPrevPoint ? prevPointIndex - currentInnerLength + 1 : prevPointIndex + currentInnerLength;\n            if (repetitionCount === this.#realRepetition) {\n                currentInnerLength--;\n                repetitionCount = 0;\n                prevPointIndex++;\n            } else repetitionCount++;\n            const nextPoint = this.#circle.getPoint(prevPointIndex);\n            this.renderer.renderLines(prevPoint, nextPoint);\n            prevPoint = nextPoint;\n            yield;\n            isPrevPoint = !isPrevPoint;\n        }\n    }\n    *generateStrings() {\n        yield* this.drawSpiral({\n            color: this.#color.getColor(0)\n        });\n    }\n    getStepCount() {\n        const { innerLength: innerLength, repetition: repetition, n: n } = this.config;\n        return Math.round(n * (innerLength * 2) * repetition);\n    }\n    drawNails() {\n        this.#circle.drawNails(this.nails);\n    }\n    static thumbnailConfig = {\n        n: 60\n    };\n}\n\n\n\n\n\n\nclass $63660c6a2fc9a003$var$Spirals extends (0, $a64bacef9e98af6b$export$2e2bcd8739ae039) {\n    static type = 'spirals';\n    name = 'Spirals';\n    id = 'spirals';\n    link = 'https://www.etsy.com/il-en/listing/974865185/3d-string-art-spiral-mandala-wall?ref=shop_home_active_10&frs=1';\n    controls = [\n        {\n            key: 'radiusIncrease',\n            label: 'Radius change',\n            defaultValue: 5.7,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 20,\n                step: 0.1\n            }\n        },\n        {\n            key: 'angleStep',\n            label: 'Angle step',\n            defaultValue: 0.45,\n            type: 'range',\n            attr: {\n                min: 0,\n                max: 1,\n                step: 0.01\n            }\n        },\n        {\n            key: 'nSpirals',\n            label: 'Number of spirals',\n            defaultValue: 3,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 20,\n                step: 1\n            }\n        },\n        {\n            ...(0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).rotationConfig,\n            defaultValue: 330 / 360\n        },\n        (0, $44d9dab6555abf73$export$2e2bcd8739ae039).getConfig({\n            defaults: {\n                isMultiColor: true,\n                colorCount: 4,\n                color: '#00d5ff',\n                multicolorRange: 1,\n                multicolorStart: 190,\n                multicolorByLightness: true,\n                minLightness: 50,\n                maxLightness: 88,\n                reverseColors: true\n            }\n        })\n    ];\n    calc;\n    color;\n    colorMap;\n    getCalc() {\n        const { nSpirals: nSpirals, rotation: rotation, margin: margin, radiusIncrease: radiusIncrease, angleStep: angleStep } = this.config;\n        const maxRadius = Math.min(...this.size) / 2 - margin;\n        return {\n            spiralRotations: new Array(nSpirals).fill(null).map((_, i)=>i * (0, $e2b746416d2bf62b$export$f4644083ce95e7e3) / nSpirals),\n            rotationAngle: -(0, $e2b746416d2bf62b$export$f4644083ce95e7e3) * rotation,\n            nailsPerSpiral: Math.floor(maxRadius / radiusIncrease),\n            angleIncrease: angleStep / (maxRadius / 50)\n        };\n    }\n    setUpDraw() {\n        super.setUpDraw();\n        const { colorCount: colorCount } = this.config;\n        this.calc = this.getCalc();\n        this.color = new (0, $44d9dab6555abf73$export$2e2bcd8739ae039)(this.config);\n        this.colorMap = this.color.getColorMap({\n            stepCount: this.getStepCount(),\n            colorCount: colorCount\n        });\n    }\n    *generatePoints() {\n        const { nSpirals: nSpirals } = this.config;\n        for(let i = 0; i < this.calc.nailsPerSpiral; i++)for(let s = 0; s < nSpirals; s++){\n            const point = this.getPoint(s, i);\n            yield {\n                point: point,\n                nailNumber: `${s}_${i}`\n            };\n        }\n    }\n    getPoint(spiralIndex, index) {\n        const [centerx, centery] = this.center;\n        const { radiusIncrease: radiusIncrease } = this.config;\n        const angle = this.calc.rotationAngle + this.calc.angleIncrease * index + this.calc.spiralRotations[spiralIndex];\n        const radius = index * radiusIncrease;\n        return [\n            centerx + radius * Math.sin(angle),\n            centery + radius * Math.cos(angle)\n        ];\n    }\n    *generateStrings() {\n        const points = this.generatePoints();\n        let index = 0;\n        this.renderer.setColor(this.color.getColor(0));\n        let lastPoint = this.center;\n        for (const { point: point } of points){\n            if (this.colorMap) {\n                const stepColor = this.colorMap.get(index);\n                if (stepColor) this.renderer.setColor(stepColor);\n            }\n            if (lastPoint) this.renderer.renderLines(lastPoint, point);\n            lastPoint = point;\n            index++;\n            yield;\n        }\n    }\n    getStepCount() {\n        const { nSpirals: nSpirals, radiusIncrease: radiusIncrease, margin: margin } = this.config;\n        const maxRadius = Math.min(...this.getSize()) / 2 - margin;\n        const n = Math.floor(maxRadius / radiusIncrease);\n        return n * nSpirals;\n    }\n    drawNails() {\n        const points = this.generatePoints();\n        for (const { point: point, nailNumber: nailNumber } of points)this.nails.addNail({\n            point: point,\n            number: nailNumber\n        });\n    }\n    static thumbnailConfig = {\n        radiusIncrease: 1.4,\n        angleStep: 0.11\n    };\n}\nvar $63660c6a2fc9a003$export$2e2bcd8739ae039 = $63660c6a2fc9a003$var$Spirals;\n\n\n\n\n\n\n\nclass $ad2ceb60c48a58dd$export$2e2bcd8739ae039 extends (0, $a64bacef9e98af6b$export$2e2bcd8739ae039) {\n    static type = 'mandala';\n    name = 'Mandala';\n    id = 'mandala';\n    link = 'https://www.youtube.com/watch?v=qhbuKbxJsk8';\n    linkText = 'Learn';\n    controls = [\n        {\n            key: 'n',\n            label: 'Number of nails',\n            defaultValue: 180,\n            type: 'range',\n            attr: {\n                min: 3,\n                max: 240,\n                step: 1\n            }\n        },\n        {\n            key: 'base',\n            label: 'Multiplication',\n            defaultValue: 2,\n            type: 'range',\n            attr: {\n                min: 2,\n                max: 99,\n                step: 1\n            }\n        },\n        {\n            key: 'layers',\n            label: 'Layers',\n            defaultValue: 7,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 20,\n                step: 1\n            }\n        },\n        (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).rotationConfig,\n        (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).distortionConfig,\n        (0, $44d9dab6555abf73$export$2e2bcd8739ae039).getConfig({\n            defaults: {\n                isMultiColor: true,\n                multicolorRange: 165,\n                multicolorStart: 256,\n                color: '#ff4d00'\n            },\n            exclude: [\n                'colorCount'\n            ]\n        })\n    ];\n    circle;\n    color;\n    calc;\n    get n() {\n        return this.calc.n;\n    }\n    getCalc() {\n        const { n: nConfig, layers: layers, layerFill: layerFill } = this.config;\n        const extraNails = nConfig % layers;\n        const n = nConfig - extraNails; // The number of nails should be a multiple of the layers, so the strings are exactly on the nails.\n        return {\n            n: n,\n            stringsPerLayer: layerFill ? Math.floor(n * layerFill) : n,\n            layerShift: Math.floor(n / layers)\n        };\n    }\n    setUpDraw() {\n        super.setUpDraw();\n        const { layers: layers, rotation: rotation, distortion: distortion, margin: margin, layerFill: layerFill, base: base, reverse: reverse } = this.config;\n        this.calc = this.getCalc();\n        const circleConfig = {\n            size: this.size,\n            n: this.n,\n            margin: margin,\n            rotation: rotation,\n            distortion: distortion,\n            reverse: reverse\n        };\n        if (this.circle) this.circle.setConfig(circleConfig);\n        else this.circle = new (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039)(circleConfig);\n        this.color = new (0, $44d9dab6555abf73$export$2e2bcd8739ae039)({\n            ...this.config,\n            colorCount: layers\n        });\n    }\n    *drawTimesTable(layerIndex) {\n        const { reverse: reverse, base: base } = this.config;\n        const { n: n, layerShift: layerShift, stringsPerLayer: stringsPerLayer } = this.calc;\n        const shift = layerShift * layerIndex * (reverse ? 1 : -1);\n        const color = this.color.getColor(layerIndex);\n        this.renderer.setColor(color);\n        let point = this.circle.getPoint(shift);\n        for(let i = 1; i <= stringsPerLayer; i++){\n            const startPoint = point;\n            point = this.circle.getPoint(i + shift);\n            const toIndex = i * base % n;\n            this.renderer.renderLines(startPoint, point, this.circle.getPoint(toIndex + shift));\n            yield;\n        }\n    }\n    *generateStrings() {\n        const { layers: layers } = this.config;\n        for(let layer = 0; layer < layers; layer++)yield* this.drawTimesTable(layer);\n    }\n    drawNails() {\n        this.circle.drawNails(this.nails);\n    }\n    getStepCount() {\n        const { layers: layers, layerFill: layerFill } = this.config;\n        const { n: n } = this.getCalc();\n        const stringsPerLayer = layerFill ? Math.floor(n * layerFill) : n;\n        return (layers ?? 1) * stringsPerLayer;\n    }\n    static thumbnailConfig = {\n        n: 70\n    };\n}\n\n\nfunction $96d8651f67c6b219$export$f481ea230fad194b(value) {\n    return `${Math.round(value * 100)}%`;\n}\n\n\nclass $33e9badd1f194d7c$export$2e2bcd8739ae039 extends (0, $ad2ceb60c48a58dd$export$2e2bcd8739ae039) {\n    static type = 'wave';\n    id = 'wave';\n    name = 'Wave';\n    link = 'https://www.etsy.com/il-en/listing/943140543/personalized-gift-string-art-mandala?ref=sim_rv-5&pro=1';\n    controls = [\n        {\n            ...(0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).nailsConfig,\n            defaultValue: 200\n        },\n        {\n            key: 'layerFill',\n            label: 'Layer fill',\n            defaultValue: 0.5,\n            type: 'range',\n            attr: {\n                min: ({ n: n })=>1 / n,\n                max: 1,\n                step: ({ n: n })=>1 / n\n            },\n            displayValue: ({ layerFill: layerFill })=>(0, $96d8651f67c6b219$export$f481ea230fad194b)(layerFill)\n        },\n        {\n            ...(0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).rotationConfig,\n            defaultValue: 176 / 360\n        },\n        (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).distortionConfig,\n        {\n            key: 'layers',\n            label: 'Layers',\n            defaultValue: 11,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 20,\n                step: 1\n            }\n        },\n        {\n            key: 'layerSpread',\n            label: 'Layer spread',\n            defaultValue: 0.075,\n            type: 'range',\n            attr: {\n                min: 0,\n                max: 1,\n                step: ({ n: n })=>1 / n\n            },\n            displayValue: ({ layerSpread: layerSpread, n: n })=>Math.round(layerSpread * n)\n        },\n        {\n            key: 'reverse',\n            label: 'Reverse',\n            defaultValue: true,\n            type: 'checkbox'\n        },\n        (0, $44d9dab6555abf73$export$2e2bcd8739ae039).getConfig({\n            defaults: {\n                isMultiColor: true,\n                multicolorRange: 196,\n                multicolorStart: 273,\n                color: '#ffffff',\n                multicolorByLightness: true,\n                minLightness: 10,\n                maxLightness: 90\n            },\n            exclude: [\n                'colorCount'\n            ]\n        })\n    ];\n    defaultValues = {\n        base: 2\n    };\n    setUpDraw() {\n        super.setUpDraw();\n        const { n: n, layerSpread: layerSpread } = this.config;\n        this.calc.layerShift = Math.round(n * layerSpread);\n    }\n    *generateStrings() {\n        const { layers: layers } = this.config;\n        for(let layer = 0; layer < layers; layer++)yield* this.drawTimesTable(layer);\n    }\n    static thumbnailConfig = {\n        n: 70\n    };\n}\n\n\n\n\nconst $aa2c32cdcace5ae2$var$SIDES = [\n    'left',\n    'bottom',\n    'right',\n    'top'\n];\nconst $aa2c32cdcace5ae2$var$SIDES_ORDER = [\n    'left',\n    'bottom',\n    'right',\n    'top'\n];\nconst $aa2c32cdcace5ae2$var$SIDES_ROTATION = {\n    left: 0,\n    bottom: Math.PI / 2,\n    right: Math.PI,\n    top: Math.PI * 1.5\n};\nclass $aa2c32cdcace5ae2$var$Eye extends (0, $a64bacef9e98af6b$export$2e2bcd8739ae039) {\n    static type = 'eye';\n    name = 'Eye';\n    id = 'eye';\n    link = 'https://www.etsy.com/listing/489853161/rose-of-space-string-art-sacred-geometry?ga_order=most_relevant&ga_search_type=all&ga_view_type=gallery&ga_search_query=string+art&ref=sr_gallery_1&epik=dj0yJnU9WXNpM1BDTnNkLVBtcWdCa3AxN1J5QUZRY1FlbkJ5Z18mcD0wJm49ZXdJb2JXZmVpNVVwN1NKQ3lXMy10ZyZ0PUFBQUFBR0ZuUzZv';\n    controls = [\n        {\n            key: 'n',\n            label: 'Number of nails per side',\n            defaultValue: 82,\n            type: 'range',\n            attr: {\n                min: 2,\n                max: 200,\n                step: 1\n            }\n        },\n        {\n            key: 'layers',\n            label: 'Layers',\n            defaultValue: 13,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 20,\n                step: 1\n            }\n        },\n        {\n            key: 'angle',\n            label: 'Layer angle',\n            defaultValue: 30,\n            displayValue: ({ angle: angle })=>`${angle}\\xb0`,\n            type: 'range',\n            attr: {\n                min: 0,\n                max: 45,\n                step: 1\n            }\n        },\n        (0, $44d9dab6555abf73$export$2e2bcd8739ae039).getConfig({\n            defaults: {\n                isMultiColor: true,\n                color: '#ffffff',\n                multicolorRange: 107,\n                multicolorStart: 226,\n                multicolorByLightness: false,\n                minLightness: 40,\n                maxLightness: 50,\n                colorCount: 2\n            },\n            customControls: [\n                {\n                    key: 'colorPerLayer',\n                    label: 'Color per layer',\n                    defaultValue: false,\n                    type: 'checkbox',\n                    show: ({ isMultiColor: isMultiColor })=>isMultiColor\n                }\n            ],\n            exclude: [\n                'colorCount',\n                'repeatColors'\n            ]\n        })\n    ];\n    defaultValues = {\n        nailsColor: '#000000'\n    };\n    #calc;\n    color;\n    getCalc() {\n        const { n: n, angle: angle, layers: layers, margin: margin } = this.config;\n        const maxSize = Math.min(...this.size) - 2 * margin;\n        const nailSpacing = maxSize / (n - 1);\n        const layerAngle = angle * Math.PI / 180;\n        const getLayerProps = (layerIndex)=>{\n            const layerSize = maxSize / Math.pow(Math.cos(layerAngle) + Math.sin(layerAngle), layerIndex);\n            const layerStart = [\n                this.center[0] - layerSize / 2,\n                this.center[1] - layerSize / 2\n            ];\n            const layerStringCount = Math.floor(layerSize / nailSpacing);\n            return {\n                layerAngle: layerAngle * layerIndex,\n                layerSize: layerSize,\n                layerStart: layerStart,\n                layerStringCount: layerStringCount\n            };\n        };\n        return {\n            maxSize: maxSize,\n            nailSpacing: nailSpacing,\n            layerAngle: layerAngle,\n            layers: new Array(layers).fill(null).map((_, layerIndex)=>getLayerProps(layerIndex))\n        };\n    }\n    setUpDraw() {\n        super.setUpDraw();\n        this.color = new (0, $44d9dab6555abf73$export$2e2bcd8739ae039)({\n            ...this.config,\n            repeatColors: true,\n            colorCount: 2\n        });\n        this.#calc = this.getCalc();\n    }\n    // Sides: top, right, bottom, left\n    getPoint({ index: index, angle: angle, layerStart: layerStart, rotation: rotation }) {\n        const theta = angle + rotation;\n        const point = [\n            layerStart[0],\n            layerStart[1] + this.#calc.nailSpacing * index\n        ];\n        const pivot = this.center;\n        const cosAngle = Math.cos(theta);\n        const sinAngle = Math.sin(theta);\n        return [\n            cosAngle * (point[0] - pivot[0]) - sinAngle * (point[1] - pivot[1]) + pivot[0],\n            sinAngle * (point[0] - pivot[0]) + cosAngle * (point[1] - pivot[1]) + pivot[1]\n        ];\n    }\n    *drawSide({ side: side, color: color = '#ffffff', angle: angle, size: size, layerStart: layerStart, layerStringCount: layerStringCount }) {\n        const sideIndex = $aa2c32cdcace5ae2$var$SIDES.indexOf(side);\n        const nextSide = $aa2c32cdcace5ae2$var$SIDES[sideIndex === $aa2c32cdcace5ae2$var$SIDES.length - 1 ? 0 : sideIndex + 1];\n        const rotation = $aa2c32cdcace5ae2$var$SIDES_ROTATION[side];\n        const nextSideRotation = $aa2c32cdcace5ae2$var$SIDES_ROTATION[nextSide];\n        const sideProps = {\n            layerStringCount: layerStringCount,\n            size: size,\n            layerStart: layerStart,\n            angle: angle\n        };\n        this.renderer.setColor(color);\n        for(let i = 0; i <= layerStringCount; i++){\n            this.renderer.renderLines(this.getPoint({\n                index: i,\n                rotation: rotation,\n                ...sideProps\n            }), this.getPoint({\n                index: i,\n                rotation: nextSideRotation,\n                ...sideProps\n            }));\n            yield;\n        }\n    }\n    *drawLayer(layerIndex) {\n        const { colorPerLayer: colorPerLayer } = this.config;\n        const { layerAngle: layerAngle, layerSize: layerSize, layerStart: layerStart, layerStringCount: layerStringCount } = this.#calc.layers[layerIndex];\n        for(let i = 0; i < $aa2c32cdcace5ae2$var$SIDES.length; i++)yield* this.drawSide({\n            color: this.color.getColor(colorPerLayer ? layerIndex : i),\n            side: $aa2c32cdcace5ae2$var$SIDES_ORDER[i],\n            angle: layerAngle,\n            size: layerSize,\n            layerStart: layerStart,\n            layerStringCount: layerStringCount\n        });\n    }\n    *generateStrings() {\n        const { layers: layers } = this.config;\n        for(let layer = layers - 1; layer >= 0; layer--)yield* this.drawLayer(layer);\n    }\n    getStepCount() {\n        let count = 0;\n        const { layers: layers, angle: angle, n: n, margin: margin } = this.config;\n        const layerAngle = angle * Math.PI / 180;\n        const maxSize = Math.min(...this.renderer.getSize()) - 2 * margin;\n        const nailSpacing = maxSize / (n - 1);\n        for(let layer = 0; layer < layers; layer++){\n            const layerSize = maxSize / Math.pow(Math.cos(layerAngle) + Math.sin(layerAngle), layer);\n            count += 4 * (Math.floor(layerSize / nailSpacing) + 1);\n        }\n        return count;\n    }\n    drawNails() {\n        const { layers: layers } = this.config;\n        for(let layer = layers - 1; layer >= 0; layer--){\n            const { layerAngle: angle, layerSize: size, layerStart: layerStart, layerStringCount: layerStringCount } = this.#calc.layers[layer];\n            for(let s = 0; s < $aa2c32cdcace5ae2$var$SIDES.length; s++){\n                const sideOrder = $aa2c32cdcace5ae2$var$SIDES_ORDER[s];\n                const rotation = $aa2c32cdcace5ae2$var$SIDES_ROTATION[sideOrder];\n                for(let i = 0; i <= layerStringCount; i++){\n                    const sideProps = {\n                        layerStringCount: layerStringCount,\n                        size: size,\n                        layerStart: layerStart,\n                        angle: angle\n                    };\n                    this.nails.addNail({\n                        point: this.getPoint({\n                            index: i,\n                            rotation: rotation,\n                            ...sideProps\n                        }),\n                        number: `${layer}_${s}_${i}`\n                    });\n                }\n            }\n        }\n    }\n    static thumbnailConfig = {\n        n: 25,\n        layers: 7\n    };\n}\nvar $aa2c32cdcace5ae2$export$2e2bcd8739ae039 = $aa2c32cdcace5ae2$var$Eye;\n\n\n\n\n\n\n\nclass $2e2273f8da969026$export$2e2bcd8739ae039 {\n    config;\n    center;\n    calc;\n    constructor(config){\n        this.setConfig(config);\n    }\n    static getCalc({ radius: radius, sides: sides, sideNails: sideNails, rotation: rotation, centerRadius: centerRadiusFraction = 0, maxCurveSize: maxCurveSize = 1 }) {\n        const centerRadius = radius * centerRadiusFraction;\n        const nailSpacing = (radius - centerRadius) / (sideNails - 1); // The distance between nails on the same side, in px\n        const sidesAngle = Math.PI * 2 / sides; // The angle, in radians, between each side\n        const rotationAngle = rotation ? -Math.PI * 2 * rotation / sides : 0;\n        return {\n            sideAngle: sidesAngle,\n            nailSpacing: nailSpacing,\n            centerRadius: centerRadius,\n            linesPerRound: sides % 2 ? sides * 2 : sides,\n            sidesConnectionCount: Math.floor(Math.min(1, maxCurveSize) * sideNails),\n            sideSize: radius - centerRadius,\n            sides: new Array(sides).fill(null).map((_, side)=>{\n                const sideAngle = side * sidesAngle + rotationAngle;\n                return {\n                    sinSideAngle: Math.sin(sideAngle),\n                    cosSideAngle: Math.cos(sideAngle)\n                };\n            })\n        };\n    }\n    getPoint(side = 0, index = 0) {\n        const radius = this.calc.centerRadius + index * this.calc.nailSpacing;\n        const { sinSideAngle: sinSideAngle, cosSideAngle: cosSideAngle } = this.calc.sides[side];\n        return [\n            this.center[0] + sinSideAngle * radius,\n            this.center[1] + cosSideAngle * radius\n        ];\n    }\n    setConfig(config) {\n        if ((0, $c29d66861308df7e$export$f05027632b38f3a4)(config, this.config, [\n            'radius',\n            'sides',\n            'sideNails',\n            'rotation',\n            'center',\n            'size',\n            'centerRadius',\n            'maxCurveSize'\n        ])) return;\n        const center = config.center ?? config.size.map((v)=>v / 2);\n        this.config = config;\n        this.center = center;\n        this.calc = $2e2273f8da969026$export$2e2bcd8739ae039.getCalc(config);\n    }\n    /**\n   * Given a Nails instance, uses it to draw the nails of this Circle\n   */ drawNails(nails, { getNumber: getNumber, reverseOrder: reverseOrder, ...nailsConfig } = {}) {\n        const { sides: sides, sideNails: sideNails } = this.config;\n        const groupNails = [];\n        for(let side = 0; side < sides; side++)for(let i = 0; i < sideNails; i++){\n            const sideIndex = reverseOrder ? sideNails - i : i;\n            groupNails.push({\n                point: this.getPoint(side, sideIndex),\n                number: getNumber ? getNumber(side, sideIndex) : sideIndex || this.config.centerRadius ? `${side}_${sideIndex}` : 0\n            });\n        }\n        nails.addGroup(groupNails, nailsConfig);\n    }\n    // In this pattern, strings are connected in a \"merry-go-round\" way, around the star.\n    // With even sides count, the strings go around the star once, while with odd sides count, each round goes twice around the star.\n    // The threading is: star at the center (or centerRadius, if > 0), then next side at the edge (outtermost nail) or the size param which represents the count of nails to use,\n    // then back to the center for the next side,   // until all sides have been connected both center and edge (for odd-side-count stars) or until all sides have been\n    // connected (for odd-side-count), then move up one nail from the center and start another round.\n    *generateStrings(renderer, { size: size } = {}) {\n        const { sideNails: sideNailsConfig, sides: sides } = this.config;\n        const { sidesConnectionCount: sidesConnectionCount, linesPerRound: linesPerRound } = this.calc;\n        const sideNails = size ? Math.max(1, Math.min(Math.floor(size), sideNailsConfig)) : sideNailsConfig;\n        const minNailIndex = Math.max(0, sideNails - sidesConnectionCount);\n        let alternate = false;\n        const rounds = sides % 2 ? Math.ceil(Math.min(sideNails, sidesConnectionCount) / 2) : sideNails - minNailIndex;\n        let prevPointIndex = minNailIndex;\n        let prevPoint = this.getPoint(0, prevPointIndex);\n        for(let round = 0; round < rounds; round++){\n            const isLastRound = round === rounds - 1;\n            let side = 0;\n            for(let i = 0; i < linesPerRound; i++){\n                side = (side + 1) % sides;\n                alternate = !alternate;\n                prevPointIndex = alternate ? sideNails - round - 1 : round + minNailIndex;\n                const nextPoint = this.getPoint(side, prevPointIndex);\n                renderer.renderLines(prevPoint, nextPoint);\n                prevPoint = nextPoint;\n                yield;\n                if (isLastRound && i === sides - 1 && sides % 2 && sideNails % 2) break;\n            }\n            if (!isLastRound) {\n                prevPointIndex = alternate ? prevPointIndex - 1 : prevPointIndex + 1;\n                const nextPoint = this.getPoint(0, prevPointIndex);\n                renderer.renderLines(prevPoint, nextPoint);\n                prevPoint = nextPoint;\n            }\n        }\n    }\n    getStepCount(size) {\n        return $2e2273f8da969026$export$2e2bcd8739ae039.getStepCount(this.config, {\n            size: size\n        });\n    }\n    static getStepCount({ sides: sides, sideNails: sideNailsConfig, maxCurveSize: maxCurveSize = 1 }, { size: size } = {}) {\n        const sidesConnectionCount = Math.floor(Math.min(1, maxCurveSize) * sideNailsConfig);\n        const sideNails = size ? Math.min(Math.floor(size), sideNailsConfig) : sideNailsConfig;\n        const minNailIndex = Math.max(0, sideNails - sidesConnectionCount);\n        const rounds = sides % 2 ? Math.ceil(Math.min(sideNails, sidesConnectionCount) / 2) : sideNails - minNailIndex;\n        const linesPerRound = sides % 2 ? sides * 2 : sides;\n        const isOdd = sides % 2 && sideNails % 2;\n        return rounds * linesPerRound - (isOdd ? sides : 0);\n    }\n    static nailsConfig = Object.freeze({\n        key: 'sideNails',\n        label: 'Nails per side',\n        defaultValue: 40,\n        type: 'range',\n        attr: {\n            min: 1,\n            max: 200,\n            step: 1\n        },\n        isStructural: true\n    });\n    static sidesConfig = Object.freeze({\n        key: 'sides',\n        label: 'Sides',\n        defaultValue: 3,\n        type: 'range',\n        attr: {\n            min: 3,\n            max: 40,\n            step: 1\n        },\n        isStructural: true\n    });\n    static maxCurveSize = {\n        key: 'maxCurveSize',\n        label: 'Max curve size',\n        description: 'The maximum number of connections used to create a curve between two sides.',\n        defaultValue: 1,\n        type: 'range',\n        displayValue: ({ maxCurveSize: maxCurveSize, sideNails: sideNails })=>Math.floor(maxCurveSize * sideNails),\n        attr: {\n            min: 0,\n            max: 1,\n            step: ({ sideNails: sideNails })=>1 / sideNails\n        },\n        isStructural: true\n    };\n    static centerRadiusConfig = {\n        key: 'centerRadius',\n        label: 'Center radius',\n        defaultValue: 0,\n        type: 'range',\n        attr: {\n            min: 0,\n            max: ({ sideNails: sideNails })=>(sideNails - 1) / sideNails,\n            step: 0.01\n        },\n        displayValue: ({ centerRadius: centerRadius })=>(0, $96d8651f67c6b219$export$f481ea230fad194b)(centerRadius),\n        isStructural: true\n    };\n    static rotationConfig = {\n        key: 'rotation',\n        label: 'Rotation',\n        defaultValue: 0,\n        type: 'range',\n        attr: {\n            min: 0,\n            max: 1,\n            step: 0.01,\n            snap: '0.5'\n        },\n        displayValue: ({ rotation: rotation, sides: sides })=>`${Math.round(rotation * 360 / sides)}\\xb0`,\n        isStructural: true,\n        affectsStepCount: false\n    };\n    static StarConfig = [\n        $2e2273f8da969026$export$2e2bcd8739ae039.nailsConfig,\n        $2e2273f8da969026$export$2e2bcd8739ae039.sidesConfig,\n        $2e2273f8da969026$export$2e2bcd8739ae039.centerRadiusConfig,\n        $2e2273f8da969026$export$2e2bcd8739ae039.maxCurveSize,\n        $2e2273f8da969026$export$2e2bcd8739ae039.rotationConfig\n    ];\n}\n\n\n\nclass $ca4a2eb6736370e4$export$2e2bcd8739ae039 extends (0, $a64bacef9e98af6b$export$2e2bcd8739ae039) {\n    static type = 'star';\n    name = 'Star';\n    id = 'star';\n    link = 'https://www.etsy.com/listing/557818258/string-art-meditation-geometric-yoga?epik=dj0yJnU9Mm1hYmZKdks1eTc3bVY2TkVhS2p2Qlg0N2dyVWJxaTEmcD0wJm49MGlWSXE1SVJ2Vm0xZ0xtaGhITDBWQSZ0PUFBQUFBR0Zwd2lj';\n    controls = [\n        {\n            key: 'sides',\n            label: 'Sides',\n            defaultValue: 3,\n            type: 'range',\n            attr: {\n                min: 3,\n                max: 20,\n                step: 1\n            }\n        },\n        {\n            key: 'sideNails',\n            label: 'Nails per side',\n            defaultValue: 40,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 200,\n                step: 1\n            }\n        },\n        (0, $2e2273f8da969026$export$2e2bcd8739ae039).centerRadiusConfig,\n        {\n            key: 'ringSize',\n            label: 'Outer ring size',\n            defaultValue: 0.1,\n            type: 'range',\n            attr: {\n                min: 0,\n                max: 0.5,\n                step: ({ sideNails: sideNails, sides: sides })=>1 / (sideNails * sides)\n            },\n            displayValue: ({ sideNails: sideNails, sides: sides, ringSize: ringSize })=>Math.floor(ringSize * sideNails * sides)\n        },\n        (0, $b103c63dc979d40c$export$2d97e2da46663803)((0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).rotationConfig, 'snap'),\n        (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).distortionConfig,\n        {\n            key: 'colorGroup',\n            label: 'Color',\n            type: 'group',\n            children: [\n                {\n                    key: 'innerColor',\n                    label: 'Star color',\n                    defaultValue: '#2ec0ff',\n                    type: 'color'\n                },\n                {\n                    key: 'outerColor',\n                    label: 'Outter color',\n                    defaultValue: '#2a82c6',\n                    type: 'color'\n                },\n                {\n                    key: 'ringColor',\n                    label: 'Ring color',\n                    defaultValue: '#2ec0ff',\n                    type: 'color'\n                }\n            ]\n        }\n    ];\n    #star = null;\n    #circle;\n    setUpDraw() {\n        super.setUpDraw();\n        const { sides: sides, rotation: rotation, distortion: distortion, sideNails: sideNails, margin: margin = 0 } = this.config;\n        const circleConfig = {\n            size: this.size,\n            n: sideNails * sides,\n            margin: margin,\n            rotation: rotation ? rotation / sides : 0,\n            distortion: distortion\n        };\n        if (this.#circle) this.#circle.setConfig(circleConfig);\n        else this.#circle = new (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039)(circleConfig);\n        const starConfig = {\n            ...this.config,\n            radius: this.#circle.radius,\n            size: this.size\n        };\n        if (this.#star) this.#star.setConfig(starConfig);\n        else this.#star = new (0, $2e2273f8da969026$export$2e2bcd8739ae039)(starConfig);\n    }\n    getArcPoint({ side: side, sideIndex: sideIndex }) {\n        return this.#circle.getPoint(side * this.config.sideNails + sideIndex);\n    }\n    *drawStar() {\n        const { innerColor: innerColor } = this.config;\n        this.renderer.setColor(innerColor);\n        yield* this.#star.generateStrings(this.renderer);\n    }\n    *drawCircle() {\n        const { outerColor: outerColor, sides: sides, sideNails: sideNails } = this.config;\n        this.renderer.setColor(outerColor);\n        let prevPoint = this.#star.getPoint(0, 0);\n        let alternate = false;\n        let isStar = false;\n        const rounds = sides % 2 ? Math.ceil(sideNails / 2) : sideNails;\n        let side = 0;\n        const linesPerRound = sides % 2 ? sides * 4 : sides * 2;\n        for(let round = 0; round <= rounds; round++){\n            const linesPerThisRound = linesPerRound - (round === rounds ? sides * 2 : 0);\n            for(let i = 0; i < linesPerThisRound; i++){\n                const pointPosition = {\n                    side: side,\n                    sideIndex: alternate ? sideNails - round - 1 : round\n                };\n                const nextPoint = isStar ? this.#star.getPoint(pointPosition.side, pointPosition.sideIndex) : this.getArcPoint(pointPosition);\n                this.renderer.renderLines(prevPoint, nextPoint);\n                prevPoint = nextPoint;\n                yield;\n                isStar = !isStar;\n                if (isStar) {\n                    side = side !== sides - 1 ? side + 1 : 0;\n                    alternate = !alternate;\n                }\n            }\n            prevPoint = this.#star.getPoint(0, round + 1);\n        }\n    }\n    *generateStrings() {\n        yield* this.drawCircle();\n        const { ringSize: ringSize, ringColor: ringColor } = this.config;\n        if (ringSize !== 0) yield* this.#circle.drawRing(this.renderer, {\n            ringSize: ringSize,\n            color: ringColor\n        });\n        yield* this.drawStar();\n    }\n    drawNails() {\n        this.#circle.drawNails(this.nails);\n        this.#star.drawNails(this.nails);\n        this.#circle.drawNails(this.nails);\n    }\n    #getCircleStepCount() {\n        const { sides: sides, sideNails: sideNails } = this.config;\n        const circleRounds = sides % 2 ? Math.ceil(sideNails / 2) : sideNails;\n        const linesPerRound = sides % 2 ? sides * 4 : sides * 2;\n        return (circleRounds + 1) * linesPerRound - sides * 2;\n    }\n    getStepCount() {\n        const { sides: sides, sideNails: sideNails, ringSize: ringSize } = this.config;\n        const ringCount = ringSize ? sideNails * sides : 0;\n        const circleCount = this.#getCircleStepCount();\n        const starCount = (0, $2e2273f8da969026$export$2e2bcd8739ae039).getStepCount(this.config);\n        return circleCount + ringCount + starCount;\n    }\n    static thumbnailConfig = {\n        sideNails: 18\n    };\n}\n\n\n\n\nconst $8db9d587e082a0d9$var$LAYER_DEFAULTS = [\n    {\n        size: 0.25,\n        end: 1,\n        color: '#a94fb0'\n    },\n    {\n        size: 0.125,\n        end: 0.888,\n        color: '#ec6ad0'\n    },\n    {\n        size: 0,\n        end: 0.826,\n        color: '#f08ad5',\n        reverse: true\n    }\n];\nclass $8db9d587e082a0d9$export$2e2bcd8739ae039 extends (0, $a64bacef9e98af6b$export$2e2bcd8739ae039) {\n    static type = 'assymetry';\n    name = 'Assymetry';\n    id = 'assymetry';\n    link = 'https://www.etsy.com/il-en/listing/1018950430/calming-wall-art-in-light-blue-for';\n    controls = [\n        (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).nailsConfig,\n        (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).rotationConfig,\n        (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).distortionConfig,\n        {\n            key: 'layers',\n            label: 'Layers',\n            type: 'group',\n            // @ts-expect-error: dynamic key is safe because we know the keys match Layers\n            children: $8db9d587e082a0d9$var$LAYER_DEFAULTS.map(({ size: size, end: end, color: color, reverse: reverse }, i)=>{\n                const layer = i + 1;\n                return {\n                    key: `layer${layer}`,\n                    label: `Layer ${layer}`,\n                    type: 'group',\n                    children: [\n                        {\n                            key: `show${layer}`,\n                            label: 'Enable',\n                            defaultValue: true,\n                            type: 'checkbox'\n                        },\n                        {\n                            key: `size${layer}`,\n                            label: 'Size',\n                            defaultValue: size,\n                            type: 'range',\n                            attr: {\n                                min: 0,\n                                max: 0.5,\n                                step: ({ n: n })=>1 / n\n                            },\n                            displayValue: (config)=>Math.round(config.n * config[`size${layer}`]),\n                            show: (config)=>config[`show${layer}`]\n                        },\n                        {\n                            key: `end${layer}`,\n                            label: 'End Position',\n                            defaultValue: end,\n                            type: 'range',\n                            attr: {\n                                min: 0,\n                                max: 1,\n                                step: ({ n: n })=>1 / n\n                            },\n                            displayValue: (config)=>Math.round(config.n * config[`end${layer}`]),\n                            show: (config)=>config[`show${layer}`]\n                        },\n                        {\n                            key: `color${layer}`,\n                            label: 'Color',\n                            defaultValue: color,\n                            type: 'color',\n                            show: (config)=>config[`show${layer}`]\n                        },\n                        {\n                            key: `reverse${layer}`,\n                            label: 'Reverse',\n                            defaultValue: reverse === true,\n                            type: 'checkbox',\n                            show: (config)=>config[`show${layer}`]\n                        }\n                    ]\n                };\n            })\n        }\n    ];\n    #circle;\n    #calc;\n    setUpDraw() {\n        super.setUpDraw();\n        this.#calc = this.#getCalc();\n    }\n    #getCalc() {\n        const { rotation: rotation, n: n, margin: margin = 0, distortion: distortion } = this.config;\n        const size = this.getSize();\n        const circleConfig = {\n            size: size,\n            n: n,\n            margin: margin,\n            rotation: rotation - 0.25,\n            distortion: distortion\n        };\n        let circle;\n        if (this.#calc?.circle) {\n            circle = this.#calc.circle;\n            this.#calc.circle.setConfig(circleConfig);\n        } else circle = new (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039)(circleConfig);\n        let lineSpacing = circle.indexAngle * circle.radius;\n        const lineNailCount = Math.floor(circle.radius / lineSpacing) - 1;\n        lineSpacing += (circle.radius - lineSpacing * lineNailCount) / lineNailCount;\n        const firstCirclePoint = circle.getPoint(0);\n        const totalNailCount = lineNailCount + n;\n        const totalIndexCount = totalNailCount + lineNailCount;\n        const layers = new Array(3).fill(null).map((_, i)=>getLayer.call(this, i + 1)).filter(({ enable: enable })=>enable);\n        return {\n            circle: circle,\n            lineSpacing: lineSpacing,\n            lineNailCount: lineNailCount,\n            firstCirclePoint: firstCirclePoint,\n            layers: layers,\n            totalNailCount: totalNailCount,\n            totalIndexCount: totalIndexCount\n        };\n        function getLayer(layerIndex) {\n            const size = Math.round(n * this.config['size' + layerIndex]) + lineNailCount;\n            return {\n                size: size,\n                endIndex: Math.round(this.config['end' + layerIndex] * (totalNailCount + lineNailCount)) - size,\n                color: this.config['color' + layerIndex],\n                enable: this.config['show' + layerIndex],\n                isReverse: this.config['reverse' + layerIndex]\n            };\n        }\n    }\n    /**\n   * Returns the position of a point on the line\n   */ getPoint(index) {\n        if (index < this.#calc.lineNailCount || index > this.#calc.totalNailCount) {\n            const linePosition = index < this.#calc.lineNailCount ? this.#calc.lineNailCount - index : index - this.#calc.totalNailCount;\n            const indexLength = linePosition * this.#calc.lineSpacing;\n            return [\n                this.#calc.firstCirclePoint[0] - indexLength * Math.sin(this.#calc.circle.rotationAngle),\n                this.#calc.firstCirclePoint[1] - indexLength * Math.cos(this.#calc.circle.rotationAngle)\n            ];\n        } else {\n            const circleIndex = index - this.#calc.lineNailCount;\n            return this.#calc.circle.getPoint(circleIndex);\n        }\n    }\n    *drawCircle({ endIndex: endIndex, color: color, isReverse: isReverse, size: size }) {\n        let prevPoint;\n        let prevPointIndex;\n        let isPrevSide = false;\n        this.renderer.setColor(color);\n        const self = this;\n        const advance = isReverse ? -1 : 1;\n        for(let index = 0; index <= endIndex; index++){\n            const startPoint = prevPoint ?? this.getPoint(getPointIndex(index));\n            const positions = [];\n            if (prevPoint) positions.push(this.getPoint(prevPointIndex + advance));\n            prevPointIndex = getPointIndex(isPrevSide ? index : index + size);\n            positions.push(prevPoint = this.getPoint(prevPointIndex));\n            this.renderer.renderLines(startPoint, ...positions);\n            yield;\n            isPrevSide = !isPrevSide;\n        }\n        function getPointIndex(index) {\n            return isReverse ? self.#calc.totalIndexCount - index : index;\n        }\n    }\n    *generateStrings() {\n        for (const layer of this.#calc.layers)yield* this.drawCircle(layer);\n    }\n    drawNails() {\n        this.#calc.circle.drawNails(this.nails, {\n            nailsNumberStart: this.#calc.lineNailCount\n        });\n        for(let i = 0; i < this.#calc.lineNailCount; i++)this.nails.addNail({\n            point: this.getPoint(i),\n            number: i\n        });\n    }\n    getStepCount() {\n        const { layers: layers } = this.#getCalc();\n        return layers.reduce((stepCount, layer)=>stepCount + layer.endIndex + 1, 0);\n    }\n    static thumbnailConfig = {\n        n: 50\n    };\n}\n\n\n\n\nconst $1530a0f3e43122ac$var$rotationConfig = {\n    label: 'Rotation',\n    defaultValue: 0,\n    type: 'range',\n    attr: {\n        min: 0,\n        max: 1 + 1 / 360,\n        step: 1 / 360\n    },\n    isStructural: true,\n    affectsStepCount: false\n};\nclass $1530a0f3e43122ac$export$2e2bcd8739ae039 extends (0, $a64bacef9e98af6b$export$2e2bcd8739ae039) {\n    static type = 'freestyle';\n    name = 'Freestyle';\n    id = 'freestyle';\n    link = 'https://www.etsy.com/il-en/listing/1018950430/calming-wall-art-in-light-blue-for';\n    controls = [\n        {\n            key: 'n',\n            label: 'Circle nails',\n            defaultValue: 80,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 300,\n                step: 1\n            }\n        },\n        {\n            key: 'minNailDistance',\n            label: 'Min nail distance',\n            defaultValue: 20,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 300,\n                step: 1\n            }\n        },\n        {\n            key: 'color',\n            label: 'Color',\n            defaultValue: '#ec6ad0',\n            type: 'color'\n        },\n        {\n            key: 'layers',\n            label: 'Layers',\n            type: 'group',\n            children: [\n                {\n                    key: 'layer1',\n                    label: 'Layer 1',\n                    type: 'group',\n                    children: [\n                        {\n                            key: 'show1',\n                            label: 'Enable',\n                            defaultValue: true,\n                            type: 'checkbox'\n                        },\n                        {\n                            key: 'radius1',\n                            label: 'Radius',\n                            defaultValue: 0.5,\n                            type: 'range',\n                            attr: {\n                                min: 0.01,\n                                max: 1,\n                                step: 0.01\n                            },\n                            show: ({ show1: show1 })=>show1\n                        },\n                        {\n                            key: 'x1',\n                            label: 'Position X',\n                            defaultValue: 0.5,\n                            type: 'range',\n                            attr: {\n                                min: 0,\n                                max: 1,\n                                step: 0.01\n                            },\n                            show: ({ show1: show1 })=>show1\n                        },\n                        {\n                            key: 'y1',\n                            label: 'Position Y',\n                            defaultValue: 0,\n                            type: 'range',\n                            attr: {\n                                min: 0,\n                                max: 1,\n                                step: 0.01\n                            },\n                            show: ({ show1: show1 })=>show1\n                        },\n                        {\n                            ...$1530a0f3e43122ac$var$rotationConfig,\n                            key: 'rotation1',\n                            show: ({ show1: show1 })=>show1,\n                            displayValue: ({ rotation1: rotation1 })=>`${Math.round(rotation1 * 360)}\\xb0`\n                        },\n                        {\n                            key: 'reverse1',\n                            label: 'Reverse',\n                            defaultValue: false,\n                            type: 'checkbox',\n                            show: ({ show1: show1 })=>show1\n                        }\n                    ]\n                },\n                {\n                    key: 'layer2',\n                    label: 'Layer 2',\n                    type: 'group',\n                    children: [\n                        {\n                            key: 'show2',\n                            label: 'Enable',\n                            defaultValue: true,\n                            type: 'checkbox'\n                        },\n                        {\n                            key: 'radius2',\n                            label: 'Radius',\n                            defaultValue: 0.5,\n                            type: 'range',\n                            attr: {\n                                min: 0.01,\n                                max: 1,\n                                step: 0.01\n                            },\n                            show: ({ show2: show2 })=>show2\n                        },\n                        {\n                            key: 'x2',\n                            label: 'Position X',\n                            defaultValue: 0,\n                            type: 'range',\n                            attr: {\n                                min: 0,\n                                max: 1,\n                                step: 0.01\n                            },\n                            show: ({ show2: show2 })=>show2\n                        },\n                        {\n                            key: 'y2',\n                            label: 'Position Y',\n                            defaultValue: 1,\n                            type: 'range',\n                            attr: {\n                                min: 0,\n                                max: 1,\n                                step: 0.01\n                            },\n                            show: ({ show2: show2 })=>show2\n                        },\n                        {\n                            ...$1530a0f3e43122ac$var$rotationConfig,\n                            key: 'rotation2',\n                            show: ({ show2: show2 })=>show2,\n                            displayValue: ({ rotation2: rotation2 })=>`${Math.round(rotation2 * 360)}\\xb0`\n                        },\n                        {\n                            key: 'reverse2',\n                            label: 'Reverse',\n                            defaultValue: false,\n                            type: 'checkbox',\n                            show: ({ show2: show2 })=>show2\n                        }\n                    ]\n                },\n                {\n                    key: 'layer3',\n                    label: 'Layer 3',\n                    type: 'group',\n                    children: [\n                        {\n                            key: 'show3',\n                            label: 'Enable',\n                            defaultValue: true,\n                            type: 'checkbox'\n                        },\n                        {\n                            key: 'radius3',\n                            label: 'Radius',\n                            defaultValue: 0.5,\n                            type: 'range',\n                            attr: {\n                                min: 0.01,\n                                max: 1,\n                                step: 0.01\n                            },\n                            show: ({ show3: show3 })=>show3\n                        },\n                        {\n                            key: 'x3',\n                            label: 'Position X',\n                            defaultValue: 1,\n                            type: 'range',\n                            attr: {\n                                min: 0,\n                                max: 1,\n                                step: 0.01\n                            },\n                            show: ({ show3: show3 })=>show3\n                        },\n                        {\n                            key: 'y3',\n                            label: 'Position Y',\n                            defaultValue: 1,\n                            type: 'range',\n                            attr: {\n                                min: 0,\n                                max: 1,\n                                step: 0.01\n                            },\n                            show: ({ show3: show3 })=>show3\n                        },\n                        {\n                            ...$1530a0f3e43122ac$var$rotationConfig,\n                            key: 'rotation3',\n                            show: ({ show3: show3 })=>show3,\n                            displayValue: ({ rotation3: rotation3 })=>`${Math.round(rotation3 * 360)}\\xb0`\n                        },\n                        {\n                            key: 'reverse3',\n                            label: 'Reverse',\n                            defaultValue: false,\n                            type: 'checkbox',\n                            show: ({ show3: show3 })=>show3\n                        }\n                    ]\n                }\n            ]\n        }\n    ];\n    #calc;\n    setUpDraw() {\n        super.setUpDraw();\n        this.#calc = this.getCalc();\n    }\n    getCalc() {\n        const { n: n, margin: margin = 0, minNailDistance: minNailDistance } = this.config;\n        const size = this.getSize();\n        const maxRadius = Math.min(...size.map((v)=>v - 2 * margin)) / 2;\n        const layers = new Array(3).fill(null).map((_, i)=>getLayer.call(this, i + 1)).filter(({ enable: enable })=>enable);\n        const maxShapeNailsCount = Math.max(...layers.map(({ circle: circle })=>circle.config.n));\n        return {\n            layers: layers,\n            maxShapeNailsCount: maxShapeNailsCount\n        };\n        function getLayer(layerIndex) {\n            const prop = (prop)=>this.config[prop + layerIndex];\n            const props = {\n                enable: prop('show'),\n                isReverse: prop('reverse'),\n                position: [\n                    prop('x'),\n                    prop('y')\n                ],\n                radius: maxRadius * prop('radius'),\n                rotation: prop('rotation')\n            };\n            const circumsference = Math.PI * 2 * props.radius;\n            const circleNails = Math.min(n, Math.floor(circumsference / minNailDistance));\n            const circle = new (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039)({\n                radius: props.radius,\n                size: this.size,\n                center: props.position.map((v, i)=>props.radius + margin + (size[i] - (props.radius + margin) * 2) * v),\n                n: circleNails,\n                rotation: props.rotation,\n                reverse: props.isReverse\n            });\n            return {\n                circle: circle,\n                ...props\n            };\n        }\n    }\n    getPoint(layer, index) {\n        const { circle: circle } = layer;\n        let circleIndex = Math.round(index * circle.config.n / this.#calc.maxShapeNailsCount);\n        return circle.getPoint(circleIndex);\n    }\n    *generateStrings() {\n        const { color: color } = this.config;\n        this.renderer.setColor(color);\n        let prevCirclePoint;\n        for(let i = 0; i < this.#calc.maxShapeNailsCount; i++)for(let layerIndex = 0; layerIndex < this.#calc.layers.length; layerIndex++){\n            const layer = this.#calc.layers[layerIndex];\n            const startPoint = prevCirclePoint ?? this.getPoint(layer, i);\n            const positions = [];\n            if (layerIndex === 0 && i) positions.push(this.getPoint(layer, i));\n            let nextLayerIndex = layerIndex + 1;\n            if (nextLayerIndex === this.#calc.layers.length) nextLayerIndex = 0;\n            prevCirclePoint = this.getPoint(this.#calc.layers[nextLayerIndex], i);\n            this.renderer.renderLines(startPoint, prevCirclePoint);\n            yield;\n        }\n    }\n    drawNails() {\n        this.#calc.layers.forEach(({ circle: circle }, layerIndex)=>circle.drawNails(this.nails, {\n                getNumber: (i)=>`${layerIndex + 1}_${i + 1}`\n            }));\n    }\n    getStepCount() {\n        const { layers: layers, maxShapeNailsCount: maxShapeNailsCount } = this.getCalc();\n        return layers.length * maxShapeNailsCount - 1;\n    }\n    static thumbnailConfig = {\n        minNailDistance: 3,\n        n: 40\n    };\n}\n\n\n\n\n\nclass $b43fc0eaa10ef4c7$export$2e2bcd8739ae039 {\n    config;\n    #points;\n    #calc;\n    constructor(config){\n        this.setConfig(config);\n    }\n    setConfig(config) {\n        if (!(0, $c29d66861308df7e$export$f05027632b38f3a4)(config, this.config)) {\n            this.config = config;\n            if (this.#points) this.#points.clear();\n            else this.#points = new Map();\n            this.#calc = this.#getCalc();\n            if (config.fitSize) {\n                const sizeAndCenter = this.#getSizeAndCenter();\n                this.#points.clear();\n                this.#calc = {\n                    ...this.#getCalc(),\n                    ...sizeAndCenter\n                };\n            }\n        }\n    }\n    #getSizeAndCenter() {\n        const { size: configSize, margin: margin } = this.config;\n        const boundingRect = this.getBoundingRect();\n        const scale = Math.min((configSize[0] - 2 * margin) / boundingRect.width, (configSize[1] - 2 * margin) / boundingRect.height);\n        const size = configSize.map((v)=>v * scale);\n        const center = [\n            this.#calc.center[0] - scale * (boundingRect.left - configSize[0] + boundingRect.right) / 2,\n            this.#calc.center[1] - scale * (boundingRect.top - configSize[1] + boundingRect.bottom) / 2\n        ];\n        return {\n            size: size,\n            center: center\n        };\n    }\n    #getCalc() {\n        const { size: size, rotation: rotation = 0, sides: sideCount, center: configCenter, margin: margin, nailsSpacing: nailsSpacing } = this.config;\n        const sideAngle = (0, $e2b746416d2bf62b$export$f4644083ce95e7e3) / sideCount;\n        const sides = new Array(sideCount).fill(null).map((_, i)=>{\n            const angle = sideAngle * i + (0, $e2b746416d2bf62b$export$f4644083ce95e7e3) * rotation;\n            const radiusAngle = -sideAngle * (i - 0.5) - (0, $e2b746416d2bf62b$export$f4644083ce95e7e3) * rotation;\n            return {\n                cos: Math.cos(angle),\n                sin: Math.sin(angle),\n                center: {\n                    cos: Math.cos(radiusAngle),\n                    sin: Math.sin(radiusAngle)\n                }\n            };\n        });\n        const center = configCenter ?? this.config.size.map((v)=>v / 2);\n        const radius = Math.min(...size) / 2 - margin;\n        const sideSize = 2 * radius * Math.sin(sideAngle / 2);\n        const start = [\n            radius * Math.sin(sideAngle / 2),\n            radius * Math.cos(sideAngle / 2)\n        ];\n        const nailsDistance = sideSize * nailsSpacing;\n        const radiusNailsCount = Math.floor(radius / nailsDistance);\n        const radiusNailsDistance = radius / radiusNailsCount;\n        return {\n            nailsPerSide: 1 / nailsSpacing,\n            center: center,\n            radius: radius,\n            sideSize: sideSize,\n            start: start,\n            nailsDistance: nailsDistance,\n            radiusNailsCount: radiusNailsCount,\n            radiusNailsDistance: radiusNailsDistance,\n            sides: sides,\n            sideAngle: sideAngle\n        };\n    }\n    get nailsPerSide() {\n        return this.#calc.nailsPerSide;\n    }\n    get radiusNailsCount() {\n        return this.#calc.radiusNailsCount;\n    }\n    get sideSize() {\n        return this.#calc.sideSize;\n    }\n    getSidePoint({ side: side, index: index }) {\n        const pointsMapIndex = [\n            side,\n            index\n        ].join('_');\n        if (this.#points.has(pointsMapIndex)) return this.#points.get(pointsMapIndex);\n        const startX = this.#calc.start[0] - index * this.#calc.nailsDistance;\n        const { cos: cos, sin: sin } = this.#calc.sides[side];\n        const point = [\n            cos * startX - sin * this.#calc.start[1] + this.#calc.center[0],\n            sin * startX + cos * this.#calc.start[1] + this.#calc.center[1]\n        ];\n        this.#points.set(pointsMapIndex, point);\n        return point;\n    }\n    getCenterPoint({ side: side, index: index }) {\n        const radius = index * this.#calc.radiusNailsDistance;\n        const { sin: sin, cos: cos } = this.#calc.sides[side].center;\n        return [\n            this.#calc.center[0] + sin * radius,\n            this.#calc.center[1] + cos * radius\n        ];\n    }\n    getBoundingRect() {\n        const points = this.#calc.sides.map((_, side)=>this.getSidePoint({\n                side: side,\n                index: 0\n            }));\n        const firstPoint = points[0];\n        const boundingRect = points.slice(1).reduce((boundingRect, [x, y])=>({\n                left: Math.min(boundingRect.left, x),\n                right: Math.max(boundingRect.right, x),\n                top: Math.min(boundingRect.top, y),\n                bottom: Math.max(boundingRect.bottom, y)\n            }), {\n            left: firstPoint[0],\n            right: firstPoint[0],\n            top: firstPoint[1],\n            bottom: firstPoint[1]\n        });\n        return {\n            ...boundingRect,\n            height: boundingRect.bottom - boundingRect.top,\n            width: boundingRect.right - boundingRect.left\n        };\n    }\n    drawNails(nails, { drawCenter: drawCenter = false, drawSides: drawSides = true, filterCenterNails: filterCenterNails } = {}) {\n        for(let side = 0; side < this.config.sides; side++){\n            const sideIndexStart = side * this.#calc.nailsPerSide;\n            if (drawSides) for(let index = 0; index < this.#calc.nailsPerSide; index++)nails.addNail({\n                point: this.getSidePoint({\n                    side: side,\n                    index: index\n                }),\n                number: sideIndexStart + index\n            });\n            if (drawCenter) {\n                for(let index = 0; index < this.#calc.radiusNailsCount; index++)if (!filterCenterNails || filterCenterNails(side, index)) nails.addNail({\n                    point: this.getCenterPoint({\n                        side: side,\n                        index: index\n                    }),\n                    number: `${side}_${index}`\n                });\n            }\n        }\n    }\n    static rotationConfig = {\n        key: 'rotation',\n        label: 'Rotation',\n        defaultValue: 0,\n        type: 'range',\n        attr: {\n            min: 0,\n            max: 1,\n            step: 0.02\n        },\n        displayValue: ({ rotation: rotation, sides: sides })=>`${Math.round(rotation * 180 / sides)}\\xb0`,\n        isStructural: true,\n        affectsStepCount: false\n    };\n}\n\n\n\nconst $3f55ac726d5ebe61$var$COLOR_CONFIG = (0, $44d9dab6555abf73$export$2e2bcd8739ae039).getConfig({\n    defaults: {\n        isMultiColor: true,\n        color: '#ff0000',\n        multicolorRange: 1,\n        multicolorStart: 0,\n        multicolorByLightness: true,\n        minLightness: 20,\n        maxLightness: 50\n    },\n    exclude: [\n        'colorCount'\n    ]\n});\nclass $3f55ac726d5ebe61$export$2e2bcd8739ae039 extends (0, $a64bacef9e98af6b$export$2e2bcd8739ae039) {\n    static type = 'polygon';\n    name = 'Polygon';\n    id = 'polygon';\n    controls = [\n        {\n            key: 'sides',\n            label: 'Sides',\n            defaultValue: 5,\n            type: 'range',\n            attr: {\n                min: 3,\n                max: 10,\n                step: 1\n            }\n        },\n        {\n            key: 'n',\n            label: 'Nails per side',\n            defaultValue: 60,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 100,\n                step: 1\n            }\n        },\n        {\n            key: 'bezier',\n            label: 'Bezier',\n            defaultValue: 2,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 4,\n                step: 1\n            },\n            show: ({ sides: sides })=>sides > 4\n        },\n        (0, $b43fc0eaa10ef4c7$export$2e2bcd8739ae039).rotationConfig,\n        $3f55ac726d5ebe61$var$COLOR_CONFIG\n    ];\n    defaultValues = {\n        nailsColor: '#5c5c5c',\n        nailRadius: 1\n    };\n    #polygon;\n    color;\n    colorMap;\n    setUpDraw() {\n        super.setUpDraw();\n        const { n: n, rotation: rotation, sides: sides, margin: margin, isMultiColor: isMultiColor } = this.config;\n        const size = this.getSize();\n        const polygonConfig = {\n            sides: sides,\n            rotation: rotation / (sides * 2),\n            margin: margin,\n            size: size,\n            nailsSpacing: 1 / n,\n            fitSize: true\n        };\n        if (this.#polygon) this.#polygon.setConfig(polygonConfig);\n        else this.#polygon = new (0, $b43fc0eaa10ef4c7$export$2e2bcd8739ae039)(polygonConfig);\n        this.color = new (0, $44d9dab6555abf73$export$2e2bcd8739ae039)({\n            ...this.config,\n            isMultiColor: isMultiColor,\n            colorCount: sides\n        });\n        if (isMultiColor) this.colorMap = this.color.getColorMap({\n            stepCount: this.getStepCount(),\n            colorCount: sides\n        });\n        else this.colorMap = null;\n    }\n    *generateStrings() {\n        const { sides: sides, bezier: bezier } = this.config;\n        const limitedBezier = Math.min(bezier, Math.ceil(sides / 2) - 1);\n        let step = 0;\n        this.renderer.setColor(this.color.getColor(0));\n        for(let side = 0; side < sides; side++){\n            const nextSide = (side + limitedBezier) % sides;\n            if (this.colorMap) this.renderer.setColor(this.colorMap.get(step));\n            for(let index = 0; index < this.#polygon.nailsPerSide; index++){\n                this.renderer.renderLines(this.#polygon.getSidePoint({\n                    side: side,\n                    index: index\n                }), this.#polygon.getSidePoint({\n                    side: nextSide,\n                    index: index\n                }));\n                yield;\n                step++;\n            }\n        }\n    }\n    getStepCount() {\n        const { sides: sides, n: n } = this.config;\n        return sides * n;\n    }\n    drawNails() {\n        this.#polygon.drawNails(this.nails);\n    }\n    static thumbnailConfig = {\n        n: 20\n    };\n}\n\n\n\n\n\nconst $7e0f39c01d255ee0$var$COLOR_CONFIG = (0, $44d9dab6555abf73$export$2e2bcd8739ae039).getConfig({\n    defaults: {\n        isMultiColor: true,\n        color: '#29f1ff',\n        multicolorRange: 132,\n        multicolorStart: 53,\n        multicolorByLightness: false,\n        minLightness: 30,\n        maxLightness: 70\n    },\n    exclude: [\n        'colorCount'\n    ]\n});\nclass $7e0f39c01d255ee0$export$2e2bcd8739ae039 extends (0, $a64bacef9e98af6b$export$2e2bcd8739ae039) {\n    static type = 'flower';\n    name = 'Flower';\n    id = 'flower';\n    link = 'https://www.sqrt.ch/Buch/fadenmodell4_100.svg';\n    controls = [\n        {\n            key: 'sides',\n            label: 'Sides',\n            defaultValue: 4,\n            type: 'range',\n            attr: {\n                min: 3,\n                max: 10,\n                step: 1\n            }\n        },\n        {\n            key: 'n',\n            label: 'Nails per side',\n            defaultValue: 60,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 100,\n                step: 1\n            }\n        },\n        {\n            key: 'layers',\n            label: 'Layers',\n            defaultValue: 2,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 10,\n                step: 1\n            }\n        },\n        (0, $b43fc0eaa10ef4c7$export$2e2bcd8739ae039).rotationConfig,\n        $7e0f39c01d255ee0$var$COLOR_CONFIG\n    ];\n    defaultValues = {\n        nailsColor: '#29f1ff',\n        nailRadius: 1,\n        stringWidth: 0.5\n    };\n    #polygons;\n    color;\n    colorMap;\n    setUpDraw() {\n        super.setUpDraw();\n        const { n: n, rotation: rotation, sides: sides, layers: layers, margin: margin, isMultiColor: isMultiColor } = this.config;\n        const size = this.getSize();\n        const layerAngleShift = 1 / (sides * layers);\n        this.#polygons = new Array(layers).fill(null).map((_, i)=>{\n            const polygonConfig = {\n                sides: sides,\n                rotation: rotation / sides + i * layerAngleShift,\n                margin: margin,\n                size: size,\n                nailsSpacing: 1 / n\n            };\n            return new (0, $b43fc0eaa10ef4c7$export$2e2bcd8739ae039)(polygonConfig);\n        });\n        this.color = new (0, $44d9dab6555abf73$export$2e2bcd8739ae039)({\n            ...this.config,\n            isMultiColor: isMultiColor,\n            colorCount: layers\n        });\n        if (isMultiColor) this.colorMap = this.color.getColorMap({\n            stepCount: this.getStepCount(),\n            colorCount: layers\n        });\n        else this.colorMap = null;\n    }\n    *generateStrings() {\n        const { sides: sides, layers: layers } = this.config;\n        let step = 0;\n        this.renderer.setColor(this.color.getColor(0));\n        for(let layer = 0; layer < layers; layer++){\n            const polygon = this.#polygons[layer];\n            for(let side = 0; side < sides; side++){\n                const leftSide = side === sides - 1 ? 0 : side + 1;\n                for(let index = 0; index <= polygon.nailsPerSide; index++){\n                    if (this.colorMap?.has(step)) this.renderer.setColor(this.colorMap.get(step));\n                    const centerIndexes = this.getCenterIndexes({\n                        polygon: polygon,\n                        sideIndex: index\n                    });\n                    this.renderer.renderLines(polygon.getCenterPoint({\n                        side: side,\n                        index: centerIndexes[0]\n                    }), polygon.getSidePoint({\n                        side: side,\n                        index: index\n                    }), polygon.getCenterPoint({\n                        side: leftSide,\n                        index: centerIndexes[1]\n                    }));\n                    yield;\n                    step++;\n                }\n            }\n        }\n    }\n    getCenterIndexes({ polygon: polygon, sideIndex: sideIndex }) {\n        const extraNailCount = polygon.nailsPerSide - polygon.radiusNailsCount;\n        return [\n            sideIndex < extraNailCount ? -extraNailCount + sideIndex : sideIndex - extraNailCount,\n            polygon.radiusNailsCount - sideIndex\n        ];\n    }\n    getStepCount() {\n        const { sides: sides, n: n, layers: layers } = this.config;\n        return sides * (n + 1) * layers;\n    }\n    drawNails() {\n        const firstNailIndex = this.#polygons[0].radiusNailsCount - this.#polygons[0].nailsPerSide;\n        const filterCenterNails = firstNailIndex > 0 ? (_, index)=>index >= firstNailIndex : null;\n        this.#polygons.forEach((polygon)=>polygon.drawNails(this.nails, {\n                drawCenter: true,\n                filterCenterNails: filterCenterNails\n            }));\n    }\n    static thumbnailConfig = {\n        n: 20\n    };\n}\n\n\n\n\n\n\nconst $5498d6506310c764$var$COLOR_CONFIG = (0, $44d9dab6555abf73$export$2e2bcd8739ae039).getConfig({\n    defaults: {\n        isMultiColor: true,\n        color: '#ffffff',\n        multicolorRange: 102,\n        multicolorStart: 239,\n        multicolorByLightness: false,\n        minLightness: 30,\n        maxLightness: 70,\n        colorCount: 4\n    },\n    exclude: [\n        'repeatColors',\n        'mirrorColors'\n    ]\n});\nclass $5498d6506310c764$export$2e2bcd8739ae039 extends (0, $a64bacef9e98af6b$export$2e2bcd8739ae039) {\n    static type = 'maurer_rose';\n    name = 'Maurer Rose';\n    id = 'maurer_rose';\n    link = 'https://blog.glitch.land/en/posts/maurer-rose/';\n    linkText = 'Learn';\n    controls = [\n        {\n            key: 'n',\n            label: 'N',\n            defaultValue: 4,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 12,\n                step: 1\n            },\n            isStructural: true\n        },\n        {\n            key: 'maxSteps',\n            label: 'Max steps',\n            defaultValue: 512,\n            type: 'range',\n            attr: {\n                min: 3,\n                max: 720,\n                step: 1\n            },\n            isStructural: true\n        },\n        {\n            key: 'angle',\n            label: 'Angle',\n            defaultValue: 341,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 720,\n                step: 1\n            },\n            displayValue: ({ angle: angle })=>`${angle}\\xb0`,\n            isStructural: true\n        },\n        (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).rotationConfig,\n        $5498d6506310c764$var$COLOR_CONFIG\n    ];\n    calc;\n    points;\n    color;\n    colorMap;\n    resetStructure() {\n        super.resetStructure();\n        if (this.points) this.points.clear();\n        this.calc = null;\n    }\n    setUpDraw() {\n        super.setUpDraw();\n        const { isMultiColor: isMultiColor, colorCount: colorCount } = this.config;\n        if (!this.calc) this.calc = this.getCalc();\n        if (!this.points) this.points = new Map();\n        if (!this.stepCount) this.stepCount = this.getStepCount();\n        this.color = new (0, $44d9dab6555abf73$export$2e2bcd8739ae039)({\n            ...this.config,\n            isMultiColor: isMultiColor,\n            colorCount: colorCount\n        });\n        if (isMultiColor) this.colorMap = this.color.getColorMap({\n            stepCount: this.stepCount,\n            colorCount: colorCount\n        });\n        else this.colorMap = null;\n    }\n    getCalc() {\n        const { angle: angle, rotation: rotation, maxSteps: maxSteps } = this.config;\n        const size = this.getSize();\n        return {\n            angleRadians: (0, $e2b746416d2bf62b$export$f4644083ce95e7e3) * angle / maxSteps,\n            radius: Math.min(...size) / 2,\n            currentSize: size,\n            rotationAngle: -Math.PI * 2 * rotation\n        };\n    }\n    getPoint(index) {\n        const { rotationAngle: rotationAngle, angleRadians: angleRadians, radius: radius } = this.calc;\n        if (this.points.has(index)) return this.points.get(index);\n        const k = index * angleRadians;\n        const r = radius * Math.sin(this.config.n * k);\n        const point = [\n            this.center[0] - r * Math.cos(k - rotationAngle),\n            this.center[1] - r * Math.sin(k - rotationAngle)\n        ];\n        this.points.set(index, point);\n        return point;\n    }\n    *generatePoints() {\n        const count = this.stepCount;\n        for(let i = 0; i < count + 1; i++)yield {\n            point: this.getPoint(i),\n            index: i\n        };\n    }\n    *generateStrings() {\n        const points = this.generatePoints();\n        let prevPoint;\n        this.renderer.setColor(this.color.getColor(0));\n        for (const { point: point, index: index } of points){\n            if (!prevPoint) {\n                prevPoint = point;\n                continue;\n            }\n            if (this.colorMap) {\n                const stepColor = this.colorMap.get(index);\n                if (stepColor) this.renderer.setColor(stepColor);\n            }\n            this.renderer.renderLines(prevPoint, point);\n            prevPoint = point;\n            yield;\n        }\n    }\n    getStepCount() {\n        if (this.stepCount) return this.stepCount;\n        const { maxSteps: maxSteps, angle: angle, n: n } = this.config;\n        const angleGcd = (0, $e2b746416d2bf62b$export$f81847884871263e)(maxSteps, angle);\n        let steps = maxSteps / angleGcd;\n        if (!(steps % 2) && n % 2) steps /= 2;\n        return Math.round(steps);\n    }\n    drawNails() {\n        const points = this.generatePoints();\n        for (const { point: point, index: index } of points)this.nails.addNail({\n            point: point,\n            number: index\n        });\n    }\n    static thumbnailConfig = {};\n}\n\n\n\n\n\n\n\n\nconst $7a74ed27f7260395$var$COLOR_CONFIG = (0, $44d9dab6555abf73$export$2e2bcd8739ae039).getConfig({\n    defaults: {\n        isMultiColor: true,\n        color: '#29f1ff',\n        multicolorRange: 30,\n        multicolorStart: 25,\n        multicolorByLightness: true,\n        minLightness: 40,\n        maxLightness: 95,\n        colorCount: 3,\n        repeatColors: true,\n        saturation: 83,\n        reverseColors: true\n    },\n    customControls: [\n        {\n            key: 'colorPerLevel',\n            label: 'Color per level',\n            defaultValue: true,\n            type: 'checkbox'\n        }\n    ]\n});\nconst $7a74ed27f7260395$var$ANGLE = -(0, $e2b746416d2bf62b$export$f4644083ce95e7e3) / 6; // The angle of a equilateral triangle;\nconst $7a74ed27f7260395$var$SIDE_ANGLES = new Array(6).fill(null).map((_, i)=>Math.PI / 2 + $7a74ed27f7260395$var$ANGLE * i);\nclass $7a74ed27f7260395$export$2e2bcd8739ae039 extends (0, $a64bacef9e98af6b$export$2e2bcd8739ae039) {\n    static type = 'flower_of_life';\n    name = 'Flower of Life';\n    id = 'flower_of_life';\n    link = 'https://www.reddit.com/r/psychedelicartwork/comments/mk97gi/rainbow_flower_of_life_uv_reactive_string_art/';\n    controls = [\n        {\n            key: 'levels',\n            label: 'Levels',\n            defaultValue: 3,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 10,\n                step: 1\n            },\n            isStructural: true\n        },\n        {\n            key: 'density',\n            label: 'Density',\n            defaultValue: 10,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 50,\n                step: 1\n            },\n            isStructural: true\n        },\n        {\n            key: 'globalRotation',\n            label: 'Rotation',\n            defaultValue: 0,\n            type: 'range',\n            attr: {\n                min: 0,\n                max: 30,\n                step: 1\n            },\n            displayValue: ({ globalRotation: globalRotation })=>`${globalRotation}\\xb0`,\n            isStructural: true,\n            affectsStepCount: false\n        },\n        {\n            key: 'fillGroup',\n            label: 'Fill',\n            type: 'group',\n            children: [\n                {\n                    key: 'fill',\n                    label: 'Show fill',\n                    defaultValue: true,\n                    type: 'checkbox',\n                    isStructural: true\n                },\n                {\n                    key: 'fillColor',\n                    label: 'Fill color',\n                    defaultValue: '#292e29',\n                    type: 'color',\n                    show: ({ fill: fill })=>fill\n                }\n            ]\n        },\n        {\n            key: 'ringGroup',\n            label: 'Ring',\n            type: 'group',\n            children: [\n                {\n                    key: 'renderRing',\n                    label: 'Show outer ring',\n                    type: 'checkbox',\n                    defaultValue: true,\n                    isStructural: true\n                },\n                {\n                    key: 'ringNailCount',\n                    label: 'Ring nail count',\n                    defaultValue: 144,\n                    type: 'range',\n                    attr: {\n                        min: 3,\n                        max: 360,\n                        step: 1\n                    },\n                    show: ({ renderRing: renderRing })=>renderRing,\n                    isStructural: true\n                },\n                {\n                    key: 'ringSize',\n                    label: 'Outer ring size',\n                    defaultValue: 0.23,\n                    type: 'range',\n                    attr: {\n                        min: 0,\n                        max: 0.5,\n                        step: 0.01\n                    },\n                    show: ({ renderRing: renderRing })=>renderRing,\n                    displayValue: ({ ringSize: ringSize })=>(0, $96d8651f67c6b219$export$f481ea230fad194b)(ringSize),\n                    isStructural: true\n                },\n                {\n                    key: 'ringPadding',\n                    label: 'Ring padding',\n                    defaultValue: 0.06,\n                    type: 'range',\n                    attr: {\n                        min: 0,\n                        max: 0.5,\n                        step: 0.01\n                    },\n                    show: ({ renderRing: renderRing })=>renderRing,\n                    isStructural: true,\n                    displayValue: ({ ringPadding: ringPadding })=>(0, $96d8651f67c6b219$export$f481ea230fad194b)(ringPadding)\n                },\n                {\n                    key: 'ringColor',\n                    label: 'Ring color',\n                    defaultValue: '#e8b564',\n                    type: 'color',\n                    show: ({ renderRing: renderRing })=>renderRing\n                }\n            ]\n        },\n        {\n            key: 'renderTriangles',\n            label: 'Show triangles',\n            defaultValue: true,\n            type: 'checkbox',\n            isStructural: true\n        },\n        {\n            key: 'renderCaps',\n            label: 'Show caps',\n            defaultValue: true,\n            type: 'checkbox',\n            show: ({ renderTriangles: renderTriangles })=>renderTriangles,\n            isStructural: true\n        },\n        $7a74ed27f7260395$var$COLOR_CONFIG\n    ];\n    defaultValues = {\n        nailsColor: '#474747'\n    };\n    #calc;\n    points;\n    color;\n    colorMap;\n    #circle;\n    getCalc() {\n        const { levels: levels, density: density, margin: margin, globalRotation: globalRotation, renderCaps: renderCaps, renderRing: renderRing, ringNailCount: ringNailCount, ringSize: ringSize, ringPadding: ringPadding } = this.config;\n        const globalRotationRadians = globalRotation * Math.PI / 180 + Math.PI / 6;\n        const radius = renderRing ? Math.min(...(this.size ?? this.getSize()).map((v)=>v / 2 - margin)) : null;\n        const ringDistance = renderRing ? Math.floor(ringSize * ringNailCount / 2) : 0; // The number of nails to count for strings in the outer ring\n        const ringWidth = renderRing ? radius * (1 - Math.cos((0, $e2b746416d2bf62b$export$f4644083ce95e7e3) * (ringDistance / ringNailCount) / 2)) : 0;\n        const polygon = new (0, $b43fc0eaa10ef4c7$export$2e2bcd8739ae039)({\n            sides: 6,\n            size: this.getSize(),\n            margin: margin + ringWidth + (renderRing && ringSize ? ringPadding * radius : 0),\n            rotation: globalRotationRadians,\n            fitSize: false,\n            nailsSpacing: 2\n        });\n        const edgeSize = polygon.sideSize / levels;\n        const nailsLength = edgeSize / (2 * Math.cos(Math.PI / 6));\n        const countPerLevelSide = new Array(levels + (renderCaps ? 1 : 0)).fill(null).map((_, level)=>level * 2 + 1);\n        return {\n            edgeSize: edgeSize,\n            triangleHeight: edgeSize * Math.sqrt(3) / 2,\n            nailsLength: nailsLength,\n            triangleCenterDistance: edgeSize / 2,\n            nailDistance: nailsLength / density,\n            triangleCount: 6 * levels ** 2,\n            countPerLevelSide: countPerLevelSide,\n            globalRotationRadians: globalRotationRadians,\n            radius: radius\n        };\n    }\n    resetStructure() {\n        super.resetStructure();\n        this.points = null;\n        this.#calc = null;\n    }\n    setUpDraw() {\n        super.setUpDraw();\n        const { isMultiColor: isMultiColor, levels: levels, colorPerLevel: colorPerLevel, colorCount: colorCount, renderRing: renderRing, ringSize: ringSize, ringNailCount: ringNailCount, ...config } = this.config;\n        if (!this.#calc) this.#calc = this.getCalc();\n        if (renderRing && ringSize) {\n            const circleConfig = {\n                size: this.size,\n                n: ringNailCount,\n                margin: config.margin,\n                rotation: config.globalRotation\n            };\n            if (this.#circle) this.#circle.setConfig(circleConfig);\n            else this.#circle = new (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039)(circleConfig);\n        } else this.#circle = null;\n        if (!this.points) this.points = this.getPoints();\n        if (!this.stepCount) this.stepCount = this.getStepCount(this.#calc);\n        const realColorCount = isMultiColor ? colorPerLevel ? levels : Math.min(colorCount, levels) : 1;\n        this.color = new (0, $44d9dab6555abf73$export$2e2bcd8739ae039)({\n            ...config,\n            isMultiColor: isMultiColor,\n            colorCount: realColorCount\n        });\n        if (isMultiColor) this.colorMap = this.color.getColorMap({\n            stepCount: realColorCount,\n            colorCount: realColorCount\n        });\n        else this.colorMap = null;\n    }\n    getTrianglePoints({ center: center, rotation: rotation, isCapLevel: isCapLevel, triangleIndexInSide: triangleIndexInSide }) {\n        let missingSide;\n        if (isCapLevel) {\n            const triangleIndex = (triangleIndexInSide + 2) % 3;\n            missingSide = this.#getNextIndexInTriangle(triangleIndex);\n        }\n        // For each side of the triangle, the first point is the center of the triangle:\n        const trianglePoints = new Array(3).fill(null).map((_, i)=>i === missingSide ? [] : [\n                center\n            ]);\n        for(let side = 0; side < 3; side++){\n            if (isCapLevel && side === missingSide) continue;\n            const sideAngle = rotation + side * ((0, $e2b746416d2bf62b$export$f4644083ce95e7e3) / 3);\n            const triangleSidePoints = trianglePoints[side];\n            const cosSideAngle = Math.cos(sideAngle);\n            const sinSideAngle = Math.sin(sideAngle);\n            for(let n = 1; n <= this.config.density; n++){\n                const nNailDistance = n * this.#calc.nailDistance;\n                triangleSidePoints.push([\n                    center[0] + nNailDistance * cosSideAngle,\n                    center[1] + nNailDistance * sinSideAngle\n                ]);\n            }\n        }\n        return trianglePoints;\n    }\n    getPoints() {\n        if (this.points) return this.points;\n        const { levels: levels, renderCaps: renderCaps } = this.config;\n        const largeDistance = this.#calc.nailsLength;\n        const smallDistance = this.#calc.triangleHeight - largeDistance;\n        const levelsPoints = [];\n        const levelsCount = renderCaps ? levels + 1 : levels;\n        for(let level = 0; level < levelsCount; level++){\n            const isCapLevel = renderCaps && level === levels;\n            const levelTrianglesPoints = [];\n            levelsPoints.push(levelTrianglesPoints);\n            const levelSideTriangleCount = this.#calc.countPerLevelSide[level];\n            // Caching distances to avoid repeated calculations for each side:\n            const levelPositions = new Array(levelSideTriangleCount).fill(null).map((_, n)=>{\n                const isFlipped = n % 2 === 0;\n                const trianglePosition = [\n                    this.#calc.triangleCenterDistance * (n - level),\n                    level * this.#calc.triangleHeight + (isFlipped ? largeDistance : smallDistance)\n                ];\n                return {\n                    rotation: Math.atan(trianglePosition[0] / trianglePosition[1]),\n                    distanceFromCenter: Math.sqrt(trianglePosition[0] ** 2 + trianglePosition[1] ** 2)\n                };\n            });\n            for(let side = 0; side < 6; side++){\n                const sideRotation = $7a74ed27f7260395$var$SIDE_ANGLES[side];\n                for(let n = 0; n < levelSideTriangleCount; n++){\n                    if (isCapLevel && n % 2 === 0) {\n                        // Cap triangles are only odd indexes\n                        levelTrianglesPoints.push(null);\n                        continue;\n                    }\n                    const { distanceFromCenter: distanceFromCenter, rotation: rotation } = levelPositions[n];\n                    const triangleCenterAngle = sideRotation - rotation - this.#calc.globalRotationRadians;\n                    const rotatedTrianglePosition = [\n                        this.center[0] + distanceFromCenter * Math.cos(triangleCenterAngle),\n                        this.center[1] - distanceFromCenter * Math.sin(triangleCenterAngle)\n                    ];\n                    const trianglePoints = this.getTrianglePoints({\n                        center: rotatedTrianglePosition,\n                        rotation: sideRotation + side * (0, $e2b746416d2bf62b$export$f4644083ce95e7e3) / 3 - n * $7a74ed27f7260395$var$ANGLE + this.#calc.globalRotationRadians,\n                        isCapLevel: isCapLevel,\n                        triangleIndexInSide: n\n                    });\n                    levelTrianglesPoints.push(trianglePoints);\n                }\n            }\n        }\n        return levelsPoints;\n    }\n    *generateTriangleStrings({ points: points, level: level, indexInSide: indexInSide }) {\n        this.renderer.setColor(this.color.getColor(level));\n        const { density: density, levels: levels } = this.config;\n        const isCapLevel = level === levels;\n        const initialSide = isCapLevel ? this.#getNextIndexInTriangle(indexInSide % 3) : 0;\n        const lastSide = isCapLevel ? initialSide : 2;\n        const lastIndex = isCapLevel ? density : density - 1;\n        for(let side = initialSide; side <= lastSide; side++){\n            const nextSide = this.#getNextIndexInTriangle(side);\n            let prevPoint = points[side][0];\n            for(let n = 0; n <= lastIndex; n++){\n                const isNextSide = n % 2 === 0;\n                const positions = [];\n                const nextSidePoint = isNextSide ? this.config.density - n : n;\n                const targetSide = isNextSide ? nextSide : side;\n                positions.push(points[targetSide][nextSidePoint]);\n                if (n < density) positions.push(points[targetSide][isNextSide ? nextSidePoint - 1 : nextSidePoint + 1]);\n                this.renderer.renderLines(prevPoint, ...positions);\n                prevPoint = positions[positions.length - 1];\n                yield;\n            }\n        }\n    }\n    *generateStringsBetweenTriangles({ triangle1: triangle1, triangle2: triangle2, level: level, triangleIndex: triangleIndex, triangleIndexInSide: triangleIndexInSide, isNextLevel: isNextLevel }) {\n        const { density: density, fillColor: fillColor } = this.config;\n        const levelSideCount = this.#calc.countPerLevelSide[level];\n        const angleShift = triangleIndex % levelSideCount % 3;\n        this.renderer.setColor(fillColor);\n        const isLastTriangleInSide = triangleIndexInSide === levelSideCount - 1;\n        const firstSide = angleShift;\n        const sideIndex = isNextLevel ? [\n            this.#getNextIndexInTriangle(angleShift),\n            this.#getNextIndexInTriangle(angleShift, -1)\n        ] : [\n            firstSide,\n            this.#getNextIndexInTriangle(firstSide, triangleIndexInSide % 2 ? 1 : -1)\n        ];\n        for(let s = 0; s < 2; s++){\n            const order = generateOrderInSide.call(this, s);\n            for (const { pointIndex: pointIndex, triangle1Points: triangle1Points, triangle2Points: triangle2Points } of order){\n                this.renderer.renderLines(triangle1Points[pointIndex], triangle2Points[pointIndex]);\n                yield;\n            }\n        }\n        function* generateOrderInSide(side) {\n            const t1Side = sideIndex[side];\n            const t2Side = getNextTriangleSide.call(this);\n            const triangle1Points = triangle1[t1Side];\n            const triangle2Points = triangle2[t2Side];\n            const last = side ? density : density - 1;\n            if (side === 0) for(let n = 0; n <= last; n++)yield {\n                pointIndex: density - n,\n                triangle1Points: triangle1Points,\n                triangle2Points: triangle2Points\n            };\n            else for(let n = last; n >= 1; n--)yield {\n                pointIndex: density - n,\n                triangle1Points: triangle1Points,\n                triangle2Points: triangle2Points\n            };\n            function getNextTriangleSide() {\n                if (isNextLevel) return this.#getNextIndexInTriangle(t1Side);\n                else {\n                    if (side === 0 && isLastTriangleInSide) return 1;\n                    else {\n                        if (side === 1 && isLastTriangleInSide) return 0;\n                        else return this.#getNextIndexInTriangle(t1Side, 1);\n                    }\n                }\n            }\n        }\n    }\n    #getNextIndexInTriangle(index, direction = 1) {\n        const result = index + direction;\n        if (result < 0) return 2;\n        if (result > 2) return 0;\n        return result;\n    }\n    *generateStrings() {\n        const { fill: fill, renderTriangles: renderTriangles, renderCaps: renderCaps, levels: levels, renderRing: renderRing, ringSize: ringSize, ringColor: ringColor } = this.config;\n        const triangleLevels = this.getPoints();\n        let levelIndex = -1;\n        for (const level of triangleLevels){\n            levelIndex++;\n            const isCapLevel = levelIndex === levels;\n            let triangleIndex = -1;\n            const lastIndexInLevel = level.length - 1;\n            for (const triangle of level){\n                triangleIndex++;\n                const levelSideCount = this.#calc.countPerLevelSide[levelIndex];\n                const triangleIndexInSide = triangleIndex % levelSideCount;\n                if (fill && !isCapLevel) {\n                    if (triangleIndex === 0) yield* this.generateStringsBetweenTriangles({\n                        triangle1: level[lastIndexInLevel],\n                        triangle2: triangle,\n                        level: levelIndex,\n                        triangleIndex: lastIndexInLevel,\n                        triangleIndexInSide: lastIndexInLevel % levelSideCount\n                    });\n                    if (triangleIndex !== lastIndexInLevel) yield* this.generateStringsBetweenTriangles({\n                        triangle1: triangle,\n                        triangle2: level[triangleIndex + 1],\n                        level: levelIndex,\n                        triangleIndex: triangleIndex,\n                        triangleIndexInSide: triangleIndexInSide\n                    });\n                    if (triangleIndexInSide % 2 === 0 && (renderCaps || levelIndex < levels - 1)) {\n                        const side = Math.floor(triangleIndex / levelSideCount);\n                        const nextLevelSideCount = this.#calc.countPerLevelSide[levelIndex + 1];\n                        const nextLevelTriangleIndex = side * nextLevelSideCount + triangleIndexInSide + 1;\n                        yield* this.generateStringsBetweenTriangles({\n                            triangle1: triangle,\n                            triangle2: triangleLevels[levelIndex + 1][nextLevelTriangleIndex],\n                            level: levelIndex,\n                            triangleIndex: triangleIndex,\n                            triangleIndexInSide: triangleIndexInSide,\n                            isNextLevel: true\n                        });\n                    }\n                }\n                const indexInSide = triangleIndex % this.#calc.countPerLevelSide[levelIndex];\n                if (renderTriangles && (!isCapLevel || indexInSide % 2)) yield* this.generateTriangleStrings({\n                    points: triangle,\n                    level: levelIndex,\n                    indexInSide: indexInSide\n                });\n            }\n        }\n        if (renderRing && ringSize) yield* this.#circle.drawRing(this.renderer, {\n            ringSize: ringSize / 2,\n            color: ringColor\n        });\n    }\n    getStepCount(calc) {\n        if (this.stepCount) return this.stepCount;\n        if (!calc) calc = this.getCalc();\n        const { levels: levels, density: density, fill: fill, renderTriangles: renderTriangles, renderCaps: renderCaps, ringNailCount: ringNailCount = 0 } = this.config;\n        const { triangleCount: triangleCount } = calc;\n        const fillStepsPerTriangle = fill ? density * 2 : 0;\n        const triangleSteps = renderTriangles ? density * 3 : 0;\n        const stepsPerTriangle = triangleSteps + fillStepsPerTriangle;\n        const levelsWithFillBetween = levels + (renderCaps ? 1 : 0);\n        const fillStepsBetweenLevels = fillStepsPerTriangle * (levelsWithFillBetween - 1) * 6 * levelsWithFillBetween / 2;\n        const stepsPerCap = density + 1;\n        const capSteps = renderTriangles && renderCaps ? 6 * levels * stepsPerCap : 0;\n        return triangleCount * stepsPerTriangle + capSteps + fillStepsBetweenLevels + ringNailCount;\n    }\n    drawNails() {\n        const triangleLevels = this.getPoints();\n        let index = 0;\n        for (const level of triangleLevels){\n            for (const triangle of level)if (triangle != null) {\n                // A cap level has nulls between caps\n                for (const triangleSide of triangle)for (const point of triangleSide)this.nails.addNail({\n                    point: point,\n                    number: index++\n                });\n            }\n        }\n        if (this.#circle) this.#circle.drawNails(this.nails);\n    }\n    static thumbnailConfig = {\n        levels: 3,\n        density: 3,\n        fill: false,\n        renderRing: true\n    };\n}\n\n\n\n\n\nconst $cfcb4d6877bfaba2$var$spreadModes = {\n    evenly: {\n        f: (layerIndex, { ringSize: ringSize, layers: layers, n: n })=>{\n            const firstLayerDistance = Math.floor(n * ringSize);\n            return Math.floor((layers - layerIndex) * firstLayerDistance / layers);\n        },\n        name: 'Evenly'\n    },\n    distance: {\n        f: (layerIndex, { n: n, ringSize: ringSize, layerDistance: layerDistance })=>{\n            const firstLayerDistance = Math.floor(n * ringSize);\n            if (layerIndex > 0) return firstLayerDistance - layerIndex * layerDistance;\n            return firstLayerDistance;\n        },\n        name: 'Specific distance'\n    }\n};\nconst $cfcb4d6877bfaba2$var$COLOR_CONFIG = (0, $44d9dab6555abf73$export$2e2bcd8739ae039).getConfig({\n    defaults: {\n        isMultiColor: true,\n        color: '#ff0000',\n        multicolorRange: 133,\n        multicolorStart: 239,\n        multicolorByLightness: false,\n        minLightness: 30,\n        maxLightness: 70,\n        colorCount: 4\n    },\n    customControls: [\n        {\n            key: 'colorPerLayer',\n            label: 'Color per layer',\n            defaultValue: true,\n            type: 'checkbox'\n        }\n    ]\n});\nclass $cfcb4d6877bfaba2$export$2e2bcd8739ae039 extends (0, $a64bacef9e98af6b$export$2e2bcd8739ae039) {\n    static type = 'comet';\n    name = 'Comet';\n    id = 'comet';\n    controls = [\n        (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).nailsConfig,\n        {\n            key: 'layers',\n            label: 'Layers',\n            defaultValue: 5,\n            type: 'range',\n            attr: {\n                min: 1,\n                max: 20,\n                step: 1\n            },\n            isStructural: true\n        },\n        {\n            key: 'ringSize',\n            label: 'First layer size',\n            description: 'Nail count from the top center nail to the first connected nail in the first layer',\n            defaultValue: 0.3,\n            type: 'range',\n            attr: {\n                min: 0,\n                max: 1,\n                step: 0.01\n            },\n            displayValue: ({ ringSize: ringSize, n: n })=>Math.floor(n * ringSize),\n            isStructural: true\n        },\n        {\n            key: 'layerSpread',\n            label: 'Layer Spread',\n            type: 'select',\n            defaultValue: 'distance',\n            options: Object.entries($cfcb4d6877bfaba2$var$spreadModes).map(([key, { name: name }])=>({\n                    value: key,\n                    label: name\n                })),\n            isStructural: true\n        },\n        {\n            key: 'layerDistance',\n            label: 'Layer Distance',\n            type: 'range',\n            attr: {\n                min: 1,\n                max: ({ n: n, layers: layers })=>Math.floor(n / 2 / layers),\n                step: 1\n            },\n            defaultValue: 1,\n            isStructural: true,\n            show: ({ layerSpread: layerSpread })=>layerSpread !== 'evenly'\n        },\n        (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).rotationConfig,\n        (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).distortionConfig,\n        (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).displacementConfig,\n        $cfcb4d6877bfaba2$var$COLOR_CONFIG\n    ];\n    defaultValues = {\n        n: 51,\n        layers: 11,\n        colorPerLayer: true,\n        multicolorRange: 203,\n        multicolorStart: 137,\n        ringSize: 0.47,\n        rotation: 0.25,\n        distortion: 0.38,\n        displacementFunc: 'fastInOut',\n        displacementMag: 1.8,\n        displacementFastArea: 0.43,\n        layerSpread: 'distance',\n        layerDistance: 1\n    };\n    #circle;\n    color;\n    setUpDraw() {\n        super.setUpDraw();\n        const circleConfig = {\n            size: this.size,\n            n: this.config.n,\n            margin: this.config.margin,\n            rotation: this.config.rotation,\n            distortion: this.config.distortion,\n            displacementFunc: this.config.displacementFunc,\n            displacementMag: this.config.displacementMag,\n            displacementFastArea: this.config.displacementFastArea\n        };\n        if (this.#circle) this.#circle.setConfig(circleConfig);\n        else this.#circle = new (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039)(circleConfig);\n        if (!this.stepCount) this.stepCount = this.getStepCount();\n        const { isMultiColor: isMultiColor, colorCount: colorCount, layers: layers, colorPerLayer: colorPerLayer } = this.config;\n        const realColorCount = isMultiColor ? colorPerLayer ? layers : Math.min(colorCount, layers) : 1;\n        this.color = new (0, $44d9dab6555abf73$export$2e2bcd8739ae039)({\n            ...this.config,\n            isMultiColor: isMultiColor,\n            colorCount: realColorCount\n        });\n    }\n    getLayerRingDistance(layerIndex) {\n        const spread = $cfcb4d6877bfaba2$var$spreadModes[this.config.layerSpread];\n        if (!spread) throw new Error(`Invalid spread mode, \"${this.config.layerSpread}\"!`);\n        return spread.f(layerIndex, this.config);\n    }\n    getLayerRingStepCount(layerIndex) {\n        const layerRingDistance = this.getLayerRingDistance(layerIndex);\n        return (this.config.n - layerRingDistance + 1) * 2 - 1;\n    }\n    *drawLayer(layerIndex = 0) {\n        const { n: n } = this.config;\n        const ringDistance = this.getLayerRingDistance(layerIndex);\n        const stepCount = n - ringDistance + 1;\n        let prevPoint = this.#circle.getPoint(0);\n        let prevPointIndex = 0;\n        this.renderer.setColor(this.color.getColor(layerIndex));\n        for(let i = 0; i < n - ringDistance + 1; i++){\n            const pointIndex = i + ringDistance;\n            const point = this.#circle.getPoint(pointIndex);\n            this.renderer.renderLines(prevPoint, point);\n            yield;\n            if (i !== stepCount - 1) {\n                prevPointIndex = i + 1;\n                prevPoint = this.#circle.getPoint(prevPointIndex);\n                this.renderer.renderLines(point, prevPoint);\n                yield;\n            }\n        }\n    }\n    *generateStrings() {\n        for(let layer = 0; layer < this.config.layers; layer++)yield* this.drawLayer(layer);\n    }\n    getStepCount() {\n        if (this.stepCount) return this.stepCount;\n        const { layers: layers } = this.config;\n        return new Array(layers).fill(0).reduce((totalStepCount, _, layerIndex)=>totalStepCount + this.getLayerRingStepCount(layerIndex), 0);\n    }\n    drawNails() {\n        this.#circle.drawNails(this.nails);\n    }\n    static thumbnailConfig = {\n        n: 24,\n        layers: 8\n    };\n}\n\n\n\n\n\n\n\n\n\nclass $47fd6f35b394300f$export$2e2bcd8739ae039 extends (0, $a64bacef9e98af6b$export$2e2bcd8739ae039) {\n    static type = 'sun';\n    name = 'Sun';\n    id = 'sun';\n    controls = [\n        {\n            key: 'starGroup',\n            label: 'Star',\n            type: 'group',\n            children: [\n                ...(0, $b103c63dc979d40c$export$c4f94c8b3850a5a9)([\n                    ...(0, $2e2273f8da969026$export$2e2bcd8739ae039).StarConfig,\n                    (0, $44d9dab6555abf73$export$2e2bcd8739ae039).getConfig({\n                        defaults: {\n                            isMultiColor: true,\n                            multicolorRange: 1,\n                            multicolorStart: 237,\n                            color: '#ffffff',\n                            saturation: 40,\n                            multicolorByLightness: true,\n                            minLightness: 20,\n                            maxLightness: 97\n                        },\n                        exclude: [\n                            'colorCount'\n                        ]\n                    })\n                ], 'sides', [\n                    {\n                        key: 'layers',\n                        label: 'Layers',\n                        defaultValue: 4,\n                        type: 'range',\n                        attr: {\n                            min: 1,\n                            max: 20,\n                            step: 1\n                        },\n                        isStructural: true\n                    },\n                    {\n                        key: 'layerSpread',\n                        label: 'Layer spread',\n                        defaultValue: 0.1625,\n                        type: 'range',\n                        displayValue: ({ layerSpread: layerSpread })=>(0, $96d8651f67c6b219$export$f481ea230fad194b)(layerSpread),\n                        attr: {\n                            min: 0.01,\n                            max: 1,\n                            step: 0.02\n                        },\n                        show: ({ layers: layers })=>layers !== 1,\n                        isStructural: true\n                    },\n                    {\n                        key: 'starRadius',\n                        label: 'Star Radius',\n                        defaultValue: 1,\n                        type: 'range',\n                        displayValue: ({ starRadius: starRadius })=>(0, $96d8651f67c6b219$export$f481ea230fad194b)(starRadius),\n                        attr: {\n                            min: 0.2,\n                            max: 1,\n                            step: 0.01\n                        },\n                        isStructural: true,\n                        affectsStepCount: false\n                    }\n                ])\n            ]\n        },\n        {\n            key: 'backdrop',\n            label: 'Backdrop',\n            type: 'group',\n            children: [\n                {\n                    key: 'backdropSize',\n                    label: 'Backdrop size',\n                    defaultValue: 0.5,\n                    type: 'range',\n                    displayValue: ({ backdropSize: backdropSize })=>(0, $96d8651f67c6b219$export$f481ea230fad194b)(backdropSize),\n                    attr: {\n                        min: 0,\n                        max: 1,\n                        step: ({ sideNails: sideNails })=>1 / sideNails\n                    },\n                    isStructural: true\n                },\n                {\n                    key: 'backdropRadius',\n                    label: 'Backdrop radius',\n                    defaultValue: 1,\n                    type: 'range',\n                    displayValue: ({ backdropRadius: backdropRadius })=>(0, $96d8651f67c6b219$export$f481ea230fad194b)(backdropRadius),\n                    attr: {\n                        min: 0,\n                        max: 1,\n                        step: 0.01\n                    },\n                    isStructural: true,\n                    affectsStepCount: false\n                },\n                {\n                    key: 'backdropShift',\n                    label: 'Backdrop shift',\n                    defaultValue: 0,\n                    type: 'range',\n                    displayValue: ({ backdropShift: backdropShift })=>(0, $96d8651f67c6b219$export$f481ea230fad194b)(backdropShift),\n                    attr: {\n                        min: 0,\n                        max: 1,\n                        step: ({ sideNails: sideNails, backdropSize: backdropSize })=>(1 / (sideNails * (1 - backdropSize))).toFixed(3)\n                    },\n                    isStructural: true,\n                    affectsStepCount: false\n                },\n                {\n                    key: 'backdropSkip',\n                    label: 'Backdrop skip',\n                    description: \"If yes, connections in the backdrop are from the backdrop's nail to the second-nearest side, not the ones near it\",\n                    defaultValue: false,\n                    type: 'checkbox',\n                    isStructural: true,\n                    affectsStepCount: false,\n                    show: ({ sides: sides })=>sides > 3\n                },\n                (0, $44d9dab6555abf73$export$2e2bcd8739ae039).getConfig({\n                    defaults: {\n                        isMultiColor: true,\n                        multicolorRange: 20,\n                        multicolorStart: 0,\n                        color: '#ffffff',\n                        saturation: 57,\n                        multicolorByLightness: true,\n                        minLightness: 20,\n                        maxLightness: 40\n                    },\n                    propMapper: ({ key: key, show: show })=>{\n                        const newKey = 'backdrop' + key[0].toUpperCase() + key.slice(1);\n                        const control = {\n                            key: 'backdrop' + key[0].toUpperCase() + key.slice(1),\n                            show: show ? ({ backdropIsMultiColor: backdropIsMultiColor })=>key === 'color' ? !backdropIsMultiColor : backdropIsMultiColor : null\n                        };\n                        if (key === 'multicolorRange') control.attr = {\n                            start: ({ backdropMulticolorStart: backdropMulticolorStart })=>backdropMulticolorStart,\n                            type: 'range'\n                        };\n                        return control;\n                    },\n                    groupLabel: 'Backdrop color',\n                    maxColorCount: 2\n                })\n            ]\n        }\n    ];\n    getCommonControls() {\n        return (0, $b103c63dc979d40c$export$c4f94c8b3850a5a9)(super.getCommonControls(), 'nailsColor', [\n            {\n                key: 'backdropNailsColor',\n                label: 'Backdrop nails color',\n                type: 'color',\n                defaultValue: '#ffffff',\n                show: ({ showNails: showNails })=>showNails\n            },\n            {\n                key: 'backdropNailsRadius',\n                label: 'Backdrop nails radius',\n                type: 'range',\n                defaultValue: 1.5,\n                attr: {\n                    min: 0.5,\n                    max: 5,\n                    step: 0.25\n                },\n                show: ({ showNails: showNails })=>showNails\n            }\n        ]);\n    }\n    #circle = null;\n    #star = null;\n    #calc;\n    #color;\n    #backdropColor;\n    defaultValues = {\n        sideNails: 50,\n        sides: 16,\n        layers: 4,\n        layerSpread: 0.77,\n        backdropSize: 0.26,\n        backdropRadius: 0.9,\n        backdropShift: 0.59,\n        backdropColorCount: 2,\n        centerRadius: 0.2,\n        maxCurveSize: 0.64,\n        rotation: 0.5,\n        saturation: 73,\n        multicolorStart: 206,\n        multicolorRange: 1,\n        multicolorByLightness: true,\n        minLightness: 35,\n        maxLightness: 100,\n        nailsColor: '#000000',\n        backdropNailsColor: '#ffffff',\n        backdropNailsRadius: 2.275\n    };\n    getCalc() {\n        const { sideNails: sideNails, backdropSize: backdropSize, layers: layers } = this.config;\n        return {\n            backdropNails: Math.floor(sideNails * backdropSize)\n        };\n    }\n    resetStructure() {\n        super.resetStructure();\n        this.#calc = null;\n    }\n    setUpDraw() {\n        super.setUpDraw();\n        const { margin: margin = 0, layers: layers, backdropRadius: backdropRadiusConfig = 1, backdropSize: backdropSize, rotation: rotation, sides: sides, starRadius: starRadiusConfig = 1, backdropColorCount: backdropColorCount } = this.config;\n        const center = this.size.map((v)=>v / 2);\n        const radius = Math.min(...center) - margin;\n        const starRadius = backdropSize && starRadiusConfig < backdropRadiusConfig ? radius * starRadiusConfig / backdropRadiusConfig : radius;\n        const backdropRadius = backdropRadiusConfig < starRadiusConfig ? radius * backdropRadiusConfig / starRadiusConfig : radius;\n        if (!this.#calc) this.#calc = this.getCalc();\n        const starConfig = {\n            ...this.config,\n            radius: starRadius,\n            size: this.size\n        };\n        if (this.#star) this.#star.setConfig(starConfig);\n        else this.#star = new (0, $2e2273f8da969026$export$2e2bcd8739ae039)(starConfig);\n        this.#color = new (0, $44d9dab6555abf73$export$2e2bcd8739ae039)({\n            ...this.config,\n            colorCount: layers\n        });\n        // @ts-ignore this is fine for now, until the color config is managed in a single control\n        this.#backdropColor = new (0, $44d9dab6555abf73$export$2e2bcd8739ae039)({\n            ...(0, $c29d66861308df7e$export$781522908e4e76a1)(this.config, (key)=>{\n                const match = key.match(/^backdrop(\\w)(.+)/);\n                return match ? match[1].toLowerCase() + match[2] : key;\n            }),\n            colorCount: backdropColorCount\n        });\n        const circleConfig = {\n            size: this.size,\n            n: sides,\n            rotation: -1 / sides / 2 + (rotation ? rotation / sides : 0),\n            radius: backdropRadius\n        };\n        if (this.#circle) this.#circle.setConfig(circleConfig);\n        else this.#circle = new (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039)(circleConfig);\n    }\n    *drawStar(size) {\n        yield* this.#star.generateStrings(this.renderer, {\n            size: size\n        });\n    }\n    *generateLayers() {\n        const { sideNails: sideNails, layerSpread: layerSpread, layers: layers } = this.config;\n        for(let layer = 0; layer < layers; layer++){\n            const color = this.#color.getColor(layer);\n            this.renderer.setColor(color);\n            const layerSize = this.#getLayerSize(layer);\n            yield* this.drawStar(layerSize);\n        }\n    }\n    *drawBackdrop() {\n        // For each side, add a nail between two star sides, at the specified backdropRadius.\n        // For the backdrop size, connect the nail to the number of points in the star for the two sides near the backdrop nail\n        const { backdropNails: backdropNails } = this.#calc;\n        const { sides: sides, backdropShift: backdropShift, sideNails: sideNails, backdropSkip: backdropSkip } = this.config;\n        const shouldSkip = backdropSkip && sides > 3;\n        let prevPoint;\n        let currentSide = 0;\n        const shift = Math.floor(backdropShift * (sideNails - backdropNails));\n        let currentSideIndex = shift + backdropNails - 1;\n        for(let side = 0; side < sides; side++){\n            this.renderer.setColor(this.#backdropColor.getColor(side % 2 ? 0 : 1));\n            const backdropPoint = this.#circle.getPoint(shouldSkip ? (side + 1) % sides : side);\n            let alternate = false;\n            const direction = side % 2 ? 1 : -1; // 1 if backdrop threading starts at the bottom and goes up, -1 if it goes down\n            prevPoint = this.#star.getPoint(side, currentSideIndex);\n            for(let i = 0; i < backdropNails; i++){\n                this.renderer.renderLines(prevPoint, backdropPoint);\n                yield;\n                currentSide = (alternate ? side : side + (shouldSkip ? 3 : 1)) % sides;\n                prevPoint = this.#star.getPoint(currentSide, currentSideIndex);\n                this.renderer.renderLines(backdropPoint, prevPoint);\n                yield;\n                if (i < backdropNails - 1) {\n                    alternate = !alternate;\n                    currentSideIndex += direction;\n                    const nextPoint = this.#star.getPoint(currentSide, currentSideIndex);\n                    this.renderer.renderLines(prevPoint, nextPoint);\n                    prevPoint = nextPoint;\n                }\n            }\n        }\n    }\n    *generateStrings() {\n        yield* this.drawBackdrop();\n        yield* this.generateLayers();\n    }\n    drawNails() {\n        const { backdropSize: backdropSize, backdropNailsColor: backdropNailsColor, backdropNailsRadius: backdropNailsRadius } = this.config;\n        this.#star.drawNails(this.nails);\n        if (backdropSize) {\n            const circleNails = [];\n            for (const circleNail of this.#circle.generateNails())circleNails.push(circleNail);\n            this.nails.addGroup(circleNails, {\n                color: backdropNailsColor,\n                radius: backdropNailsRadius\n            });\n        }\n    }\n    #getLayerSize(layer) {\n        const { layers: layers, layerSpread: layerSpread, sideNails: sideNails } = this.config;\n        return Math.max(1, sideNails - layer * Math.max(1, Math.floor(sideNails / layers * layerSpread)));\n    }\n    getStepCount() {\n        const { layers: layers, sides: sides } = this.config;\n        const { backdropNails: backdropNails } = this.getCalc();\n        const backdropStepCount = sides * backdropNails * 2;\n        let stepCount = backdropStepCount;\n        for(let layer = 0; layer < layers; layer++){\n            const layerSize = this.#getLayerSize(layer);\n            stepCount += (0, $2e2273f8da969026$export$2e2bcd8739ae039).getStepCount(this.config, {\n                size: layerSize\n            });\n        }\n        return stepCount;\n    }\n    static thumbnailConfig = {\n        sideNails: 10,\n        backdropNailsRadius: 0.5\n    };\n}\n\n\n\n\n\n\n\n\nclass $54d330e2d674b207$export$2e2bcd8739ae039 extends (0, $a64bacef9e98af6b$export$2e2bcd8739ae039) {\n    static type = 'lotus';\n    name = 'Lotus';\n    id = 'lotus';\n    controls = [\n        {\n            key: 'sides',\n            label: 'Sides',\n            description: 'How many petals there are in the Lotus',\n            type: 'range',\n            defaultValue: 16,\n            attr: {\n                min: 5,\n                max: 64,\n                step: 1\n            },\n            isStructural: true\n        },\n        {\n            key: 'density',\n            label: 'Density',\n            type: 'range',\n            defaultValue: 144,\n            attr: {\n                min: 1,\n                max: 500,\n                step: ({ sides: sides })=>sides\n            },\n            isStructural: true\n        },\n        (0, $b103c63dc979d40c$export$2d97e2da46663803)((0, $dd4af12b0f1337d9$export$2e2bcd8739ae039).rotationConfig, 'snap'),\n        {\n            key: 'removeSections',\n            label: 'Remove sections',\n            type: 'range',\n            attr: {\n                min: 0,\n                max: 1,\n                step: ({ sides: sides, renderCenter: renderCenter })=>1 / $54d330e2d674b207$var$getSectionCountToRemove(sides, renderCenter)\n            },\n            defaultValue: 0,\n            displayValue: ({ removeSections: removeSections, sides: sides, renderCenter: renderCenter })=>Math.round(removeSections * $54d330e2d674b207$var$getSectionCountToRemove(sides, renderCenter)),\n            isStructural: true\n        },\n        {\n            key: 'fit',\n            label: 'Fit',\n            type: 'checkbox',\n            defaultValue: true,\n            show: ({ removeSections: removeSections })=>removeSections,\n            isStructural: true\n        },\n        {\n            key: 'renderCenter',\n            label: 'Render center',\n            type: 'checkbox',\n            defaultValue: true,\n            isStructural: true\n        },\n        {\n            key: 'centerRadius',\n            label: 'Center radius',\n            type: 'range',\n            defaultValue: 0,\n            attr: {\n                min: 0,\n                max: 1,\n                step: 0.01\n            },\n            displayValue: ({ centerRadius: centerRadius })=>(0, $96d8651f67c6b219$export$f481ea230fad194b)(centerRadius),\n            show: ({ renderCenter: renderCenter })=>renderCenter,\n            isStructural: true\n        },\n        {\n            key: 'renderCenterNails',\n            label: 'Render center nails',\n            type: 'checkbox',\n            defaultValue: false,\n            isStructural: true,\n            show: ({ renderCenter: renderCenter })=>renderCenter\n        },\n        (0, $44d9dab6555abf73$export$2e2bcd8739ae039).getConfig({\n            defaults: {\n                isMultiColor: true,\n                multicolorStart: 20,\n                multicolorRange: 26,\n                multicolorByLightness: true,\n                minLightness: 32,\n                maxLightness: 85,\n                saturation: 100,\n                colorCount: 8\n            },\n            customControls: [\n                {\n                    key: 'radialColor',\n                    label: 'Radial color',\n                    defaultValue: false,\n                    type: 'checkbox'\n                }\n            ],\n            maxColorCount: 32\n        })\n    ];\n    defaultValues = {\n        nailsColor: '#a08346'\n    };\n    #calc;\n    #color;\n    getCalc() {\n        const { sides: sides, density: density, margin: margin, rotation: rotation, removeSections: removeSections, fit: fit, centerRadius: centerRadiusPercent, renderCenter: renderCenter } = this.config;\n        const d = 0.5; // The helper circle's center is right between the pattern center and the edge\n        const size = this.getSize();\n        let radius = Math.min(...size) * d / 2;\n        const sideAngle = (0, $e2b746416d2bf62b$export$f4644083ce95e7e3) / sides;\n        const densityNailCount = fixNailsCount(density);\n        const baseCircleConfig = {\n            n: densityNailCount,\n            center: [\n                0,\n                0\n            ],\n            size: [\n                0,\n                0\n            ],\n            radius: 0,\n            rotation: 0\n        };\n        let petalSectionsToRemove = 0;\n        if (removeSections) {\n            const maxPetalSectionsToRemove = $54d330e2d674b207$var$getSectionCountToRemove(sides, renderCenter);\n            petalSectionsToRemove = Math.min(maxPetalSectionsToRemove, Math.round(removeSections * maxPetalSectionsToRemove));\n            const angleStart = sideAngle * petalSectionsToRemove;\n            if (fit) {\n                // Since we removed sections and now the pattern is smaller than the canvas size, we fit the remaining shape to fit on canvas\n                // this is done by:\n                // 1. Calculating the new outer edge of the shape, after removing sections\n                // 2. Increase the size of the circles that create petals by the inverse ratio of the new to original size\n                // 3. Since the circles are now larger, increase the number of nails in the circles by the size ratio, to maintain density.\n                const topSectionHeight = 2 * radius * Math.sin((Math.PI - angleStart) / 2);\n                const fitAspectRatio = (2 * radius - margin) / topSectionHeight;\n                baseCircleConfig.n = removeSectionsNailCount(fixNailsCount(density * fitAspectRatio), petalSectionsToRemove);\n                radius *= fitAspectRatio;\n            } else // the `density` config is for a full circle, so making the number of nails on a petal relative to the size of the petal arc relative to a full circle\n            baseCircleConfig.n = removeSectionsNailCount(densityNailCount, petalSectionsToRemove);\n            Object.assign(baseCircleConfig, {\n                angleStart: angleStart,\n                angleEnd: (0, $e2b746416d2bf62b$export$f4644083ce95e7e3) - angleStart\n            });\n        }\n        Object.assign(baseCircleConfig, {\n            size: [\n                radius - margin / 2,\n                radius - margin / 2\n            ],\n            radius: radius - margin / 2\n        });\n        // Draw circles around the center point. For this, create a helper Circle, so its points can be used as centers for the lotus circles:\n        const helperCircle = new (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039)({\n            n: sides,\n            size: size.map((v)=>v * d - margin),\n            center: this.center,\n            radius: radius - margin / 2,\n            rotation: rotation\n        });\n        const circles = new Array(sides).fill(null).map((_, i)=>new (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039)({\n                ...baseCircleConfig,\n                center: helperCircle.getPoint(i),\n                rotation: rotation - i / sides\n            }));\n        const calc = {\n            circles: circles,\n            circleNailsCount: baseCircleConfig.n,\n            sideAngle: sideAngle,\n            sections: $54d330e2d674b207$var$getSectionsCount(sides),\n            removedSections: petalSectionsToRemove,\n            nailsPerSection: Math.floor(baseCircleConfig.n / (sides - 2 * petalSectionsToRemove)),\n            nailsPerCircle: baseCircleConfig.n\n        };\n        if (renderCenter && centerRadiusPercent) {\n            const lastSection = calc.sections - 1 - calc.removedSections;\n            const maxCenterRadiusPoint = circles[0].getPoint(lastSection * calc.nailsPerSection);\n            const maxCenterRadius = Math.floor(Math.sqrt(Math.abs(helperCircle.center[0] - maxCenterRadiusPoint[0]) ** 2 + Math.abs(helperCircle.center[1] - maxCenterRadiusPoint[1]) ** 2));\n            const centerCircleRadius = centerRadiusPercent * maxCenterRadius;\n            calc.centerCircle = new (0, $dd4af12b0f1337d9$export$2e2bcd8739ae039)({\n                n: sides,\n                center: helperCircle.center,\n                size: [\n                    centerCircleRadius,\n                    centerCircleRadius\n                ],\n                radius: centerCircleRadius,\n                rotation: -Math.ceil((sides - 4) / 2) / 2 / sides\n            });\n        }\n        return calc;\n        function fixNailsCount(nailsCount) {\n            return Math.max(sides, nailsCount - nailsCount % sides);\n        }\n        function removeSectionsNailCount(fullCircleNailCount, sectionsToRemove) {\n            return Math.round(fullCircleNailCount * (1 - 2 * sectionsToRemove / sides) + 1);\n        }\n    }\n    resetStructure() {\n        super.resetStructure();\n        this.#calc = null;\n    }\n    setUpDraw() {\n        super.setUpDraw();\n        if (!this.#calc) this.#calc = this.getCalc();\n        let colorCount = this.config.radialColor ? this.#calc.sections - this.#calc.removedSections - 1 : this.config.colorCount;\n        if (!this.config.renderCenter && this.config.radialColor) colorCount--;\n        this.#color = new (0, $44d9dab6555abf73$export$2e2bcd8739ae039)({\n            ...this.config,\n            colorCount: colorCount\n        });\n    }\n    #getPatchColor(circleIndex, section) {\n        const { radialColor: radialColor } = this.config;\n        const { removedSections: removedSections } = this.#calc;\n        return this.#color.getColor(radialColor ? section - removedSections : circleIndex);\n    }\n    *#drawPatch(circleIndex, section) {\n        const { sides: sides } = this.config;\n        const { circles: circles, sections: sections, nailsPerSection: nailsPerSection, nailsPerCircle: nailsPerCircle, removedSections: removedSections } = this.#calc;\n        const color = this.#getPatchColor(circleIndex, section);\n        const circle = circles[circleIndex];\n        this.renderer.setColor(color);\n        const prevCircle = this.#calc.circles[circleIndex === 0 ? sides - 1 : circleIndex - 1];\n        if (section === 0) {\n            // For first section (outtermost): connectPoint is `prevCircle[sideAngle * 2]\n            const connectPoint = prevCircle.getPoint(nailsPerSection * 2);\n            for(let i = nailsPerCircle - nailsPerSection; i < nailsPerCircle; i++){\n                this.renderer.renderLines(circle.getPoint(i), connectPoint);\n                yield;\n            }\n            for(let i = 0; i <= nailsPerSection; i++){\n                this.renderer.renderLines(circle.getPoint(i), connectPoint);\n                yield;\n            }\n        } else {\n            // For middle sections, connectPoint is `circleIndex - 1`, (sideAngle * section + 1). Connect circleIndex[section] and `circleIndex + section`[section]\n            const isLastSection = section === sections - 2;\n            const connectPoint = isLastSection && this.#calc.centerCircle ? this.#calc.centerCircle.getPoint(circleIndex) : prevCircle.getPoint(nailsPerSection * (section + 2 - removedSections) - (sides % 2 && section === sections - 2 ? nailsPerSection / 2 : 0));\n            const firstCircle = circles[(circleIndex + section) % sides];\n            const firstCircleStart = nailsPerCircle - (section + 1 - removedSections) * nailsPerSection - (removedSections ? 1 : 0);\n            for(let i = 0; i <= nailsPerSection; i++){\n                this.renderer.renderLines(firstCircle.getPoint(firstCircleStart + i), connectPoint);\n                yield;\n            }\n            const startIndex = (section - removedSections) * nailsPerSection + 1;\n            for(let i = startIndex; i < startIndex + nailsPerSection; i++){\n                this.renderer.renderLines(circle.getPoint(i), connectPoint);\n                yield;\n            }\n        }\n    }\n    *generateStrings() {\n        for (const { side: side, section: section } of this.#generatePatches())yield* this.#drawPatch(side, section);\n    }\n    *#generatePatches() {\n        const { radialColor: radialColor, sides: sides, renderCenter: renderCenter } = this.config;\n        const { sections: sections, removedSections: removedSections } = this.#calc;\n        const lastSection = sections - (renderCenter ? 1 : 2);\n        if (radialColor) {\n            for(let section = removedSections; section < lastSection; section++)for(let side = 0; side < sides; side++)yield {\n                side: side,\n                section: section\n            };\n        } else {\n            for(let side = 0; side < sides; side++)for(let section = removedSections; section < lastSection; section++)yield {\n                side: side,\n                section: section\n            };\n        }\n    }\n    drawNails() {\n        const { renderCenter: renderCenter, renderCenterNails: renderCenterNails } = this.config;\n        const { circles: circles, circleNailsCount: circleNailsCount, centerCircle: centerCircle } = this.#calc;\n        circles.forEach((circle, circleIndex)=>{\n            circle.drawNails(this.nails, {\n                getNumber: (i)=>`${circleIndex + 1}_${i}`,\n                excludedNailRanges: renderCenterNails ? null : this.#getCenterExcludedNails()\n            });\n        });\n        if (renderCenter) {\n            if (centerCircle) centerCircle.drawNails(this.nails, {\n                getNumber: (i)=>`C_${i + 1}`\n            });\n            else this.nails.addNail({\n                point: this.center,\n                number: 'C'\n            });\n        }\n    }\n    #getCenterExcludedNails() {\n        const { renderCenter: renderCenter } = this.config;\n        const { sections: sections, nailsPerSection: nailsPerSection, nailsPerCircle: nailsPerCircle, removedSections: removedSections } = this.#calc;\n        const innerSectionNailsStart = (sections - 1 - removedSections - (renderCenter ? 0 : 1)) * nailsPerSection + 1;\n        const innerSectionNailsEnd = nailsPerCircle - innerSectionNailsStart;\n        return [\n            [\n                innerSectionNailsStart,\n                innerSectionNailsEnd\n            ]\n        ];\n    }\n    getStepCount() {\n        const { nailsPerSection: nailsPerSection, sections: sections, removedSections: removedSections } = this.getCalc();\n        const { sides: sides } = this.config;\n        const patchCount = 2 * nailsPerSection + 1;\n        const sideStepCount = patchCount * (sections - removedSections - 1);\n        return sides * sideStepCount;\n    }\n    static thumbnailConfig = {};\n}\nfunction $54d330e2d674b207$var$getSectionsCount(sides) {\n    return sides % 2 ? Math.ceil(sides / 2) : sides / 2;\n}\nfunction $54d330e2d674b207$var$getSectionCountToRemove(sides, renderCenter) {\n    return $54d330e2d674b207$var$getSectionsCount(sides) - (renderCenter ? 2 : 3);\n}\n\n\nconst $3eff4f8917d513a6$var$patternTypes = [\n    (0, $ca4a2eb6736370e4$export$2e2bcd8739ae039),\n    (0, $8db9d587e082a0d9$export$2e2bcd8739ae039),\n    (0, $ad2ceb60c48a58dd$export$2e2bcd8739ae039),\n    (0, $44064e6908c034c2$export$2e2bcd8739ae039),\n    (0, $63660c6a2fc9a003$export$2e2bcd8739ae039),\n    (0, $33e9badd1f194d7c$export$2e2bcd8739ae039),\n    (0, $aa2c32cdcace5ae2$export$2e2bcd8739ae039),\n    (0, $1530a0f3e43122ac$export$2e2bcd8739ae039),\n    (0, $3f55ac726d5ebe61$export$2e2bcd8739ae039),\n    (0, $7e0f39c01d255ee0$export$2e2bcd8739ae039),\n    (0, $5498d6506310c764$export$2e2bcd8739ae039),\n    (0, $7a74ed27f7260395$export$2e2bcd8739ae039),\n    (0, $cfcb4d6877bfaba2$export$2e2bcd8739ae039),\n    (0, $47fd6f35b394300f$export$2e2bcd8739ae039),\n    (0, $54d330e2d674b207$export$2e2bcd8739ae039)\n];\nvar $3eff4f8917d513a6$export$2e2bcd8739ae039 = $3eff4f8917d513a6$var$patternTypes;\n\n\nconst $644cb43818f0710b$var$DEFAULT_THUMB_COLOR = 'white';\nconst $644cb43818f0710b$var$FULL_GAMUT_GRADIENT = 'linear-gradient(to right in hsl longer hue, hsl(1 100 50), hsl(360 100 50))';\nclass $644cb43818f0710b$export$2e2bcd8739ae039 extends HTMLElement {\n    static formAssociated = true;\n    internals;\n    start = 1;\n    colorThumb = false;\n    reverse = false;\n    type = 'hue';\n    #input = null;\n    constructor(){\n        super();\n        this.attachShadow({\n            mode: 'open',\n            delegatesFocus: true\n        });\n        this.shadowRoot.innerHTML = `\n        <string-art-range-input min=\"1\" max=\"360\" step=\"1\" />\n    `;\n        this.#input = this.shadowRoot.querySelector('string-art-range-input');\n        this.internals = this.attachInternals();\n    }\n    static get observedAttributes() {\n        return [\n            'start',\n            'colorthumb',\n            'value',\n            'reverse',\n            'type'\n        ];\n    }\n    attributeChangedCallback(name, oldVal, newVal) {\n        if (name === 'value') this.value = newVal;\n        if (name === 'start') {\n            this.start = parseInt(newVal, 10);\n            this.#setBackground();\n        }\n        if (name === 'reverse') {\n            this.reverse = !!newVal;\n            this.#setBackground();\n        }\n        if (name === 'colorthumb') {\n            this.colorThumb = !!newVal;\n            this.#setThumbColor();\n        // Update color thumb\n        }\n        if (name === 'type') {\n            this.type = newVal === 'range' ? 'range' : 'hue';\n            this.#setBackground();\n        }\n    }\n    get value() {\n        return this.#input.value;\n    }\n    set value(v) {\n        this.#input.value = v;\n        this.#setBackground();\n        if (this.colorThumb) this.#setThumbColor();\n    }\n    connectedCallback() {\n        if (this.hasAttribute('value')) this.value = parseInt(this.getAttribute('value'));\n        if (this.hasAttribute('colorthumb')) this.colorThumb = true;\n        this.#setThumbColor();\n        this.#input.addEventListener('input', (e)=>this.#handleInput(e));\n    }\n    #handleInput(e) {\n        const value = this.value;\n        this.internals.setFormValue(String(value));\n        this.dispatchEvent(new CustomEvent('input', {\n            detail: {\n                value: value\n            }\n        }));\n        this.#setBackground();\n        this.#setThumbColor();\n    }\n    disconnectedCallback() {\n    // Destroy EditorControls here\n    }\n    focus() {}\n    blur() {}\n    #setBackground() {\n        const background = this.type === 'range' ? `linear-gradient(to ${this.reverse ? 'left' : 'right'} in hsl ${this.value >= 180 ? 'longer' : 'shorter'} hue, hsl(${this.start} 100 50), hsl(${// Fixes a bug in Chrome, that for a 180 deg hue gradient, it always goes in reverse\n        this.start + (this.value === 180 ? 181 : this.value)} 100 50))` : $644cb43818f0710b$var$FULL_GAMUT_GRADIENT;\n        this.#input.setAttribute('background', background);\n    }\n    #setThumbColor() {\n        const thumbColor = this.colorThumb ? `hsl(${this.value}deg 100 50)` : $644cb43818f0710b$var$DEFAULT_THUMB_COLOR;\n        this.#input.setAttribute('thumbcolor', thumbColor);\n    }\n}\ncustomElements.define('string-art-hue-input', $644cb43818f0710b$export$2e2bcd8739ae039);\n\n\nconst $afb5e8cb2003dfda$var$DEFAULT_SNAP_DISTANCE = 0.05;\nconst $afb5e8cb2003dfda$var$THUMB_RADIUS = 8;\nconst $afb5e8cb2003dfda$var$TICK_WIDTH = 2;\nconst $afb5e8cb2003dfda$var$TICK_COLOR = 'rgba(0,0,0,.2)';\nconst $afb5e8cb2003dfda$var$FAR_VALUES_DISTANCE = 0.2; // values are considered far from each other if they are at least a fifth of the width of the input apart\nclass $afb5e8cb2003dfda$export$2e2bcd8739ae039 extends HTMLElement {\n    static formAssociated = true;\n    internals;\n    min;\n    max;\n    #input = null;\n    #backgroundStyle = null;\n    #snap = $afb5e8cb2003dfda$var$DEFAULT_SNAP_DISTANCE;\n    #prevValue = null;\n    #prevSnapValue = null;\n    #tickValues = null;\n    #snapDistance = null;\n    #background = null;\n    #thumbColor = null;\n    #snapDisabledTick = null;\n    #resizeObserver;\n    constructor(){\n        super();\n        this.attachShadow({\n            mode: 'open',\n            delegatesFocus: true\n        });\n        this.shadowRoot.innerHTML = `\n          <style>\n            input[type=\"range\"] {\n              width: 100%;\n              appearance: none;\n              -webkit-appearance: none; /* remove iOS default */\n              background: transparent;\n              border: none;\n              margin: 2px;\n              cursor: pointer;\n            }\n\n            input[type=\"range\"]::-webkit-slider-thumb {\n              appearance: none;\n              -webkit-appearance: none;\n              width: ${$afb5e8cb2003dfda$var$THUMB_RADIUS * 2}px;\n              height: ${$afb5e8cb2003dfda$var$THUMB_RADIUS * 2}px;\n              border-radius: 50%;\n              background: var(--color-input);\n              cursor: pointer;\n              border: none;\n              margin-top: -4px;\n              z-index: 10;\n              box-shadow: 0 0 5px rgba(0,0,0,.5)\n            }\n\n            input[type=\"range\"]::-webkit-slider-thumb:hover {\n              background: var(--color-input-hover);\n            }\n              \n            input[type=\"range\"]:active::-webkit-slider-thumb {\n              background: var(--color-input-active);\n            }\n\n            input[type=\"range\"]::-webkit-slider-runnable-track {\n              height: 8px;\n              border-radius: 4px;\n              margin: 0;\n            }\n          </style>\n          <style id=\"background\"></style>\n          <input type=\"range\">\n        `;\n        this.#input = this.shadowRoot.querySelector('input[type=\"range\"]');\n        this.#backgroundStyle = this.shadowRoot.querySelector('#background');\n        this.#snap = $afb5e8cb2003dfda$var$DEFAULT_SNAP_DISTANCE;\n        this.#prevSnapValue = null;\n        this.internals = this.attachInternals();\n    }\n    static get observedAttributes() {\n        return [\n            'min',\n            'max',\n            'value',\n            'step',\n            'snap',\n            'background',\n            'thumbcolor'\n        ];\n    }\n    attributeChangedCallback(name, oldVal, newVal) {\n        if (name === 'snap') this.#tickValues = this.getTickValues();\n        else if (this.#input) this.#input[name] = newVal;\n        if (name === 'min' || name === 'max') this[name] = Number(newVal);\n        let value;\n        if (name === 'value') value = Number(newVal);\n        if (name === 'background') this.#background = newVal;\n        if (name === 'thumbcolor') this.#thumbColor = newVal;\n        if (this.min != null && this.max != null) {\n            if (this.min > this.max) {\n                this.max = this.min;\n                this.#input.max = String(this.min);\n            }\n            this.#snapDistance = (this.max - this.min) * this.#snap || $afb5e8cb2003dfda$var$DEFAULT_SNAP_DISTANCE;\n            if (this.#tickValues && this.value != null) {\n                const snappedValue = this.getClosestTick(value);\n                if (snappedValue != null) this.#prevSnapValue = snappedValue;\n            }\n        }\n        this.#setStyle();\n    }\n    get value() {\n        return Number(this.#input.value);\n    }\n    set value(v) {\n        this.#input.value = String(v);\n        this.#setStyle();\n    }\n    connectedCallback() {\n        [\n            'min',\n            'max',\n            'value',\n            'step'\n        ].forEach((attr)=>{\n            if (this.hasAttribute(attr)) this.#input[attr] = this.getAttribute(attr);\n        });\n        this.#tickValues = this.getTickValues();\n        this.#resizeObserver = new ResizeObserver((entries)=>{\n            for (let entry of entries){\n                const width = entry.contentRect.width;\n                this.#setStyle();\n            }\n        });\n        this.#resizeObserver.observe(this.#input);\n        this.#input.addEventListener('input', ()=>this.handleInput());\n        this.#input.addEventListener('keydown', (e)=>this.handleKeydown(e));\n        this.#input.addEventListener('change', ()=>this.#snapDisabledTick = null);\n        this.tabIndex = 0;\n    }\n    disconnectedCallback() {\n        this.#resizeObserver.unobserve(this);\n    }\n    getTickValues() {\n        const ticks = this.getAttribute('snap');\n        const ticksMatch = ticks?.match(/\\d+(\\.\\d+)?/g);\n        if (!ticksMatch) return [];\n        return ticksMatch.map(Number).filter((n)=>!isNaN(n)).sort();\n    }\n    #shouldAvoidSnap(newValue, closestTick) {\n        if (closestTick == null) closestTick = this.getClosestTick(newValue);\n        if (closestTick == null) return true;\n        // If moving away from the snap value, don't snap:\n        const distanceFromTick = Math.abs(newValue - closestTick);\n        if (distanceFromTick >= this.#snapDistance / 2 && distanceFromTick > Math.abs(this.#prevValue - closestTick)) return true;\n        return false;\n    }\n    // Checks whether two values are far apart,\n    #areValuesFar(value1, value2) {\n        const distance = Math.abs(value1 - value2) / (this.max - this.min);\n        return distance >= $afb5e8cb2003dfda$var$FAR_VALUES_DISTANCE;\n    }\n    focus() {\n        this.#input.focus();\n    }\n    blur() {\n        this.#input.blur();\n    }\n    handleInput() {\n        const value = Number(this.#input.value);\n        const closestTick = this.getClosestTick(value);\n        this.internals.setFormValue(this.#input.value);\n        if (closestTick != null && this.#snapDisabledTick !== closestTick && this.#shouldAvoidSnap(value, closestTick)) this.#snapDisabledTick = closestTick;\n        if (closestTick !== this.#snapDisabledTick) {\n            if (closestTick !== null) {\n                this.#input.value = String(closestTick);\n                if (closestTick !== this.#prevSnapValue) {\n                    this.#vibrate();\n                    this.#prevSnapValue = closestTick;\n                }\n            } else if (this.#prevSnapValue != null) this.#prevSnapValue = null;\n        }\n        if (this.#snapDisabledTick != null && closestTick == null && this.#areValuesFar(value, this.#snapDisabledTick)) this.#snapDisabledTick = null;\n        this.#setStyle();\n        this.#prevValue = value;\n        this.dispatchEvent(new CustomEvent('input', {\n            detail: {\n                value: this.#input.value\n            }\n        }));\n    }\n    handleKeydown(event) {\n        event.preventDefault();\n        const step = Number(this.#input.step || 1);\n        const value = Number(this.#input.value);\n        let newValue;\n        if (event.key === 'ArrowLeft') newValue = Math.max(this.min, value - step);\n        else if (event.key === 'ArrowRight') newValue = Math.min(this.max, value + step);\n        else if (event.key === 'ArrowUp') {\n            const next = this.#tickValues.find((t)=>t > value);\n            if (next !== undefined) newValue = next;\n            else if (value !== this.max) // no next tick found, go to max\n            newValue = this.max;\n        } else if (event.key === 'ArrowDown') {\n            const reversed = [\n                ...this.#tickValues\n            ].reverse();\n            const prev = reversed.find((t)=>t < value);\n            if (prev !== undefined) newValue = prev;\n            else if (value !== this.min) newValue = this.min;\n        }\n        if (newValue != null) {\n            this.value = newValue;\n            this.#prevValue = newValue;\n            // emit event and prevent default for arrow keys\n            this.dispatchEvent(new CustomEvent('input', {\n                detail: {\n                    value: newValue\n                },\n                bubbles: true,\n                composed: true\n            }));\n        }\n        return false;\n    }\n    getClosestTick(value) {\n        if (!this.#tickValues || this.#tickValues.length === 0) return null;\n        for (const tickValue of this.#tickValues){\n            const distance = Math.abs(value - tickValue);\n            if (distance <= this.#snapDistance) return tickValue;\n        }\n        return null;\n    }\n    #vibrate() {\n        if ('vibrate' in navigator) navigator.vibrate(10);\n    }\n    #setStyle() {\n        const inputWidth = this.#input.clientWidth;\n        if (!inputWidth) return;\n        const valueInRange = this.value - this.min;\n        const range = this.max - this.min;\n        const availableWidth = inputWidth - 2 * $afb5e8cb2003dfda$var$THUMB_RADIUS;\n        const valueWidth = $afb5e8cb2003dfda$var$THUMB_RADIUS + availableWidth * valueInRange / range;\n        // The center of the thumb of the range input doesn't reach 0 and 100%, so the actual range to display leaves out the thumb's radius on the left and right.\n        // Due to this, the ticks are placed in the constricted range of [THUMB_RADIUS::inputWidth - 2 * THUMB_RADIUS]\n        const tickPositions = this.#tickValues?.filter((v)=>v !== this.min && v !== this.max).map((v)=>$afb5e8cb2003dfda$var$THUMB_RADIUS + availableWidth * (v - this.min) / range - $afb5e8cb2003dfda$var$TICK_WIDTH / 2);\n        const tickPositionsInGradient = tickPositions?.map((p)=>`transparent ${p}px, ${$afb5e8cb2003dfda$var$TICK_COLOR} ${p}px, ${$afb5e8cb2003dfda$var$TICK_COLOR} ${p + $afb5e8cb2003dfda$var$TICK_WIDTH}px, transparent ${p + $afb5e8cb2003dfda$var$TICK_WIDTH}px`).join(', ');\n        const ticksBackground = tickPositions?.length ? `linear-gradient(to right, ${tickPositionsInGradient}), ` : null;\n        const styles = [\n            `input[type=\"range\"]::-webkit-slider-runnable-track {\n        background: ${ticksBackground ? ticksBackground : ''}${this.#background ?? `linear-gradient(to right, var(--color-input) ${valueWidth}px, #ddd ${valueWidth}px)`};\n      }${this.#background ? '' : `\n       input[type=\"range\"]:hover::-webkit-slider-runnable-track {\n        background: ${ticksBackground ? ticksBackground : ''}linear-gradient(to right, var(--color-input-hover) ${valueWidth}px, #ddd ${valueWidth}px);\n      }\n        input[type=\"range\"]:active::-webkit-slider-runnable-track {\n        background: ${ticksBackground ? ticksBackground : ''}linear-gradient(to right, var(--color-input-active) ${valueWidth}px, #ddd ${valueWidth}px);\n      }`}`\n        ];\n        if (this.#thumbColor != null) styles.push(`input[type=\"range\"]::-webkit-slider-thumb { background: ${this.#thumbColor} !important}`);\n        this.#backgroundStyle.innerHTML = styles.join('\\n');\n    }\n}\ncustomElements.define('string-art-range-input', $afb5e8cb2003dfda$export$2e2bcd8739ae039);\n\n\nconst $da037f8140467741$var$elements = {\n    controls: document.querySelector('#controls'),\n    controlsPanel: document.querySelector('#controls_panel'),\n    sidebarForm: document.querySelector('#sidebar_form')\n};\nconst $da037f8140467741$var$EVENTS = new Set([\n    'input',\n    'change'\n]);\nconst $da037f8140467741$var$STATE_LOCAL_STORAGE_KEY = 'controls_state';\nconst $da037f8140467741$var$RANGE_SCROLL_LOCK_TIMEOUT = 120;\nlet $da037f8140467741$var$inputTimeout;\nclass $da037f8140467741$export$2e2bcd8739ae039 {\n    config;\n    controlsConfig;\n    state;\n    eventHandlers;\n    controlElements = {};\n    #postponeRangeInput = false;\n    #postponeRangeInputTimeout;\n    #wrappedOnInput;\n    #wrappedOnTouchStart;\n    #wrappedOnTouchEnd;\n    #wrappedOnRangeScroll;\n    #currentInputRange;\n    #currentInputRangeValue;\n    #rangeLockTimeout;\n    #lockRange = false;\n    #boundToggleFieldset;\n    constructor(controlsConfig, config){\n        this.config = config;\n        this.controlsConfig = controlsConfig;\n        this.state = this._getState() ?? {\n            groups: {}\n        };\n        this.eventHandlers = {\n            input: new Set(),\n            change: new Set()\n        };\n        this.#wrappedOnInput = this.#onInput.bind(this);\n        $da037f8140467741$var$elements.controls.addEventListener('input', this.#wrappedOnInput);\n        this.#wrappedOnTouchStart = this.#onTouchStart.bind(this);\n        $da037f8140467741$var$elements.controls.addEventListener('touchstart', this.#wrappedOnTouchStart);\n        $da037f8140467741$var$elements.controls.addEventListener('mousedown', this.#onMouseDown);\n        this.#boundToggleFieldset = this.#toggleFieldset.bind(this);\n        $da037f8140467741$var$elements.sidebarForm.addEventListener('click', this.#boundToggleFieldset);\n        $da037f8140467741$var$elements.sidebarForm.addEventListener('keydown', this.#toggleFieldSetOnEnter);\n        this.controlElements = {};\n        this.renderControls();\n    }\n    destroy() {\n        $da037f8140467741$var$elements.controls.removeEventListener('input', this.#wrappedOnInput);\n        $da037f8140467741$var$elements.sidebarForm.removeEventListener('click', this.#boundToggleFieldset);\n        $da037f8140467741$var$elements.sidebarForm.removeEventListener('keydown', this.#toggleFieldSetOnEnter);\n        $da037f8140467741$var$elements.controls.removeEventListener('touchstart', this.#wrappedOnTouchStart);\n        $da037f8140467741$var$elements.controls.removeEventListener('mousedown', this.#onMouseDown);\n        $da037f8140467741$var$elements.controls.innerHTML = '';\n    }\n    #toggleFieldset(e) {\n        if (e.target.nodeName === 'LEGEND') {\n            e.target.parentElement.classList.toggle('minimized');\n            const groupId = e.target.parentElement.dataset.group;\n            this.state = {\n                ...this.state,\n                groups: {\n                    ...this.state.groups,\n                    [groupId]: !e.target.parentElement.classList.contains('minimized')\n                }\n            };\n            this._updateState(this.state);\n        }\n    }\n    #toggleFieldSetOnEnter(e) {\n        if (e.target.nodeName === 'LEGEND' && e.key === 'Enter') this.#toggleFieldset(e);\n    }\n    addEventListener(event, eventHandler) {\n        if (!$da037f8140467741$var$EVENTS.has(event)) throw new Error(`Unsupported event for EditorControls, \"${event}\"!`);\n        if (!(eventHandler instanceof Function)) throw new Error('Invalid event handler.');\n        this.eventHandlers[event].add(eventHandler);\n    }\n    _triggerEvent(event, eventData) {\n        for (const eventHandler of this.eventHandlers[event])eventHandler(eventData);\n    }\n    #onMouseDown() {\n        // Clearing selection when starting to click in the controls, do avoid a buggy behavior,\n        // when if a control's display value was selected (can happen by mistake), the drag of range input doesn't work.\n        const selection = window.getSelection();\n        if (selection) selection.removeAllRanges();\n    }\n    /**\n   * Needed for range inputs, to avoid changing the value when the user drags to\n   * scroll and accidentally touches a range input when intending to scroll.\n   * @param {Event} e\n   */ #onTouchStart(e) {\n        if ($da037f8140467741$var$isRangeInput(e.target)) {\n            this.#postponeRangeInput = true;\n            this.#currentInputRange = e.target;\n            this.#currentInputRangeValue = e.target.value;\n            this.#rangeLockTimeout = window.setTimeout(()=>{\n                this.#postponeRangeInput = false;\n            }, $da037f8140467741$var$RANGE_SCROLL_LOCK_TIMEOUT);\n            this.#wrappedOnTouchEnd = this.#onTouchEnd.bind(this);\n            document.body.addEventListener('touchend', this.#wrappedOnTouchEnd);\n            this.#wrappedOnRangeScroll = this.#onRangeScroll.bind(this);\n            $da037f8140467741$var$elements.controlsPanel.addEventListener('scroll', this.#wrappedOnRangeScroll);\n        }\n    }\n    #onTouchEnd() {\n        document.body.removeEventListener('touchend', this.#wrappedOnTouchEnd);\n        $da037f8140467741$var$elements.controlsPanel.removeEventListener('scroll', this.#wrappedOnRangeScroll);\n        if (this.#lockRange) {\n            this.#lockRange = false;\n            if (this.#currentInputRange) this.#currentInputRange.value = this.#currentInputRangeValue;\n        }\n        this.#currentInputRange = this.#currentInputRangeValue = null;\n    }\n    #onRangeScroll() {\n        this.#lockRange = true;\n    }\n    #onInput(e) {\n        clearTimeout($da037f8140467741$var$inputTimeout);\n        clearTimeout(this.#postponeRangeInputTimeout);\n        if (this.#postponeRangeInput && $da037f8140467741$var$isRangeInput(e.target)) {\n            e.preventDefault();\n            this.#postponeRangeInputTimeout = window.setTimeout(()=>{\n                this.#onInput(e);\n            }, $da037f8140467741$var$RANGE_SCROLL_LOCK_TIMEOUT);\n            return false;\n        }\n        if (this.#lockRange) {\n            e.preventDefault();\n            return false;\n        }\n        if (e.target instanceof HTMLInputElement || $da037f8140467741$var$isRangeInput(e.target) || e.target instanceof HTMLSelectElement) this.updateInput({\n            inputElement: e.target,\n            originalEvent: e,\n            deferChange: true\n        });\n    }\n    updateControlDisplayValue(controlKey) {\n        const { config: config, displayValueElement: displayValueElement, input: input } = this.controlElements[controlKey];\n        if (displayValueElement) {\n            const formattedValue = config.displayValue ? config.displayValue(this.config) : input.value;\n            displayValueElement.innerText = String(formattedValue);\n        }\n    }\n    updateInput({ inputElement: inputElement, originalEvent: originalEvent, deferChange: deferChange = true }) {\n        const inputValue = $da037f8140467741$var$getInputValue(inputElement);\n        const controlKey = inputElement.id.replace(/^config_/, '');\n        if (this.config[controlKey] === inputValue) return;\n        const eventData = Object.freeze({\n            control: controlKey,\n            value: inputValue,\n            originalEvent: originalEvent\n        });\n        this._triggerEvent('input', eventData);\n        const triggerChange = ()=>{\n            this._triggerEvent('change', eventData);\n            this.updateControlsVisibility();\n        };\n        this.updateControlsAttributes();\n        this.updateControlDisplayValue(controlKey);\n        if (deferChange) $da037f8140467741$var$inputTimeout = window.setTimeout(triggerChange, 100);\n        else triggerChange();\n    }\n    _getState() {\n        const state = localStorage.getItem($da037f8140467741$var$STATE_LOCAL_STORAGE_KEY);\n        if (state) try {\n            return JSON.parse(state);\n        } catch (e) {\n            return null;\n        }\n        return null;\n    }\n    _updateState(newState) {\n        if (newState) localStorage.setItem($da037f8140467741$var$STATE_LOCAL_STORAGE_KEY, JSON.stringify(newState));\n        else localStorage.removeItem($da037f8140467741$var$STATE_LOCAL_STORAGE_KEY);\n    }\n    updateControlsAttributes(controlsConfig) {\n        if (!controlsConfig) controlsConfig = this.controlsConfig;\n        controlsConfig.forEach((control)=>{\n            if (control.type === 'group') this.updateControlsAttributes(control.children);\n            else if (control.attr) {\n                const functionAttrs = Object.entries(control.attr).filter(([_, value])=>value instanceof Function);\n                if (functionAttrs.length) {\n                    const inputEl = this.controlElements[control.key].input;\n                    if (inputEl) functionAttrs.forEach(([name, attributeValueFn])=>{\n                        const newAttrValue = this.getConfigValue(attributeValueFn, this.config);\n                        if (newAttrValue != inputEl.getAttribute(name)) {\n                            inputEl.setAttribute(name, String(newAttrValue));\n                            // If the min or max of the input changed and they're not within the new min/max, update the value of the input\n                            if (name === 'min' && inputEl.value < newAttrValue || name === 'max' && inputEl.value > newAttrValue) {\n                                inputEl.value = String(newAttrValue);\n                                clearTimeout(inputEl.updateTimeout);\n                                inputEl.updateTimeout = window.setTimeout(()=>{\n                                    this.updateInput({\n                                        inputElement: inputEl\n                                    });\n                                }, 100);\n                            } else this.updateControlDisplayValue(control.key);\n                        }\n                    });\n                }\n            }\n        });\n    }\n    updateControlsVisibility(controlsConfig) {\n        (controlsConfig ?? this.controlsConfig).forEach((control)=>{\n            if (control.show) {\n                const shouldShowControl = control.show(this.config);\n                const controlEl = this.controlElements[control.key].element;\n                if (controlEl) {\n                    if (shouldShowControl) controlEl.removeAttribute('hidden');\n                    else controlEl.setAttribute('hidden', 'hidden');\n                }\n            }\n            if (control.isDisabled) {\n                const shouldDisableControl = control.isDisabled(this.config);\n                const inputEl = this.controlElements[control.key].input;\n                if (inputEl) {\n                    if (shouldDisableControl) inputEl.setAttribute('disabled', 'disabled');\n                    else inputEl.removeAttribute('disabled');\n                }\n            }\n            if (control.children) this.updateControlsVisibility(control.children);\n        });\n    }\n    renderControls(containerEl = $da037f8140467741$var$elements.controls, _controlsConfig, indexStart) {\n        const controlsConfig = _controlsConfig ?? this.controlsConfig;\n        containerEl.innerHTML = '';\n        const controlsFragment = document.createDocumentFragment();\n        indexStart = indexStart ?? 1;\n        controlsConfig.forEach((controlConfig, controlIndex)=>{\n            const controlId = `config_${String(controlConfig.key)}`;\n            let controlEl;\n            let inputEl;\n            let displayValueElement;\n            if (controlConfig.type === 'group') {\n                controlEl = document.createElement('fieldset');\n                controlEl.setAttribute('data-group', String(controlConfig.key));\n                const groupTitleEl = document.createElement('legend');\n                groupTitleEl.setAttribute('tabindex', '0');\n                groupTitleEl.innerText = controlConfig.label;\n                controlEl.appendChild(groupTitleEl);\n                controlEl.className = 'control control_group';\n                if (controlConfig.defaultValue === 'minimized') {\n                    controlEl.classList.add('minimized');\n                    this.state.groups[String(controlConfig.key)] = false;\n                }\n                const childrenContainer = document.createElement('div');\n                controlEl.appendChild(childrenContainer);\n                this.renderControls(childrenContainer, controlConfig.children);\n            } else {\n                controlEl = document.createElement('div');\n                controlEl.className = 'control';\n                const label = document.createElement('label');\n                label.innerHTML = controlConfig.label;\n                label.setAttribute('for', controlId);\n                inputEl = document.createElement($da037f8140467741$var$getElementTagNameForControlType(controlConfig.type));\n                if ($da037f8140467741$var$isRangeInput(inputEl)) inputEl.classList.add('range-input');\n                inputEl.setAttribute('tabindex', String(controlIndex));\n                const inputValue = this.config[controlConfig.key] ?? this.getConfigValue(controlConfig.defaultValue, this.config);\n                if (controlConfig.type === 'select') {\n                    const selectOptions = document.createDocumentFragment();\n                    controlConfig.options.forEach((_option)=>{\n                        const { value: value, label: label } = typeof _option === 'string' ? {\n                            value: _option,\n                            label: _option\n                        } : _option;\n                        const optionEl = document.createElement('option');\n                        optionEl.setAttribute('value', value);\n                        optionEl.innerText = label;\n                        selectOptions.appendChild(optionEl);\n                    });\n                    inputEl.appendChild(selectOptions);\n                    inputEl.value = String(inputValue);\n                    controlEl.appendChild(label);\n                    controlEl.appendChild(inputEl);\n                } else {\n                    if (controlConfig.type !== 'range') inputEl.setAttribute('type', controlConfig.type);\n                    if (controlConfig.type === 'checkbox') {\n                        inputEl.checked = !!inputValue;\n                        controlEl.appendChild(inputEl);\n                        controlEl.appendChild(label);\n                    } else {\n                        controlEl.appendChild(label);\n                        controlEl.appendChild(inputEl);\n                        setTimeout(()=>{\n                            inputEl.value = String(inputValue);\n                        });\n                        displayValueElement = document.createElement('span');\n                        displayValueElement.id = `config_${String(controlConfig.key)}_value`;\n                        displayValueElement.innerText = String(controlConfig.displayValue ? controlConfig.displayValue(this.config) : inputValue);\n                        displayValueElement.className = 'control_input_value';\n                        controlEl.appendChild(displayValueElement);\n                    }\n                }\n                if (controlConfig.attr) Object.entries(controlConfig.attr).forEach(([attr, value])=>{\n                    const realValue = this.getConfigValue(value, this.config);\n                    inputEl.setAttribute(attr, String(realValue));\n                });\n                inputEl.id = controlId;\n            }\n            this.controlElements[controlConfig.key] = {\n                config: controlConfig,\n                displayValueElement: displayValueElement,\n                input: inputEl,\n                element: controlEl\n            };\n            controlEl.id = `control_${String(controlConfig.key)}`;\n            controlsFragment.appendChild(controlEl);\n        });\n        containerEl.appendChild(controlsFragment);\n        this.updateGroupsState();\n        requestAnimationFrame(()=>this.updateControlsVisibility());\n    }\n    updateGroupsState() {\n        const groups = $da037f8140467741$var$elements.sidebarForm.querySelectorAll('[data-group]');\n        groups.forEach((groupEl)=>{\n            if (groupEl instanceof HTMLFieldSetElement) {\n                const groupId = groupEl.dataset.group;\n                const groupState = this.state.groups[groupId];\n                if (typeof groupState === 'boolean') {\n                    if (groupState) groupEl.classList.remove('minimized');\n                    else groupEl.classList.add('minimized');\n                }\n            }\n        });\n    }\n    getConfigValue(valueOrFn, config) {\n        if (valueOrFn instanceof Function) return valueOrFn(config);\n        return valueOrFn;\n    }\n}\nfunction $da037f8140467741$var$getInputValue(inputElement) {\n    if ($da037f8140467741$var$isRangeInput(inputElement)) return Number(inputElement.value);\n    if (inputElement instanceof HTMLInputElement) {\n        const type = inputElement.type;\n        switch(type){\n            case 'range':\n                return parseFloat(inputElement.value);\n            case 'hue':\n                return inputElement.value;\n            case 'checkbox':\n                return inputElement.checked;\n            case 'number':\n                return parseFloat(inputElement.value);\n            default:\n                return inputElement.value;\n        }\n    } else if (inputElement instanceof HTMLSelectElement) return inputElement.value;\n}\nfunction $da037f8140467741$var$getElementTagNameForControlType(controlType) {\n    switch(controlType){\n        case 'select':\n            return 'select';\n        case 'range':\n            return 'string-art-range-input';\n        case 'hue':\n            return 'string-art-hue-input';\n        default:\n            return 'input';\n    }\n}\nfunction $da037f8140467741$var$isRangeInput(element) {\n    return element instanceof (0, $afb5e8cb2003dfda$export$2e2bcd8739ae039) || element instanceof (0, $644cb43818f0710b$export$2e2bcd8739ae039);\n}\n\n\nconst $fb81eeeade2a45e9$var$sizeControls = document.querySelector('#size_controls');\nconst $fb81eeeade2a45e9$var$elements = {\n    sizeSelect: $fb81eeeade2a45e9$var$sizeControls.querySelector('#size_select'),\n    sizeCustom: $fb81eeeade2a45e9$var$sizeControls.querySelector('#size_custom'),\n    width: $fb81eeeade2a45e9$var$sizeControls.querySelector('#size_custom_width'),\n    height: $fb81eeeade2a45e9$var$sizeControls.querySelector('#size_custom_height'),\n    orientationSelect: $fb81eeeade2a45e9$var$sizeControls.querySelector('#size_orientation_select')\n};\nfunction $fb81eeeade2a45e9$var$cmToPixels(cm, dpi = 300) {\n    return Math.floor(cm / 2.54 * dpi);\n}\nconst $fb81eeeade2a45e9$var$SCREEN_SIZE = [\n    Math.floor(window.screen.width),\n    Math.floor(window.screen.height)\n];\nconst $fb81eeeade2a45e9$var$SIZES = [\n    {\n        id: 'fit',\n        name: 'Fit to screen'\n    },\n    {\n        id: 'A4',\n        value: [\n            20,\n            28\n        ].map((v)=>$fb81eeeade2a45e9$var$cmToPixels(v)),\n        orientationSelect: true\n    },\n    {\n        id: 'A3',\n        value: [\n            28,\n            40\n        ].map((v)=>$fb81eeeade2a45e9$var$cmToPixels(v)),\n        orientationSelect: true\n    },\n    {\n        id: 'screen',\n        name: `Screen size (${$fb81eeeade2a45e9$var$SCREEN_SIZE.join('x')})`,\n        value: $fb81eeeade2a45e9$var$SCREEN_SIZE\n    },\n    {\n        id: 'custom',\n        name: 'Custom...'\n    }\n];\nclass $fb81eeeade2a45e9$export$2e2bcd8739ae039 {\n    element = document.querySelector('#size_controls');\n    constructor({ getCurrentSize: getCurrentSize }){\n        const sizeOptionsFragment = document.createDocumentFragment();\n        $fb81eeeade2a45e9$var$SIZES.forEach((size)=>{\n            const sizeListItem = document.createElement('option');\n            sizeListItem.setAttribute('value', size.id);\n            sizeListItem.innerText = size.name ?? size.id;\n            sizeOptionsFragment.appendChild(sizeListItem);\n        });\n        $fb81eeeade2a45e9$var$elements.sizeSelect.appendChild(sizeOptionsFragment);\n        this.selectedSize = $fb81eeeade2a45e9$var$SIZES[0];\n        $fb81eeeade2a45e9$var$elements.sizeSelect.addEventListener('change', (e)=>{\n            const selectedSizeId = e.target.value;\n            const size = $fb81eeeade2a45e9$var$SIZES.find(({ id: id })=>id === selectedSizeId);\n            this.selectedSize = size;\n            if (size.id === 'custom') {\n                $fb81eeeade2a45e9$var$elements.sizeCustom.removeAttribute('hidden');\n                const [width, height] = getCurrentSize();\n                $fb81eeeade2a45e9$var$elements.width.value = width;\n                $fb81eeeade2a45e9$var$elements.height.value = height;\n            } else {\n                $fb81eeeade2a45e9$var$elements.sizeCustom.setAttribute('hidden', 'hidden');\n                this._notifyOnChange(this.getValue());\n            }\n            if (size.orientationSelect) $fb81eeeade2a45e9$var$elements.orientationSelect.removeAttribute('hidden');\n            else $fb81eeeade2a45e9$var$elements.orientationSelect.setAttribute('hidden', 'hidden');\n        });\n        $fb81eeeade2a45e9$var$elements.orientationSelect.addEventListener('change', (e)=>{\n            this._notifyOnChange(this.getValue());\n        });\n        $fb81eeeade2a45e9$var$elements.sizeCustom.addEventListener('focusin', (e)=>{\n            e.target.select();\n        });\n        $fb81eeeade2a45e9$var$elements.sizeCustom.addEventListener('input', ()=>{\n            this._notifyOnChange([\n                $fb81eeeade2a45e9$var$elements.width.value ? parseInt($fb81eeeade2a45e9$var$elements.width.value) : null,\n                $fb81eeeade2a45e9$var$elements.height.value ? parseInt($fb81eeeade2a45e9$var$elements.height.value) : null\n            ]);\n        });\n    }\n    _notifyOnChange([width, height] = []) {\n        this.element.dispatchEvent(new CustomEvent('sizechange', {\n            detail: width && height ? [\n                width,\n                height\n            ] : null\n        }));\n    }\n    getValue() {\n        if (this.selectedSize.id === 'custom') return [\n            parseInt($fb81eeeade2a45e9$var$elements.width.value, 10),\n            parseInt($fb81eeeade2a45e9$var$elements.height.value, 10)\n        ];\n        else {\n            let value = this.selectedSize.value;\n            if (this.selectedSize.orientationSelect && $fb81eeeade2a45e9$var$elements.orientationSelect.value === 'horizontal') value = Array.from(value).reverse();\n            return value;\n        }\n    }\n}\n\n\n\nclass $9936be7d63e3034a$export$2e2bcd8739ae039 {\n    parentElement;\n    color;\n    size;\n    constructor(parentElement){\n        this.parentElement = parentElement;\n    }\n    destroy() {\n        this.element.remove();\n    }\n    get element() {\n        throw new Error('element getter not implemented!');\n    }\n    setColor(color) {\n        this.color = color;\n    }\n    setBackground(color) {}\n    getSize() {\n        const { width: width, height: height } = this.parentElement.getBoundingClientRect();\n        return [\n            width,\n            height\n        ];\n    }\n    setSize(size) {\n        this.element.removeAttribute('width');\n        this.element.removeAttribute('height');\n        if (this.element instanceof HTMLElement) {\n            if (size) {\n                this.element.style.width = `${size[0]}px`;\n                this.element.style.height = `${size[1]}px`;\n            } else this.element.removeAttribute('style');\n        }\n    }\n}\n\n\n\nclass $d45f09bc4feaf860$export$2e2bcd8739ae039 extends (0, $9936be7d63e3034a$export$2e2bcd8739ae039) {\n    canvas;\n    ctx;\n    pixelRatio;\n    constructor(parentElement){\n        super(parentElement);\n        this.canvas = document.createElement('canvas');\n        this.ctx = this.canvas.getContext('2d');\n        const dpr = window.devicePixelRatio || 1;\n        this.pixelRatio = dpr;\n        this.ctx.globalCompositeOperation = 'source-over';\n        parentElement.appendChild(this.canvas);\n    }\n    get element() {\n        return this.canvas;\n    }\n    /**\n   * Clears the canvas and resets the width and height\n   */ reset() {\n        this.ctx.clearRect(0, 0, ...this.getSize());\n        this.canvas.removeAttribute('width');\n        this.canvas.removeAttribute('height');\n        const [width, height] = this.getSize();\n        this.canvas.setAttribute('width', String(width));\n        this.canvas.setAttribute('height', String(height));\n    }\n    setColor(color) {\n        this.ctx.strokeStyle = color;\n    }\n    setLineWidth(width) {\n        this.ctx.lineWidth = width;\n    }\n    setBackground(color) {\n        this.ctx.globalCompositeOperation = 'destination-over';\n        this.ctx.fillStyle = color;\n        this.ctx.fillRect(0, 0, ...this.getSize());\n        this.ctx.globalCompositeOperation = 'source-over';\n    }\n    getSize() {\n        return [\n            this.canvas.clientWidth * this.pixelRatio,\n            this.canvas.clientHeight * this.pixelRatio\n        ];\n    }\n    renderLines(startPosition, ...positions) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(...startPosition);\n        for (const position of positions)this.ctx.lineTo(...position);\n        this.ctx.stroke();\n    }\n    renderNails(nails, { color: color, fontSize: fontSize, radius: radius, renderNumbers: renderNumbers, margin: margin = 0 }) {\n        const centerX = this.canvas.width / 2;\n        this.ctx.globalCompositeOperation = 'source-over';\n        this.ctx.beginPath();\n        this.ctx.fillStyle = color;\n        this.ctx.textBaseline = 'middle';\n        this.ctx.font = `${fontSize}px sans-serif`;\n        const nailNumberOffset = radius + margin;\n        nails.forEach(({ point: [x, y], number: number })=>{\n            this.ctx.moveTo(x + radius, y);\n            this.ctx.arc(x, y, radius, 0, (0, $e2b746416d2bf62b$export$f4644083ce95e7e3));\n            if (renderNumbers && number != null) {\n                const isRightAlign = x < centerX;\n                const numberPosition = [\n                    isRightAlign ? x - nailNumberOffset : x + nailNumberOffset,\n                    y\n                ];\n                this.ctx.textAlign = isRightAlign ? 'right' : 'left';\n                this.ctx.fillText(String(number), ...numberPosition);\n            }\n        });\n        this.ctx.fill();\n    }\n    clear() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n    toDataURL() {\n        return this.canvas.toDataURL();\n    }\n}\n\n\nclass $00df09d341073864$export$2e2bcd8739ae039 {\n    #eventHandlers = {};\n    addEventListener(event, handler) {\n        const handlers = this.#eventHandlers[event] ??= [];\n        if (!handlers.includes(handler)) handlers.push(handler);\n    }\n    removeEventListener(event, handler) {\n        const handlers = this.#eventHandlers[event];\n        if (!handlers) return;\n        const index = handlers.indexOf(handler);\n        if (index !== -1) handlers.splice(index, 1);\n    }\n    emit(event, payload) {\n        this.#eventHandlers[event]?.forEach((handler)=>handler(payload));\n    }\n}\n\n\n\nconst $174f2c93f6348ee5$var$promptDialogId = 'prompt_dialog';\nfunction $174f2c93f6348ee5$export$195ba6d62321b933({ value: value, ...options }) {\n    let dialog = document.querySelector(`#${$174f2c93f6348ee5$var$promptDialogId}`);\n    if (!dialog) {\n        dialog = document.createElement('input-dialog');\n        dialog.id = $174f2c93f6348ee5$var$promptDialogId;\n        document.body.appendChild(dialog);\n    }\n    [\n        'title',\n        'description',\n        'submit',\n        'cancel',\n        'type'\n    ].forEach((attr)=>{\n        if (options[attr] != null && options[attr] !== '') dialog.setAttribute(attr, options[attr]);\n        else dialog.removeAttribute(attr);\n    });\n    return dialog.show(value);\n}\nconst $174f2c93f6348ee5$var$CONFIRM_DIALOG_ID = 'confirm_dialog';\nfunction $174f2c93f6348ee5$export$715f9d76bb8c1fea(options) {\n    let dialog = document.querySelector(`#${$174f2c93f6348ee5$var$CONFIRM_DIALOG_ID}`);\n    if (!dialog) {\n        dialog = document.createElement('confirm-dialog');\n        dialog.id = $174f2c93f6348ee5$var$CONFIRM_DIALOG_ID;\n        document.body.appendChild(dialog);\n    }\n    [\n        'title',\n        'description',\n        'submit',\n        'cancel',\n        'type'\n    ].forEach((attr)=>{\n        if (options[attr] != null && options[attr] !== '') dialog.setAttribute(attr, options[attr]);\n        else dialog.removeAttribute(attr);\n    });\n    return dialog.show();\n}\n\n\nconst $00643d12b3a54506$var$APP_DATA_STORAGE_KEY = 'string_art_app_data';\nclass $00643d12b3a54506$export$2e2bcd8739ae039 extends (0, $00df09d341073864$export$2e2bcd8739ae039) {\n    elements;\n    currentPattern;\n    constructor(){\n        super();\n        this.elements = {\n            saveDialog: document.querySelector('#save_dialog')\n        };\n        document.querySelector('#pattern_menu').addEventListener('select', (e)=>{\n            // @ts-ignore\n            switch(e.detail.value){\n                case 'save_as':\n                    this.#showSaveAsDialog();\n                    break;\n                case 'delete':\n                    this.deletePattern();\n                    break;\n                case 'save':\n                    this.saveCurrentPattern();\n                    break;\n                case 'rename':\n                    this.renameCurrentPattern();\n                    break;\n            }\n        });\n        document.querySelector('#save_btn').addEventListener('click', ()=>{\n            if (this.currentPattern.isTemplate) this.#showSaveAsDialog();\n            else this.saveCurrentPattern();\n        });\n    }\n    #showSaveAsDialog() {\n        const nextId = this.#getNextAvailableId();\n        const defaultName = `Pattern #${nextId}`;\n        (0, $174f2c93f6348ee5$export$195ba6d62321b933)({\n            title: 'Save pattern',\n            description: 'Name this pattern:',\n            submit: 'Save',\n            value: defaultName\n        }).then((patternName)=>{\n            this.saveNewPattern({\n                type: this.currentPattern.type,\n                config: this.currentPattern.config,\n                name: patternName == null || patternName === '' ? defaultName : patternName\n            });\n        }, ()=>{});\n    }\n    setPattern(pattern) {\n        this.currentPattern = pattern;\n    }\n    static patternDataToStringArt({ type: patternType, ...patternData }) {\n        const Pattern = (0, $3eff4f8917d513a6$export$2e2bcd8739ae039).find(({ type: type })=>type === patternType);\n        if (Pattern == null) throw new Error(`No pattern of type \"${patternType}\" found!`);\n        const pattern = new Pattern();\n        Object.assign(pattern, patternData);\n        return pattern;\n    }\n    static getSavedPatterns() {\n        const { patterns: patterns } = this.loadAppData();\n        return patterns.map(this.patternDataToStringArt);\n    }\n    static getPatternByID(patternId) {\n        const patternData = this.loadPatternDataById(patternId);\n        return patternData ? this.patternDataToStringArt(patternData) : null;\n    }\n    static loadPatternDataById(patternId) {\n        const { patterns: patterns } = this.loadAppData();\n        return patterns.find(({ id: id })=>id === patternId);\n    }\n    #getNextAvailableId() {\n        const appData = $00643d12b3a54506$export$2e2bcd8739ae039.loadAppData();\n        const lastId = appData?.patterns?.length ? Number(appData.patterns[appData.patterns.length - 1].id) : 0;\n        const nextId = isNaN(lastId) ? 1 : lastId + 1;\n        return String(nextId);\n    }\n    saveNewPattern(patternData) {\n        const appData = $00643d12b3a54506$export$2e2bcd8739ae039.loadAppData();\n        const nextId = this.#getNextAvailableId();\n        const newPatternData = {\n            ...patternData,\n            id: nextId\n        };\n        appData.patterns.push(newPatternData);\n        this.saveAppData(appData);\n        this.emit('newPattern', {\n            pattern: $00643d12b3a54506$export$2e2bcd8739ae039.patternDataToStringArt(newPatternData)\n        });\n        return newPatternData;\n    }\n    savePattern(patternData) {\n        const appData = $00643d12b3a54506$export$2e2bcd8739ae039.loadAppData();\n        const patternIndex = appData.patterns.findIndex(({ id: id })=>id === this.currentPattern.id);\n        if (patternIndex !== -1) {\n            appData.patterns[patternIndex] = patternData;\n            this.saveAppData(appData);\n            this.emit('save', {\n                pattern: $00643d12b3a54506$export$2e2bcd8739ae039.patternDataToStringArt(patternData)\n            });\n        }\n    }\n    saveCurrentPattern() {\n        const newPatternData = {\n            id: this.currentPattern.id,\n            name: this.currentPattern.name,\n            type: this.currentPattern.type,\n            config: this.currentPattern.config\n        };\n        this.savePattern(newPatternData);\n        return newPatternData;\n    }\n    renameCurrentPattern() {\n        (0, $174f2c93f6348ee5$export$195ba6d62321b933)({\n            title: 'Rename',\n            description: 'Name this pattern:',\n            submit: 'Save',\n            value: this.currentPattern.name\n        }).then((newPatternName)=>{\n            if (newPatternName !== this.currentPattern.name) {\n                const patternData = $00643d12b3a54506$export$2e2bcd8739ae039.loadPatternDataById(this.currentPattern.id);\n                patternData.name = newPatternName;\n                this.savePattern(patternData);\n            }\n            this.currentPattern.name = newPatternName;\n        });\n    }\n    deletePattern() {\n        (0, $174f2c93f6348ee5$export$715f9d76bb8c1fea)({\n            title: 'Delete pattern',\n            description: 'Are you sure you wish to delete this pattern?',\n            submit: 'Delete',\n            type: 'error'\n        }).then(()=>{\n            const appData = $00643d12b3a54506$export$2e2bcd8739ae039.loadAppData();\n            const patternIndex = appData.patterns.findIndex(({ id: id })=>id === this.currentPattern.id);\n            if (patternIndex === -1) throw new Error(`Can't delete pattern with ID \"${this.currentPattern.id}\", it's not found!`);\n            const pattern = appData.patterns.splice(patternIndex, 1)[0];\n            this.saveAppData(appData);\n            this.emit('deletePattern', {\n                pattern: $00643d12b3a54506$export$2e2bcd8739ae039.patternDataToStringArt(pattern)\n            });\n        }, ()=>{});\n    }\n    static loadAppData() {\n        const rawData = localStorage.getItem($00643d12b3a54506$var$APP_DATA_STORAGE_KEY);\n        try {\n            return rawData ? JSON.parse(rawData) : {\n                patterns: []\n            };\n        } catch (error) {\n            throw new Error('App data is corrupted, failed to load it. ' + error.message);\n        }\n    }\n    saveAppData(appData) {\n        localStorage.setItem($00643d12b3a54506$var$APP_DATA_STORAGE_KEY, JSON.stringify(appData));\n    }\n}\n\n\n\nconst $8a4d6517fbd25a59$var$THUMBNAIL_WIDTH_PX = '100px';\nconst $8a4d6517fbd25a59$var$MINIMIZED_CLASS = 'minimized';\nclass $8a4d6517fbd25a59$export$45b50bca1da1e9b3 extends (0, $00df09d341073864$export$2e2bcd8739ae039) {\n    elements = {\n        root: document.querySelector('#pattern_select_panel'),\n        thumbnails: document.querySelector('#thumbnails'),\n        toggleBtn: document.querySelector('#pattern_select_btn'),\n        dropdown: document.querySelector('#pattern_select_dropdown'),\n        patternName: document.querySelector('#pattern_name')\n    };\n    pattern;\n    thumbnailsRendered = false;\n    _onClickOutside;\n    constructor(persistance){\n        super();\n        this.elements.toggleBtn.addEventListener('click', ()=>this.toggle());\n        persistance.addEventListener('newPattern', ({ pattern: pattern })=>{\n            if (this.isOpen) this.createThumbnails();\n            else this.thumbnailsRendered = false;\n            this.setCurrentPattern(pattern);\n            this.emit('select', {\n                patternId: pattern.id\n            });\n        });\n        persistance.addEventListener('save', ({ pattern: pattern })=>{\n            if (this.isOpen) this.createThumbnails();\n            else this.thumbnailsRendered = false;\n            this.setCurrentPattern(pattern);\n        });\n        persistance.addEventListener('deletePattern', ({ pattern: pattern })=>{\n            if (this.isOpen) {\n                const thumbnail = this.elements.thumbnails.querySelector(`[data-pattern=\"${pattern.id}\"]`);\n                thumbnail.remove();\n            } else this.thumbnailsRendered = false;\n        });\n        this.elements.thumbnails.addEventListener('click', (e)=>{\n            e.preventDefault();\n            e.stopPropagation();\n            const link = e.target instanceof HTMLElement && e.target.closest('[data-pattern]');\n            if (!link) return false;\n            this.emit('select', {\n                patternId: link.dataset.pattern\n            });\n            this.toggle();\n        });\n    }\n    get isOpen() {\n        return !this.elements.root.classList.contains($8a4d6517fbd25a59$var$MINIMIZED_CLASS);\n    }\n    toggle() {\n        if (!this.isOpen) this.open();\n        else if (this.pattern) this.close();\n    }\n    open() {\n        if (!this.isOpen) {\n            this.elements.root.classList.remove($8a4d6517fbd25a59$var$MINIMIZED_CLASS);\n            if (!this.thumbnailsRendered) {\n                this.createThumbnails();\n                this.thumbnailsRendered = true;\n            }\n            this._onClickOutside = (e)=>{\n                if (e.target instanceof HTMLElement && !e.target.closest('#pattern_select_panel')) this.toggle();\n            };\n            document.body.addEventListener('mousedown', this._onClickOutside);\n        }\n    }\n    close() {\n        if (this.isOpen) {\n            this.elements.root.classList.add($8a4d6517fbd25a59$var$MINIMIZED_CLASS);\n            document.body.removeEventListener('mousedown', this._onClickOutside);\n            this._onClickOutside = null;\n        }\n    }\n    setCurrentPattern(pattern) {\n        this.pattern = pattern;\n        this.elements.patternName.innerText = pattern?.name ?? 'Choose a pattern';\n    }\n    #createThumbnailsSection(title, patterns) {\n        const section = document.createElement(\"section\");\n        const sectionTitle = document.createElement('h3');\n        sectionTitle.className = 'pattern_select_thumbnails_title';\n        sectionTitle.innerText = title;\n        section.appendChild(sectionTitle);\n        const thumbnailsList = document.createElement(\"ul\");\n        thumbnailsList.className = \"pattern_select_thumbnails\";\n        section.appendChild(thumbnailsList);\n        const thumbnailsFragment = document.createDocumentFragment();\n        patterns.forEach((pattern)=>{\n            const patternLink = document.createElement('a');\n            patternLink.style.width = patternLink.style.height = $8a4d6517fbd25a59$var$THUMBNAIL_WIDTH_PX;\n            pattern.renderer = new (0, $d45f09bc4feaf860$export$2e2bcd8739ae039)(patternLink);\n            pattern.assignConfig({\n                margin: 1,\n                enableBackground: false,\n                nailRadius: 0.5,\n                ...pattern.constructor.thumbnailConfig\n            });\n            const li = document.createElement('li');\n            thumbnailsFragment.appendChild(li);\n            patternLink.href = `?pattern=${pattern.id}`;\n            patternLink.setAttribute('data-pattern', pattern.id);\n            patternLink.title = pattern.name;\n            li.appendChild(patternLink);\n        });\n        thumbnailsList.appendChild(thumbnailsFragment);\n        this.elements.thumbnails.appendChild(section);\n        patterns.forEach((pattern)=>pattern.draw());\n    }\n    createThumbnails() {\n        this.elements.thumbnails.innerHTML = \"\";\n        const savedPatterns = (0, $00643d12b3a54506$export$2e2bcd8739ae039).getSavedPatterns();\n        if (savedPatterns.length) this.#createThumbnailsSection('My Patterns', (0, $00643d12b3a54506$export$2e2bcd8739ae039).getSavedPatterns());\n        const patterns = (0, $3eff4f8917d513a6$export$2e2bcd8739ae039).map((PatternType)=>new PatternType);\n        this.#createThumbnailsSection('Built-in patterns', patterns);\n    }\n}\n\n\nconst $d8f8628a77747326$var$MAX_FLOAT_DECIMALS = 6;\nfunction $d8f8628a77747326$export$fa8157df3262779b(pattern) {\n    const { defaultConfig: defaultConfig, config: config } = pattern;\n    const nonDefaultConfigValues = Object.entries(config).map(([key, value])=>{\n        if (value === defaultConfig[key]) return null;\n        if (typeof value === 'boolean') return `!${value ? 1 : 0}`;\n        if (typeof value === 'number') return parseFloat(value.toFixed($d8f8628a77747326$var$MAX_FLOAT_DECIMALS));\n        return value;\n    });\n    while(nonDefaultConfigValues[nonDefaultConfigValues.length - 1] === null)nonDefaultConfigValues.pop();\n    if (!nonDefaultConfigValues.length) return '';\n    const serializedConfigValues = nonDefaultConfigValues.join('_').replace(/\\_{2,}/g, (match)=>'~' + match.length + '_');\n    return serializedConfigValues;\n}\nconst $d8f8628a77747326$var$numberRegExp = /^\\-?\\d+(\\.\\d+)?$/;\nconst $d8f8628a77747326$var$booleanRegExp = /^(?:!)([01])$/;\nfunction $d8f8628a77747326$export$39ef19ebad6081a3(pattern, serializedCofig) {\n    const serializedConfigValues = serializedCofig.replace(/(?:~)(\\d+)(?:_)/g, (_, commaCount)=>new Array(+commaCount).fill('_').join('')).split('_').map((v)=>{\n        if (v === '') return null;\n        if ($d8f8628a77747326$var$numberRegExp.test(v)) return parseFloat(v);\n        const booleanMatch = v.match($d8f8628a77747326$var$booleanRegExp);\n        if (booleanMatch) return booleanMatch[1] === '1';\n        return v;\n    });\n    const configKeys = Object.keys(pattern.defaultConfig);\n    return serializedConfigValues.reduce((config, serializedValue, i)=>{\n        if (serializedValue !== null) {\n            const key = configKeys[i];\n            return {\n                ...config,\n                [key]: serializedValue\n            };\n        }\n        return config;\n    }, {});\n}\n\n\nasync function $38bb4a85553a6bfc$export$ed80d9de1d9df928(input) {\n    try {\n        navigator.share(await $38bb4a85553a6bfc$var$getShareData(input));\n    } catch (error) {\n        alert('Error: ' + error.message);\n    }\n}\nasync function $38bb4a85553a6bfc$export$4fa6f570da04f7cc(input) {\n    if (!navigator.share) return false;\n    const shareData = await $38bb4a85553a6bfc$var$getShareData(input);\n    return navigator.canShare(shareData);\n}\nasync function $38bb4a85553a6bfc$var$getShareData({ renderer: renderer, pattern: pattern }) {\n    const dataUrl = renderer.toDataURL();\n    const blob = await (await fetch(dataUrl)).blob();\n    const files = [\n        new File([\n            blob\n        ], pattern.name + '.jpg', {\n            type: blob.type,\n            lastModified: new Date().getTime()\n        })\n    ];\n    return {\n        url: window.location.href,\n        files: files,\n        title: document.title,\n        text: 'String Art Studio - ' + pattern.name\n    };\n}\n\n\nconst $718de5d870731526$var$swFilename = 'service-worker.js';\nasync function $718de5d870731526$export$d594efb518b3cec4() {\n    if (!navigator.serviceWorker || document.location.hostname === '127.0.0.1') return;\n    try {\n        const registration = await navigator.serviceWorker.register($718de5d870731526$var$swFilename);\n        registration.onupdatefound = ()=>{\n            const installingWorker = registration.installing;\n            if (installingWorker == null) return;\n            installingWorker.onstatechange = ()=>{\n                if (installingWorker.state === 'installed') {\n                    if (navigator.serviceWorker.controller) console.log(\"New content is available and will be used when all tabs for this page are closed. See https://bit.ly/CRA-PWA.\");\n                    else console.log('Content is cached for offline use.');\n                }\n            };\n        };\n    } catch (error) {\n        console.error('Error during service worker registration:', error);\n    }\n}\n\n\n\n\nconst $3ff5c6d6cb93edd9$var$SVG_NS = 'http://www.w3.org/2000/svg';\nclass $3ff5c6d6cb93edd9$export$2e2bcd8739ae039 extends (0, $9936be7d63e3034a$export$2e2bcd8739ae039) {\n    svg;\n    backgroundGroup;\n    background = null;\n    linesGroup;\n    nailsGroup;\n    nailsCirclesGroup;\n    nailsTextGroup;\n    currentColor = null;\n    lineWidth = 1;\n    currentLineGroup = null;\n    constructor(parentElement){\n        super(parentElement);\n        this.svg = document.createElementNS($3ff5c6d6cb93edd9$var$SVG_NS, 'svg');\n        this.svg.style.setProperty('display', 'block');\n        this.backgroundGroup = document.createElementNS($3ff5c6d6cb93edd9$var$SVG_NS, 'g');\n        this.backgroundGroup.setAttribute('data-id', 'background');\n        this.linesGroup = document.createElementNS($3ff5c6d6cb93edd9$var$SVG_NS, 'g');\n        this.linesGroup.setAttribute('data-id', 'lines');\n        this.nailsGroup = document.createElementNS($3ff5c6d6cb93edd9$var$SVG_NS, 'g');\n        this.nailsGroup.setAttribute('data-id', 'nails');\n        this.nailsCirclesGroup = document.createElementNS($3ff5c6d6cb93edd9$var$SVG_NS, 'g');\n        this.nailsCirclesGroup.setAttribute('data-id', 'nailsCircles');\n        this.nailsTextGroup = document.createElementNS($3ff5c6d6cb93edd9$var$SVG_NS, 'g');\n        this.nailsTextGroup.setAttribute('data-id', 'nailsText');\n        this.nailsGroup.appendChild(this.nailsCirclesGroup);\n        this.nailsGroup.appendChild(this.nailsTextGroup);\n        this.svg.appendChild(this.backgroundGroup);\n        this.svg.appendChild(this.linesGroup);\n        this.svg.appendChild(this.nailsGroup);\n        this.svg.setAttribute('xmlns', $3ff5c6d6cb93edd9$var$SVG_NS);\n        parentElement.appendChild(this.svg);\n    }\n    get element() {\n        return this.svg;\n    }\n    reset() {\n        this.linesGroup.innerHTML = '';\n        this.nailsCirclesGroup.innerHTML = '';\n        this.nailsTextGroup.innerHTML = '';\n        const [width, height] = this.getSize().map(Math.trunc);\n        this.svg.setAttributeNS($3ff5c6d6cb93edd9$var$SVG_NS, 'viewBox', `0 0 ${width} ${height}`);\n        this.svg.setAttributeNS($3ff5c6d6cb93edd9$var$SVG_NS, 'width', String(width));\n        this.svg.setAttributeNS($3ff5c6d6cb93edd9$var$SVG_NS, 'height', String(height));\n        this.svg.style.width = width + 'px';\n        this.svg.style.height = height + 'px';\n        this.currentColor = null;\n        this.lineWidth = null;\n    }\n    setColor(color) {\n        if (color !== this.currentColor) {\n            this.currentLineGroup = document.createElementNS($3ff5c6d6cb93edd9$var$SVG_NS, 'g');\n            this.currentLineGroup.setAttribute('stroke', color);\n            this.currentLineGroup.setAttribute('stroke-width', String(this.lineWidth));\n            this.linesGroup.appendChild(this.currentLineGroup);\n            this.currentColor = color;\n        }\n    }\n    setLineWidth(width) {\n        this.lineWidth = width ?? '1';\n        this.linesGroup.setAttributeNS($3ff5c6d6cb93edd9$var$SVG_NS, 'stroke-width', width ?? '1');\n        this.linesGroup.childNodes.forEach((group)=>{\n            if (group instanceof SVGGElement) group.setAttributeNS($3ff5c6d6cb93edd9$var$SVG_NS, 'stroke-width', width ?? '1');\n        });\n    }\n    setBackground(color) {\n        if (color) {\n            if (!this.background) {\n                this.background = document.createElementNS($3ff5c6d6cb93edd9$var$SVG_NS, 'rect');\n                this.background.setAttribute('width', '100%');\n                this.background.setAttribute('height', '100%');\n                this.backgroundGroup.appendChild(this.background);\n            }\n            this.background.setAttribute('fill', color);\n        } else {\n            this.background = null;\n            this.backgroundGroup.innerHTML = '';\n        }\n    }\n    getSize() {\n        return [\n            this.svg.clientWidth,\n            this.svg.clientHeight\n        ];\n    }\n    setSize(size) {\n        super.setSize(size);\n        if (size) {\n            const [width, height] = size.map(Math.trunc);\n            this.svg.setAttributeNS($3ff5c6d6cb93edd9$var$SVG_NS, 'viewBox', `0 0 ${width} ${height}`);\n            this.svg.setAttributeNS($3ff5c6d6cb93edd9$var$SVG_NS, 'width', String(width));\n            this.svg.setAttributeNS($3ff5c6d6cb93edd9$var$SVG_NS, 'height', String(height));\n        }\n    }\n    renderLines(startPosition, ...positions) {\n        let previousPoint = startPosition;\n        const fragment = document.createDocumentFragment();\n        for (const position of positions){\n            const line = document.createElementNS($3ff5c6d6cb93edd9$var$SVG_NS, 'line');\n            line.setAttribute('x1', String(Math.trunc(previousPoint[0])));\n            line.setAttribute('y1', String(Math.trunc(previousPoint[1])));\n            line.setAttribute('x2', String(Math.trunc(position[0])));\n            line.setAttribute('y2', String(Math.trunc(position[1])));\n            previousPoint = position;\n            fragment.appendChild(line);\n        }\n        this.currentLineGroup.appendChild(fragment);\n    }\n    renderNails(nails, { color: color, fontSize: fontSize, radius: radius, renderNumbers: renderNumbers, margin: margin = 0 }) {\n        const centerX = this.getSize()[0] / 2;\n        this.nailsCirclesGroup.innerHTML = this.nailsTextGroup.innerHTML = '';\n        const circlesFragment = document.createDocumentFragment();\n        const textFragment = document.createDocumentFragment();\n        this.nailsGroup.setAttribute('fill', color);\n        const nailNumberOffset = radius + margin;\n        this.nailsTextGroup.style.fontSize = fontSize;\n        nails.forEach(({ point: [x, y], number: number })=>{\n            const circle = document.createElementNS($3ff5c6d6cb93edd9$var$SVG_NS, 'circle');\n            circle.setAttribute('cx', x);\n            circle.setAttribute('cy', y);\n            circle.setAttribute('r', radius);\n            circlesFragment.appendChild(circle);\n            if (renderNumbers && number != null) {\n                const isRightAlign = x < centerX;\n                const numberPosition = [\n                    isRightAlign ? x - nailNumberOffset : x + nailNumberOffset,\n                    y\n                ];\n                const textEl = document.createElementNS($3ff5c6d6cb93edd9$var$SVG_NS, 'text');\n                textEl.innerHTML = String(number);\n                textEl.setAttribute('x', numberPosition[0]);\n                textEl.setAttribute('y', numberPosition[1]);\n                if (isRightAlign) textEl.setAttribute('text-anchor', 'end');\n                textFragment.appendChild(textEl);\n            }\n        });\n        this.nailsCirclesGroup.appendChild(circlesFragment);\n        this.nailsTextGroup.appendChild(textFragment);\n    }\n    clear() {\n        this.linesGroup.innerHTML = '';\n        this.nailsGroup.innerHTML = '';\n    }\n    toDataURL() {\n        return '';\n    }\n}\n\n\n\nfunction $b7266296a7c0118e$export$bb3b75778e3e272(dataUrl, fileName) {\n    const downloadLink = document.createElement('a');\n    downloadLink.href = dataUrl;\n    downloadLink.download = fileName;\n    document.body.appendChild(downloadLink);\n    downloadLink.click();\n    document.body.removeChild(downloadLink);\n}\n\n\nfunction $21c7ecb944647062$export$a0b41a3b036d92d2(pattern, size) {\n    const parentEl = document.createElement('article');\n    parentEl.style.width = size[0] + 'px';\n    parentEl.style.height = size[1] + 'px';\n    document.body.appendChild(parentEl);\n    const svgRenderer = new (0, $3ff5c6d6cb93edd9$export$2e2bcd8739ae039)(parentEl);\n    const PatternConstructor = pattern.constructor;\n    const svgPattern = new PatternConstructor(svgRenderer);\n    svgPattern.setConfig(pattern.config);\n    svgPattern.draw();\n    var svgData = svgPattern.renderer.svg.outerHTML;\n    var svgBlob = new Blob([\n        svgData\n    ], {\n        type: 'image/svg+xml;charset=utf-8'\n    });\n    var svgUrl = URL.createObjectURL(svgBlob);\n    (0, $b7266296a7c0118e$export$bb3b75778e3e272)(svgUrl, pattern.name + '.svg');\n    document.body.removeChild(parentEl);\n}\n\n\n\n\n\nclass $f4729f31dd8a035c$export$e44a253a59704894 extends HTMLElement {\n    button;\n    #buttonStyle;\n    constructor(){\n        super();\n        this.attachShadow({\n            mode: 'open'\n        });\n        this.shadowRoot.innerHTML = `\n      <style>\n        :host {\n          display: inline-block;\n          position: relative;\n        }\n\n        button {\n          display: block;\n          padding: 10px 15px;\n          background: transparent;\n          color: white;\n          border: none;\n          cursor: pointer;\n          font: inherit;\n        }\n\n        button:hover {\n          background: #444;\n        }\n\n        button:focus {\n          background: rgba(255,255,255,.2)\n        }\n        ul {\n          display: none;\n          position: absolute;\n          top: 100%;\n          right: 0;\n          min-width: 120px;\n          background: var(--color-dialog-background);\n          border: var(--border-dialog);\n          margin: 0;\n          padding: 0;\n          list-style: none;\n          z-index: 1000;\n          box-shadow: 1px 1px 10px rgba(0,0,0,.7)\n        }\n\n        :host(.open) ul {\n          display: block;\n        }\n      </style>\n\n      <button aria-haspopup=\"true\" aria-expanded=\"false\">\n        <slot name=\"label\">Menu</slot>\n      </button>\n      <ul role=\"menu\">\n        <slot></slot>\n      </ul>\n    `;\n    }\n    connectedCallback() {\n        this.button = this.shadowRoot.querySelector('button');\n        this.button.addEventListener('click', ()=>this.toggle());\n        if (this.#buttonStyle) this.button.style = this.#buttonStyle;\n        document.addEventListener('click', (e)=>{\n            if (!this.contains(e.target) && !this.shadowRoot.contains(e.target)) this.close();\n        });\n        this.button.addEventListener('keydown', (e)=>{\n            if (e.key === 'Escape') {\n                this.close();\n                this.button.focus();\n            }\n        });\n        // Listen for selection from child items\n        this.addEventListener('item-selected', (e)=>{\n            const customEvent = e;\n            this.dispatchEvent(new CustomEvent('select', {\n                detail: {\n                    value: customEvent.detail.value\n                },\n                bubbles: true,\n                composed: true\n            }));\n            this.close();\n        });\n    }\n    static get observedAttributes() {\n        return [\n            'button-style'\n        ];\n    }\n    attributeChangedCallback(name, oldVal, newVal) {\n        if (name === 'button-style') {\n            if (this.button) this.button.style = newVal;\n            else this.#buttonStyle = newVal;\n        }\n    }\n    toggle() {\n        const isOpen = this.classList.toggle('open');\n        this.button.setAttribute('aria-expanded', String(isOpen));\n    }\n    close() {\n        this.classList.remove('open');\n        this.button.setAttribute('aria-expanded', 'false');\n    }\n}\ncustomElements.define('dropdown-menu', $f4729f31dd8a035c$export$e44a253a59704894);\n\n\nclass $0096ec60fce19dcf$var$DropdownMenuItem extends HTMLElement {\n    static get observedAttributes() {\n        return [\n            'value'\n        ];\n    }\n    value = '';\n    constructor(){\n        super();\n        this.attachShadow({\n            mode: 'open'\n        });\n        this.shadowRoot.innerHTML = `\n      <style>\n        li {\n          list-style: none;\n          padding: 12px 40px 12px 20px;\n          color: White;\n          text-decoration: none;\n          white-space: nowrap;\n          background: transparent;\n          cursor: pointer;\n        }\n        li:hover {\n          background: rgba(255,255,255,.1);\n        }\n        span:not(:empty) {\n          float: left; \n          margin-right: .5em;\n          position: relative;\n          left: -4px;\n          top: 1px;\n        }\n      </style>\n      <li role=\"menuitem\">\n        <span id=\"icon\"><slot name=\"icon\"></span>\n        <slot></slot>\n      </li>\n    `;\n    }\n    connectedCallback() {\n        const item = this.shadowRoot.querySelector('li');\n        item.addEventListener('click', (e)=>{\n            e.preventDefault();\n            this.dispatchEvent(new CustomEvent('item-selected', {\n                detail: {\n                    value: this.value\n                },\n                bubbles: true,\n                composed: true\n            }));\n        });\n    }\n    attributeChangedCallback(name, _oldValue, newValue) {\n        if (name === 'value') this.value = newValue;\n    }\n}\ncustomElements.define('dropdown-menu-item', $0096ec60fce19dcf$var$DropdownMenuItem);\n\n\nvar $eb971f7ae22dc5e1$exports = {};\n$eb971f7ae22dc5e1$exports = \"dialog{background:var(--color-dialog-background);color:#fff;border:var(--border-dialog);width:400px;margin:0;position:fixed;top:100px;left:50%;overflow:hidden;transform:translate(-50%);box-shadow:0 0 10px #000c}dialog::backdrop{background:#000000b3}.dialog-title{color:var(--color-accent);text-shadow:1px 1px 1px #000;margin-top:0;font-size:1.4em;font-weight:400}dialog.error .dialog-title{color:var(--color-error)}.dialog-input{border:solid 1px var(--color-input);color:#fff;background:0 0;border-radius:4px;outline:none;width:100%;font-size:1.1em;height:40px!important;padding:4px 8px!important}.dialog-input::selection{color:#000;background:#fff}.dialog-input:hover,.dialog-input:active,.dialog-input:focus-visible{border-color:var(--color-input-active)}.dialog-input:active,.dialog-input:focus-visible{background:#ffffff1a}.dialog-menu{text-align:end;flex-direction:row;justify-content:end;align-items:center;margin-bottom:0;display:flex}.dialog-menu button{color:#fff;cursor:pointer;background:0 0;border:none;border-radius:4px;margin-inline-start:.5em;padding:8px 16px;font-size:1em}.dialog-menu button[type=submit]{background:var(--color-input)}dialog.error .dialog-menu button[type=submit]{background:var(--color-error)}.dialog-menu button[type=submit]:hover{background:var(--color-input-active)}.dialog-menu .btn-cancel{opacity:.5}.dialog-menu .btn-cancel:hover,.dialog-menu .btn-cancel:focus{opacity:1}#dialog_contents{display:flex}\";\n\n\nconst $34a1caf943752901$var$sheet = new CSSStyleSheet();\n$34a1caf943752901$var$sheet.replaceSync(String($eb971f7ae22dc5e1$exports));\nclass $34a1caf943752901$export$2e2bcd8739ae039 extends HTMLElement {\n    dialog;\n    input;\n    static get observedAttributes() {\n        return [\n            'title',\n            'description',\n            'value',\n            'submit',\n            'cancel',\n            'type'\n        ];\n    }\n    constructor(){\n        super();\n        const shadow = this.attachShadow({\n            mode: 'open'\n        });\n        shadow.adoptedStyleSheets = [\n            $34a1caf943752901$var$sheet\n        ];\n        this.shadowRoot.innerHTML = `\n      <confirm-dialog>\n        <input\n            type=\"text\"\n            class=\"dialog-input\"\n            name=\"patternName\"\n            required\n          />\n      </confirm-dialog>\n    `;\n        this.dialog = shadow.querySelector('confirm-dialog');\n        this.input = shadow.querySelector('input');\n        this.input.addEventListener('keypress', (e)=>{\n            if (e.code === 'Enter') this.dialog.submit();\n        });\n    }\n    connectedCallback() {\n        this.syncAttributes();\n    }\n    attributeChangedCallback() {\n        this.syncAttributes();\n    }\n    syncAttributes() {\n        $34a1caf943752901$export$2e2bcd8739ae039.observedAttributes.filter((attr)=>attr !== 'value').forEach((attr)=>{\n            if (this.hasAttribute(attr)) this.dialog.setAttribute(attr, this.getAttribute(attr));\n            else this.dialog.removeAttribute(attr);\n        });\n        if (this.hasAttribute('value')) this.input.value = this.getAttribute('value') || '';\n    }\n    /**\n   * Opens the dialog, optionally with an initial value.\n   */ show(initialValue) {\n        if (initialValue !== undefined) this.input.value = initialValue;\n        else if (this.hasAttribute('value')) this.input.value = this.getAttribute('value') || '';\n        this.input.select();\n        return this.dialog.show().then(()=>this.input.value);\n    }\n    /**\n   * Gets the value entered by the user if submitted,\n   * or null if canceled.\n   */ getValue() {\n        return this.input.value;\n    }\n}\ncustomElements.define('input-dialog', $34a1caf943752901$export$2e2bcd8739ae039);\n\n\nvar $7a37a3caedf4d681$exports = {};\n$7a37a3caedf4d681$exports = \"dialog{background:var(--color-dialog-background);color:#fff;border:var(--border-dialog);width:400px;margin:0;position:fixed;top:100px;left:50%;overflow:hidden;transform:translate(-50%);box-shadow:0 0 10px #000c}dialog::backdrop{background:#000000b3}.dialog-title{color:var(--color-accent);text-shadow:1px 1px 1px #000;margin-top:0;font-size:1.4em;font-weight:400}dialog.error .dialog-title{color:var(--color-error)}.dialog-input{border:solid 1px var(--color-input);color:#fff;background:0 0;border-radius:4px;outline:none;width:100%;font-size:1.1em;height:40px!important;padding:4px 8px!important}.dialog-input::selection{color:#000;background:#fff}.dialog-input:hover,.dialog-input:active,.dialog-input:focus-visible{border-color:var(--color-input-active)}.dialog-input:active,.dialog-input:focus-visible{background:#ffffff1a}.dialog-menu{text-align:end;flex-direction:row;justify-content:end;align-items:center;margin-bottom:0;display:flex}.dialog-menu button{color:#fff;cursor:pointer;background:0 0;border:none;border-radius:4px;margin-inline-start:.5em;padding:8px 16px;font-size:1em}.dialog-menu button[type=submit]{background:var(--color-input)}dialog.error .dialog-menu button[type=submit]{background:var(--color-error)}.dialog-menu button[type=submit]:hover{background:var(--color-input-active)}.dialog-menu .btn-cancel{opacity:.5}.dialog-menu .btn-cancel:hover,.dialog-menu .btn-cancel:focus{opacity:1}#dialog_contents{display:flex}\";\n\n\nconst $1b7158181746ebe4$var$sheet = new CSSStyleSheet();\n$1b7158181746ebe4$var$sheet.replaceSync(String($7a37a3caedf4d681$exports));\nclass $1b7158181746ebe4$export$2e2bcd8739ae039 extends HTMLElement {\n    dialog;\n    cancelBtn;\n    submitBtn;\n    titleEl;\n    descEl;\n    static get observedAttributes() {\n        return [\n            'title',\n            'description',\n            'submit',\n            'cance',\n            'type'\n        ];\n    }\n    constructor(){\n        super();\n        const shadow = this.attachShadow({\n            mode: 'open'\n        });\n        shadow.adoptedStyleSheets = [\n            $1b7158181746ebe4$var$sheet\n        ];\n        this.shadowRoot.innerHTML = `\n      <dialog>\n        <form method=\"dialog\">\n          <h2 class=\"dialog-title\"></h2>\n          <p class=\"dialog-desc\"></p>\n          <div id=\"dialog_contents\">\n            <slot></slot>\n          </div>\n          <menu class=\"dialog-menu\">\n            <button type=\"button\" class=\"btn-cancel\">Cancel</button>\n            <button type=\"submit\" value=\"confirm\" class=\"btn-submit\"></button>\n          </menu>\n        </form>\n      </dialog>\n    `;\n        this.dialog = shadow.querySelector('dialog');\n        this.cancelBtn = shadow.querySelector('.btn-cancel');\n        this.submitBtn = shadow.querySelector('.btn-submit');\n        this.titleEl = shadow.querySelector('.dialog-title');\n        this.descEl = shadow.querySelector('.dialog-desc');\n    }\n    connectedCallback() {\n        this.cancelBtn.addEventListener('click', ()=>{\n            this.dialog.returnValue = '';\n            this.dialog.close();\n        });\n        // Initialize attributes on first connect\n        this.syncAttributes();\n    }\n    attributeChangedCallback() {\n        this.syncAttributes();\n    }\n    syncAttributes() {\n        if (this.hasAttribute('title')) this.titleEl.textContent = this.getAttribute('title');\n        if (this.hasAttribute('description')) this.descEl.textContent = this.getAttribute('description');\n        this.submitBtn.textContent = this.getAttribute('submit') || 'Submit';\n        this.cancelBtn.textContent = this.getAttribute('cancel') || 'Cancel';\n        if (this.hasAttribute('type') && this.getAttribute('type') === 'error') this.dialog.classList.add('error');\n        else this.dialog.classList.remove('error');\n    }\n    /**\n   * Opens the dialog, optionally with an initial value.\n   */ show() {\n        this.dialog.showModal();\n        return new Promise((resolve, reject)=>{\n            const handleClose = ()=>{\n                this.dialog.removeEventListener('close', handleClose);\n                if (this.dialog.returnValue === 'confirm') resolve();\n                else reject();\n            };\n            this.dialog.addEventListener('close', handleClose);\n        });\n    }\n    submit() {\n        this.submitBtn.click();\n    }\n}\ncustomElements.define('confirm-dialog', $1b7158181746ebe4$export$2e2bcd8739ae039);\n\n\n\n\n\n\n\nwindow.addEventListener('error', function(event) {\n    alert('Error: ' + event.message);\n});\nconst $1ccc8d3c866b7484$var$elements = {\n    main: document.querySelector('main'),\n    canvas: document.querySelector('#canvas_panel'),\n    downloadBtn: document.querySelector('#download_btn'),\n    downloadSVGBtn: document.querySelector('#download_svg_btn'),\n    downloadNailsBtn: document.querySelector('#download_nails_btn'),\n    resetBtn: document.querySelector('#reset_btn'),\n    shareBtn: document.querySelector('#share_btn'),\n    playerBtn: document.querySelector('#player_btn'),\n    buttons: document.querySelector('#buttons'),\n    instructionsLink: document.querySelector('#pattern_select_dropdown_instructions')\n};\nlet $1ccc8d3c866b7484$var$currentRenderer;\nconst $1ccc8d3c866b7484$var$player = new (0, $f003126099aabc1e$export$2e2bcd8739ae039)(document.querySelector('#player'));\nconst $1ccc8d3c866b7484$var$sizeControls = new (0, $fb81eeeade2a45e9$export$2e2bcd8739ae039)({\n    getCurrentSize: ()=>[\n            $1ccc8d3c866b7484$var$elements.canvas.clientWidth,\n            $1ccc8d3c866b7484$var$elements.canvas.clientHeight\n        ]\n});\nconst $1ccc8d3c866b7484$var$persistance = new (0, $00643d12b3a54506$export$2e2bcd8739ae039)();\nconst $1ccc8d3c866b7484$var$thumbnails = new (0, $8a4d6517fbd25a59$export$45b50bca1da1e9b3)($1ccc8d3c866b7484$var$persistance);\nwindow.addEventListener('load', $1ccc8d3c866b7484$var$main);\nasync function $1ccc8d3c866b7484$var$main() {\n    let controls;\n    initRouting();\n    await (0, $718de5d870731526$export$d594efb518b3cec4)();\n    document.body.querySelectorAll('.pattern_only').forEach($1ccc8d3c866b7484$var$hide);\n    $1ccc8d3c866b7484$var$unHide(document.querySelector('main'));\n    const queryParams = new URLSearchParams(document.location.search);\n    $1ccc8d3c866b7484$var$currentRenderer = queryParams.get('renderer') === 'svg' ? new (0, $3ff5c6d6cb93edd9$export$2e2bcd8739ae039)($1ccc8d3c866b7484$var$elements.canvas) : new (0, $d45f09bc4feaf860$export$2e2bcd8739ae039)($1ccc8d3c866b7484$var$elements.canvas);\n    const patterns = (0, $3eff4f8917d513a6$export$2e2bcd8739ae039).map((Pattern)=>new Pattern($1ccc8d3c866b7484$var$currentRenderer));\n    let currentPattern;\n    if (history.state?.pattern) updateState(history.state);\n    else {\n        const queryPattern = queryParams.get('pattern');\n        if (queryPattern) {\n            const config = queryParams.get('config');\n            updateState({\n                pattern: queryPattern,\n                config: config\n            });\n        } else $1ccc8d3c866b7484$var$thumbnails.toggle();\n    }\n    $1ccc8d3c866b7484$var$elements.downloadBtn.addEventListener('click', downloadCanvas);\n    $1ccc8d3c866b7484$var$elements.downloadSVGBtn.addEventListener('click', downloadSVG);\n    $1ccc8d3c866b7484$var$elements.downloadNailsBtn.addEventListener('click', downloadNailsImage);\n    $1ccc8d3c866b7484$var$elements.resetBtn.addEventListener('click', reset);\n    $1ccc8d3c866b7484$var$elements.shareBtn.addEventListener('click', async ()=>await (0, $38bb4a85553a6bfc$export$ed80d9de1d9df928)({\n            renderer: $1ccc8d3c866b7484$var$currentRenderer,\n            pattern: currentPattern\n        }));\n    function deactivateTabs(exclude) {\n        document.querySelectorAll('#buttons [data-toggle-for].active').forEach((btn)=>{\n            if (btn instanceof HTMLElement && !exclude?.includes(btn.getAttribute('data-toggle-for'))) btn.click();\n        });\n    }\n    $1ccc8d3c866b7484$var$elements.instructionsLink.addEventListener('click', (e)=>{\n        e.preventDefault();\n        history.pushState({\n            pattern: null\n        }, 'String Art Studio', './');\n        unselectPattern();\n    });\n    $1ccc8d3c866b7484$var$thumbnails.addEventListener('select', ({ patternId: patternId })=>{\n        const pattern = findPatternById(patternId);\n        setCurrentPattern(pattern);\n    });\n    $1ccc8d3c866b7484$var$elements.canvas.addEventListener('wheel', ({ deltaY: deltaY })=>{\n        const direction = -deltaY / Math.abs(deltaY); // Up is 1, down is -1\n        $1ccc8d3c866b7484$var$player.advance(direction);\n    });\n    // // If just a click, advance by one. If touch is left, play until removed\n    // elements.canvas.addEventListener('mousedown', () => {\n    //   let timeout;\n    //   const advance = () => {\n    //     clearTimeout(timeout);\n    //     player.advance();\n    //     elements.canvas.removeEventListener('mouseup', advance);\n    //   };\n    //   timeout = setTimeout(() => {\n    //     player.play();\n    //     const stopPlay = () => {\n    //       player.pause();\n    //       elements.canvas.removeEventListener('mouseup', stopPlay);\n    //     };\n    //     elements.canvas.addEventListener('mouseup', stopPlay);\n    //   }, 200);\n    //   elements.canvas.addEventListener('mouseup', advance);\n    // });\n    document.body.addEventListener('click', (e)=>{\n        const toggleBtn = e.target instanceof HTMLElement && e.target.closest('[data-toggle-for]');\n        if (toggleBtn instanceof HTMLElement && toggleBtn) {\n            const dialogId = toggleBtn.dataset.toggleFor;\n            deactivateTabs([\n                dialogId\n            ]);\n            toggleBtn.classList.toggle('active');\n            const toggledElement = document.querySelector('#' + dialogId);\n            if (toggledElement) {\n                toggledElement.classList.toggle('open');\n                document.body.classList.toggle('dialog_' + dialogId);\n                currentPattern && currentPattern.draw({\n                    position: currentPattern.position\n                });\n            }\n        }\n    });\n    $1ccc8d3c866b7484$var$persistance.addEventListener('deletePattern', ({ pattern: pattern })=>{\n        const templatePattern = findPatternById(pattern.type);\n        if (templatePattern) {\n            templatePattern.config = pattern.config;\n            setCurrentPattern(templatePattern, {\n                isDefaultConfig: false\n            });\n        }\n    });\n    $1ccc8d3c866b7484$var$persistance.addEventListener('save', ({ pattern: pattern })=>{\n        setCurrentPattern(pattern);\n    });\n    function initRouting() {\n        window.addEventListener('popstate', ({ state: state })=>{\n            updateState(state);\n        });\n    }\n    function updateState(state) {\n        if (state?.pattern) {\n            const pattern = findPatternById(state.pattern);\n            if (pattern) {\n                pattern.renderer = $1ccc8d3c866b7484$var$currentRenderer;\n                selectPattern(pattern, {\n                    draw: false,\n                    config: state.config ? (0, $d8f8628a77747326$export$39ef19ebad6081a3)(pattern, state.config) : null\n                });\n                $1ccc8d3c866b7484$var$thumbnails.close();\n                currentPattern.draw();\n            } else $1ccc8d3c866b7484$var$thumbnails.open();\n        } else {\n            unselectPattern();\n            $1ccc8d3c866b7484$var$thumbnails.open();\n        }\n    }\n    function findPatternById(patternId) {\n        let pattern = patterns.find(({ id: id })=>id === patternId);\n        if (!pattern) // Try from persistance\n        pattern = (0, $00643d12b3a54506$export$2e2bcd8739ae039).getPatternByID(patternId);\n        return pattern;\n    }\n    async function initPattern() {\n        if (!currentPattern) throw new Error(\"Can't init pattern - no current pattern available!\");\n        initSize();\n        window.addEventListener('resize', ()=>currentPattern && currentPattern.draw());\n        $1ccc8d3c866b7484$var$elements.downloadBtn.addEventListener('click', downloadCanvas);\n        $1ccc8d3c866b7484$var$elements.downloadNailsBtn.addEventListener('click', downloadNailsImage);\n        $1ccc8d3c866b7484$var$elements.resetBtn.addEventListener('click', reset);\n        const showShare = await (0, $38bb4a85553a6bfc$export$4fa6f570da04f7cc)({\n            renderer: $1ccc8d3c866b7484$var$currentRenderer,\n            pattern: currentPattern\n        });\n        if (showShare) $1ccc8d3c866b7484$var$unHide($1ccc8d3c866b7484$var$elements.shareBtn);\n    }\n    function downloadCanvas() {\n        (0, $b7266296a7c0118e$export$bb3b75778e3e272)($1ccc8d3c866b7484$var$currentRenderer.toDataURL(), currentPattern.name + '.png');\n    }\n    function downloadSVG() {\n        (0, $21c7ecb944647062$export$a0b41a3b036d92d2)(currentPattern, $1ccc8d3c866b7484$var$currentRenderer.getSize());\n    }\n    function downloadNailsImage() {\n        const currentConfig = currentPattern.config;\n        currentPattern.config = {\n            ...currentConfig,\n            darkMode: false,\n            showNails: true,\n            showNailNumbers: true,\n            showStrings: false,\n            nailsColor: '#000000'\n        };\n        currentPattern.draw();\n        downloadCanvas();\n        // Reset to the config before the download:\n        currentPattern.config = currentConfig;\n        currentPattern.draw();\n    }\n    function reset() {\n        (0, $174f2c93f6348ee5$export$715f9d76bb8c1fea)({\n            title: 'Reset options',\n            description: currentPattern.isTemplate ? 'Are you sure you wish to reset options to defaults?' : 'Are you sure you wish to reset to the latest saved options?',\n            submit: 'Reset'\n        }).then(()=>{\n            const pattern = findPatternById(currentPattern.id);\n            setCurrentPattern(pattern, currentPattern.isTemplate ? {\n                config: {}\n            } : {}); // For a template, make sure to reset the config, for saved patterns loading the pattern above gets the latest saved options\n        }, ()=>{});\n    }\n    function onInputsChange() {\n        $1ccc8d3c866b7484$var$player.update(currentPattern);\n        const configQuery = (0, $d8f8628a77747326$export$fa8157df3262779b)(currentPattern);\n        history.replaceState({\n            pattern: currentPattern.id,\n            config: configQuery\n        }, currentPattern.name, `?pattern=${currentPattern.id}${configQuery ? `&config=${encodeURIComponent(configQuery)}` : ''}`);\n        setIsDefaultConfig();\n    }\n    function setIsDefaultConfig(value) {\n        // Determine whether the pattern is currently on its last saved (for saved patterns) or default state (for templates):\n        const isDefaultConfig = value ?? currentPattern.isTemplate ? (0, $c29d66861308df7e$export$f05027632b38f3a4)(currentPattern.config, currentPattern.defaultConfig) : (0, $c29d66861308df7e$export$f05027632b38f3a4)(currentPattern.config, findPatternById(currentPattern.id).config);\n        $1ccc8d3c866b7484$var$elements.main.dataset.isDefaultConfig = String(isDefaultConfig);\n    }\n    function setCurrentPattern(pattern, setPatternOptions) {\n        selectPattern(pattern, setPatternOptions);\n        history.pushState({\n            pattern: pattern.id\n        }, pattern.name, '?pattern=' + pattern.id);\n        $1ccc8d3c866b7484$var$elements.main.dataset.isDefaultConfig = String(setPatternOptions?.isDefaultConfig !== false);\n    }\n    function initSize() {\n        $1ccc8d3c866b7484$var$sizeControls.element.addEventListener('sizechange', ({ detail: detail })=>{\n            setSize(detail);\n        });\n    }\n    function setSize(size) {\n        if (size && size.length === 2) {\n            $1ccc8d3c866b7484$var$currentRenderer.setSize(size);\n            if (!$1ccc8d3c866b7484$var$elements.canvas.classList.contains('overflow')) $1ccc8d3c866b7484$var$elements.canvas.classList.add('overflow');\n        } else {\n            $1ccc8d3c866b7484$var$elements.canvas.classList.remove('overflow');\n            $1ccc8d3c866b7484$var$currentRenderer.setSize(null);\n        }\n        currentPattern.draw();\n    }\n    function selectPattern(pattern, { config: config, draw: draw = true } = {}) {\n        const isFirstTime = !currentPattern;\n        currentPattern = pattern;\n        currentPattern.renderer = $1ccc8d3c866b7484$var$currentRenderer;\n        if (config) // @ts-ignore\n        currentPattern.setConfig(config);\n        if (controls) controls.destroy();\n        $1ccc8d3c866b7484$var$persistance.setPattern(currentPattern);\n        controls = new (0, $da037f8140467741$export$2e2bcd8739ae039)(pattern.configControls, pattern.config);\n        controls.addEventListener('input', ({ control: control, value: value })=>{\n            currentPattern.setConfigValue(control, value);\n            controls.config = currentPattern.config;\n            currentPattern.draw();\n        });\n        controls.addEventListener('change', onInputsChange);\n        if (draw) requestAnimationFrame(()=>{\n            currentPattern.draw();\n        });\n        $1ccc8d3c866b7484$var$thumbnails.setCurrentPattern(pattern);\n        document.title = `${pattern.name} - String Art Studio`;\n        document.body.setAttribute('data-pattern', pattern.id);\n        if (isFirstTime) {\n            initPattern();\n            document.body.querySelectorAll('.pattern_only').forEach($1ccc8d3c866b7484$var$unHide);\n        }\n        $1ccc8d3c866b7484$var$player.update(currentPattern, {\n            draw: false\n        });\n        $1ccc8d3c866b7484$var$elements.main.dataset.isTemplate = String(currentPattern.isTemplate);\n    }\n    function unselectPattern() {\n        currentPattern = null;\n        $1ccc8d3c866b7484$var$currentRenderer.clear();\n        $1ccc8d3c866b7484$var$thumbnails.setCurrentPattern(null);\n        controls && controls.destroy();\n        document.body.querySelectorAll('.pattern_only').forEach($1ccc8d3c866b7484$var$hide);\n        document.body.removeAttribute('data-pattern');\n    }\n}\nfunction $1ccc8d3c866b7484$var$unHide(element) {\n    element.removeAttribute('hidden');\n}\nfunction $1ccc8d3c866b7484$var$hide(element) {\n    element.setAttribute('hidden', 'hidden');\n}\n\n\n//# sourceMappingURL=string_art.07585b46.js.map\n","import Player from './editor/Player';\nimport patternTypes from './pattern_types';\nimport EditorControls from './editor/EditorControls';\nimport EditorSizeControls from './editor/EditorSizeControls';\nimport { Thumbnails } from './thumbnails/Thumbnails';\nimport { deserializeConfig, serializeConfig } from './Serialize';\nimport { isShareSupported, share } from './share';\nimport { initServiceWorker } from './pwa';\nimport CanvasRenderer from './renderers/CanvasRenderer';\nimport SVGRenderer from './renderers/SVGRenderer';\nimport { downloadPatternAsSVG } from './download/SVGDownload';\nimport { downloadFile } from './download/Download';\nimport './components/components';\nimport type Renderer from './renderers/Renderer';\nimport type { Dimensions } from './types/general.types';\nimport { PrimitiveValue } from './types/config.types';\nimport Persistance from './Persistance';\nimport StringArt from './StringArt';\nimport { compareObjects } from './helpers/object_utils';\nimport { confirm } from './helpers/dialogs';\n\ninterface SetPatternOptions {\n  config?: Record<string, PrimitiveValue>;\n  draw?: boolean;\n  isDefaultConfig?: boolean;\n}\n\nwindow.addEventListener('error', function (event) {\n  alert('Error: ' + event.message);\n});\n\nconst elements: { [key: string]: HTMLElement } = {\n  main: document.querySelector('main'),\n  canvas: document.querySelector('#canvas_panel'),\n  downloadBtn: document.querySelector('#download_btn'),\n  downloadSVGBtn: document.querySelector('#download_svg_btn'),\n  downloadNailsBtn: document.querySelector('#download_nails_btn'),\n  resetBtn: document.querySelector('#reset_btn'),\n  shareBtn: document.querySelector('#share_btn'),\n  playerBtn: document.querySelector('#player_btn'),\n  buttons: document.querySelector('#buttons'),\n  instructionsLink: document.querySelector(\n    '#pattern_select_dropdown_instructions'\n  ),\n};\n\nlet currentRenderer: Renderer;\n\nconst player = new Player(document.querySelector('#player'));\nconst sizeControls = new EditorSizeControls({\n  getCurrentSize: () => [\n    elements.canvas.clientWidth,\n    elements.canvas.clientHeight,\n  ],\n});\n\nconst persistance = new Persistance();\nconst thumbnails = new Thumbnails(persistance);\n\nwindow.addEventListener('load', main);\n\nasync function main() {\n  let controls: EditorControls<any>;\n\n  initRouting();\n\n  await initServiceWorker();\n\n  document.body.querySelectorAll('.pattern_only').forEach(hide);\n  unHide(document.querySelector('main'));\n\n  const queryParams = new URLSearchParams(document.location.search);\n  currentRenderer =\n    queryParams.get('renderer') === 'svg'\n      ? new SVGRenderer(elements.canvas)\n      : new CanvasRenderer(elements.canvas);\n\n  const patterns = patternTypes.map(Pattern => new Pattern(currentRenderer));\n  type Pattern = StringArt<any>;\n  let currentPattern: Pattern;\n\n  if (history.state?.pattern) {\n    updateState(history.state);\n  } else {\n    const queryPattern = queryParams.get('pattern');\n\n    if (queryPattern) {\n      const config = queryParams.get('config');\n      updateState({ pattern: queryPattern, config });\n    } else {\n      thumbnails.toggle();\n    }\n  }\n\n  elements.downloadBtn.addEventListener('click', downloadCanvas);\n  elements.downloadSVGBtn.addEventListener('click', downloadSVG);\n  elements.downloadNailsBtn.addEventListener('click', downloadNailsImage);\n  elements.resetBtn.addEventListener('click', reset);\n  elements.shareBtn.addEventListener(\n    'click',\n    async () =>\n      await share({\n        renderer: currentRenderer,\n        pattern: currentPattern,\n      })\n  );\n\n  function deactivateTabs(exclude?: string[]) {\n    document\n      .querySelectorAll('#buttons [data-toggle-for].active')\n      .forEach(btn => {\n        if (\n          btn instanceof HTMLElement &&\n          !exclude?.includes(btn.getAttribute('data-toggle-for'))\n        ) {\n          btn.click();\n        }\n      });\n  }\n\n  elements.instructionsLink.addEventListener('click', e => {\n    e.preventDefault();\n    history.pushState({ pattern: null }, 'String Art Studio', './');\n    unselectPattern();\n  });\n\n  thumbnails.addEventListener('select', ({ patternId }) => {\n    const pattern = findPatternById(patternId);\n    setCurrentPattern(pattern);\n  });\n\n  elements.canvas.addEventListener('wheel', ({ deltaY }) => {\n    const direction = -deltaY / Math.abs(deltaY); // Up is 1, down is -1\n    player.advance(direction);\n  });\n  // // If just a click, advance by one. If touch is left, play until removed\n  // elements.canvas.addEventListener('mousedown', () => {\n  //   let timeout;\n\n  //   const advance = () => {\n  //     clearTimeout(timeout);\n  //     player.advance();\n  //     elements.canvas.removeEventListener('mouseup', advance);\n  //   };\n\n  //   timeout = setTimeout(() => {\n  //     player.play();\n  //     const stopPlay = () => {\n  //       player.pause();\n  //       elements.canvas.removeEventListener('mouseup', stopPlay);\n  //     };\n  //     elements.canvas.addEventListener('mouseup', stopPlay);\n  //   }, 200);\n\n  //   elements.canvas.addEventListener('mouseup', advance);\n  // });\n\n  document.body.addEventListener('click', e => {\n    const toggleBtn =\n      e.target instanceof HTMLElement && e.target.closest('[data-toggle-for]');\n    if (toggleBtn instanceof HTMLElement && toggleBtn) {\n      const dialogId = toggleBtn.dataset.toggleFor;\n\n      deactivateTabs([dialogId]);\n      toggleBtn.classList.toggle('active');\n\n      const toggledElement = document.querySelector('#' + dialogId);\n      if (toggledElement) {\n        toggledElement.classList.toggle('open');\n        document.body.classList.toggle('dialog_' + dialogId);\n        currentPattern &&\n          currentPattern.draw({ position: currentPattern.position });\n      }\n    }\n  });\n\n  persistance.addEventListener('deletePattern', ({ pattern }) => {\n    const templatePattern = findPatternById(pattern.type);\n    if (templatePattern) {\n      templatePattern.config = pattern.config;\n      setCurrentPattern(templatePattern, { isDefaultConfig: false });\n    }\n  });\n\n  persistance.addEventListener('save', ({ pattern }) => {\n    setCurrentPattern(pattern);\n  });\n\n  function initRouting() {\n    window.addEventListener('popstate', ({ state }) => {\n      updateState(state);\n    });\n  }\n\n  function updateState(state?: { pattern: string; config: any }) {\n    if (state?.pattern) {\n      const pattern = findPatternById(state.pattern);\n      if (pattern) {\n        pattern.renderer = currentRenderer;\n        selectPattern(pattern, {\n          draw: false,\n          config: state.config\n            ? deserializeConfig(pattern, state.config)\n            : null,\n        });\n\n        thumbnails.close();\n        currentPattern.draw();\n      } else {\n        thumbnails.open();\n      }\n    } else {\n      unselectPattern();\n      thumbnails.open();\n    }\n  }\n\n  function findPatternById(patternId: string): StringArt<any> | null {\n    let pattern: StringArt<any> = patterns.find(({ id }) => id === patternId);\n\n    if (!pattern) {\n      // Try from persistance\n      pattern = Persistance.getPatternByID(patternId);\n    }\n    return pattern;\n  }\n\n  async function initPattern() {\n    if (!currentPattern) {\n      throw new Error(\"Can't init pattern - no current pattern available!\");\n    }\n\n    initSize();\n\n    window.addEventListener(\n      'resize',\n      () => currentPattern && currentPattern.draw()\n    );\n\n    elements.downloadBtn.addEventListener('click', downloadCanvas);\n    elements.downloadNailsBtn.addEventListener('click', downloadNailsImage);\n    elements.resetBtn.addEventListener('click', reset);\n    const showShare = await isShareSupported({\n      renderer: currentRenderer,\n      pattern: currentPattern,\n    });\n    if (showShare) {\n      unHide(elements.shareBtn);\n    }\n  }\n\n  function downloadCanvas() {\n    downloadFile(currentRenderer.toDataURL(), currentPattern.name + '.png');\n  }\n\n  function downloadSVG() {\n    downloadPatternAsSVG(currentPattern, currentRenderer.getSize());\n  }\n\n  function downloadNailsImage() {\n    const currentConfig = currentPattern.config;\n    currentPattern.config = {\n      ...currentConfig,\n      darkMode: false,\n      showNails: true,\n      showNailNumbers: true,\n      showStrings: false,\n      nailsColor: '#000000',\n    };\n    currentPattern.draw();\n    downloadCanvas();\n\n    // Reset to the config before the download:\n    currentPattern.config = currentConfig;\n    currentPattern.draw();\n  }\n\n  function reset() {\n    confirm({\n      title: 'Reset options',\n      description: currentPattern.isTemplate\n        ? 'Are you sure you wish to reset options to defaults?'\n        : 'Are you sure you wish to reset to the latest saved options?',\n      submit: 'Reset',\n    }).then(\n      () => {\n        const pattern = findPatternById(currentPattern.id);\n        setCurrentPattern(\n          pattern,\n          currentPattern.isTemplate ? { config: {} } : {}\n        ); // For a template, make sure to reset the config, for saved patterns loading the pattern above gets the latest saved options\n      },\n      () => {}\n    );\n  }\n\n  function onInputsChange() {\n    player.update(currentPattern);\n    const configQuery = serializeConfig(currentPattern);\n    history.replaceState(\n      {\n        pattern: currentPattern.id,\n        config: configQuery,\n      },\n      currentPattern.name,\n      `?pattern=${currentPattern.id}${\n        configQuery ? `&config=${encodeURIComponent(configQuery)}` : ''\n      }`\n    );\n\n    setIsDefaultConfig();\n  }\n\n  function setIsDefaultConfig(value?: boolean) {\n    // Determine whether the pattern is currently on its last saved (for saved patterns) or default state (for templates):\n    const isDefaultConfig =\n      value ?? currentPattern.isTemplate\n        ? compareObjects(currentPattern.config, currentPattern.defaultConfig)\n        : compareObjects(\n            currentPattern.config,\n            findPatternById(currentPattern.id).config\n          );\n\n    elements.main.dataset.isDefaultConfig = String(isDefaultConfig);\n  }\n\n  function setCurrentPattern(\n    pattern: Pattern,\n    setPatternOptions?: SetPatternOptions\n  ) {\n    selectPattern(pattern, setPatternOptions);\n    history.pushState(\n      { pattern: pattern.id },\n      pattern.name,\n      '?pattern=' + pattern.id\n    );\n\n    elements.main.dataset.isDefaultConfig = String(\n      setPatternOptions?.isDefaultConfig !== false\n    );\n  }\n\n  function initSize() {\n    sizeControls.element.addEventListener(\n      'sizechange',\n      ({ detail }: CustomEvent<Dimensions | null>) => {\n        setSize(detail);\n      }\n    );\n  }\n\n  function setSize(size: Dimensions | null) {\n    if (size && size.length === 2) {\n      currentRenderer.setSize(size);\n      if (!elements.canvas.classList.contains('overflow')) {\n        elements.canvas.classList.add('overflow');\n      }\n    } else {\n      elements.canvas.classList.remove('overflow');\n      currentRenderer.setSize(null);\n    }\n\n    currentPattern.draw();\n  }\n\n  function selectPattern(\n    pattern: Pattern,\n    { config, draw = true }: SetPatternOptions = {}\n  ) {\n    const isFirstTime = !currentPattern;\n\n    currentPattern = pattern;\n    currentPattern.renderer = currentRenderer;\n    if (config) {\n      // @ts-ignore\n      currentPattern.setConfig(config);\n    }\n    if (controls) {\n      controls.destroy();\n    }\n\n    persistance.setPattern(currentPattern);\n    controls = new EditorControls<any>(pattern.configControls, pattern.config);\n    controls.addEventListener('input', ({ control, value }) => {\n      currentPattern.setConfigValue(control, value);\n      controls.config = currentPattern.config;\n      currentPattern.draw();\n    });\n    controls.addEventListener('change', onInputsChange);\n\n    if (draw) {\n      requestAnimationFrame(() => {\n        currentPattern.draw();\n      });\n    }\n\n    thumbnails.setCurrentPattern(pattern);\n    document.title = `${pattern.name} - String Art Studio`;\n    document.body.setAttribute('data-pattern', pattern.id);\n\n    if (isFirstTime) {\n      initPattern();\n      document.body.querySelectorAll('.pattern_only').forEach(unHide);\n    }\n\n    player.update(currentPattern, { draw: false });\n\n    elements.main.dataset.isTemplate = String(currentPattern.isTemplate);\n  }\n\n  function unselectPattern() {\n    currentPattern = null;\n    currentRenderer.clear();\n    thumbnails.setCurrentPattern(null);\n    controls && controls.destroy();\n    document.body.querySelectorAll('.pattern_only').forEach(hide);\n    document.body.removeAttribute('data-pattern');\n  }\n}\n\nfunction unHide(element: Element) {\n  element.removeAttribute('hidden');\n}\n\nfunction hide(element: Element) {\n  element.setAttribute('hidden', 'hidden');\n}\n","import type StringArt from '../StringArt';\n\n/**\n * Represents the navigation that controls the StringArt when playing\n */\nexport default class Player {\n  elements: {\n    player: HTMLElement;\n    step: HTMLSpanElement;\n    playerPosition: HTMLInputElement;\n    playBtn: HTMLButtonElement;\n    pauseBtn: HTMLButtonElement;\n    text: HTMLDivElement;\n  };\n  stepCount: number;\n  #isPlaying: boolean;\n  stringArt: StringArt;\n  #renderRafId: number;\n\n  constructor(parentEl: HTMLElement) {\n    this.elements = {\n      player: parentEl,\n      step: parentEl.querySelector('#step'),\n      //stepInstructions: parentEl.querySelector('#step_instructions'),\n      playerPosition: parentEl.querySelector(\n        '#player_position'\n      ) as HTMLInputElement,\n      playBtn: parentEl.querySelector('#play_btn'),\n      pauseBtn: parentEl.querySelector('#pause_btn'),\n      text: parentEl.querySelector('#player_text'),\n    };\n    this.stepCount = 0;\n    this.#isPlaying = false;\n\n    this.elements.playerPosition.addEventListener('input', ({ target }) => {\n      if ('value' in target) {\n        this.goto(+target.value);\n      }\n    });\n\n    this.elements.playBtn.addEventListener('click', () => {\n      this.play();\n    });\n\n    this.elements.pauseBtn.addEventListener('click', () => {\n      this.pause();\n    });\n  }\n\n  updateStatus(isPlaying: boolean) {\n    if (this.#isPlaying !== isPlaying) {\n      this.elements.player.classList.toggle('playing');\n      this.#isPlaying = isPlaying;\n    }\n  }\n\n  update(stringArt: StringArt<any>, { draw = true } = {}) {\n    this.stringArt = stringArt;\n    this.stepCount = stringArt.getStepCount();\n    this.elements.playerPosition.setAttribute('max', String(this.stepCount));\n    this.elements.step.innerText = `${this.stepCount}/${this.stepCount}`;\n    this.elements.text.style.removeProperty('width');\n    this.elements.text.style.width =\n      (this.elements.text.clientWidth || 70) + 'px';\n    this.goto(this.stepCount, { updateStringArt: draw });\n  }\n\n  updatePosition(position: number) {\n    this.elements.step.innerText = `${position}/${this.stepCount}`;\n    this.elements.playerPosition.value = String(position);\n  }\n\n  goto(position: number, { updateStringArt = true } = {}) {\n    if (position > this.stepCount || position < 1) {\n      return;\n    }\n\n    this.pause();\n    this.updatePosition(position);\n    if (updateStringArt) {\n      this.stringArt.goto(position);\n    }\n  }\n\n  advance(value = 1) {\n    const currentPosition = Number(this.elements.playerPosition.value);\n\n    this.goto(\n      Math.max(\n        1,\n        Math.min(\n          this.stepCount,\n          Number(this.elements.playerPosition.value) + value\n        )\n      )\n    );\n  }\n\n  setInstructions(instructions) {\n    // this.elements.stepInstructions.innerText = instructions;\n  }\n\n  play() {\n    this.updateStatus(true);\n    cancelAnimationFrame(this.#renderRafId);\n\n    if (this.stringArt.position === this.stepCount) {\n      this.stringArt.goto(0);\n    }\n\n    const self = this;\n\n    step();\n\n    function step() {\n      if (!self.stringArt.drawNext().done) {\n        self.#renderRafId = requestAnimationFrame(step);\n      } else {\n        self.updateStatus(false);\n      }\n      self.updatePosition(self.stringArt.position);\n    }\n  }\n\n  pause() {\n    cancelAnimationFrame(this.#renderRafId);\n    this.updateStatus(false);\n  }\n\n  toggle() {\n    if (this.#isPlaying) {\n      this.pause();\n    } else {\n      this.play();\n    }\n  }\n}\n","import Spiral from './string_art_types/Spiral';\nimport Spirals from './string_art_types/Spirals';\nimport Wave from './string_art_types/Wave';\nimport Eye from './string_art_types/Eye';\nimport Mandala from './string_art_types/Mandala';\nimport Star from './string_art_types/Star';\nimport Assymetry from './string_art_types/Assymetry';\nimport Freestyle from './string_art_types/Freestyle';\nimport PolygonPattern from './string_art_types/PolygonPattern';\nimport Flower from './string_art_types/Flower';\nimport MaurerRose from './string_art_types/MaurerRose';\nimport FlowerOfLife from './string_art_types/FlowerOfLife';\nimport Comet from './string_art_types/Comet';\nimport Sun from './string_art_types/Sun';\nimport Lotus from './string_art_types/Lotus';\n\nconst patternTypes = [\n  Star,\n  Assymetry,\n  Mandala,\n  Spiral,\n  Spirals,\n  Wave,\n  Eye,\n  Freestyle,\n  PolygonPattern,\n  Flower,\n  MaurerRose,\n  FlowerOfLife,\n  Comet,\n  Sun,\n  Lotus,\n];\n\nexport default patternTypes;\n","import Color from '../helpers/color/Color';\nimport StringArt from '../StringArt';\nimport Circle from '../helpers/Circle';\nimport { ControlsConfig } from '../types/config.types';\nimport {\n  ColorConfig,\n  ColorMap,\n  ColorValue,\n} from '../helpers/color/color.types';\n\nconst COLOR_CONFIG = Color.getConfig({\n  defaults: {\n    isMultiColor: true,\n    colorCount: 7,\n    color: '#ffbb29',\n    multicolorRange: 21,\n    multicolorStart: 32,\n    multicolorByLightness: true,\n    minLightness: 36,\n    maxLightness: 98,\n  },\n});\n\ninterface SpiralConfig extends ColorConfig {\n  n: number;\n  repetition: number;\n  innerLength: number;\n  rotation: number;\n  distortion: number;\n}\n\nexport default class Spiral extends StringArt<SpiralConfig> {\n  static type = 'spiral';\n\n  id = 'spiral';\n  name = 'Spiral';\n  link =\n    'https://www.etsy.com/il-en/listing/840974781/boho-wall-decor-artwork-spiral-round';\n  controls: ControlsConfig<SpiralConfig> = [\n    {\n      ...Circle.nailsConfig,\n      defaultValue: 200,\n    },\n    {\n      key: 'repetition',\n      label: 'Repetition',\n      defaultValue: 5,\n      type: 'range',\n      attr: { min: 1, max: 20, step: 1 },\n    },\n    {\n      key: 'innerLength',\n      label: 'Spiral thickness',\n      defaultValue: 0.5,\n      type: 'range',\n      attr: {\n        min: ({ n }) => 1 / n,\n        max: 1,\n        step: ({ n }) => 1 / n,\n      },\n      displayValue: ({ n, innerLength }) => Math.round(n * innerLength),\n    },\n    {\n      ...Circle.rotationConfig,\n      defaultValue: 0.75,\n    },\n    Circle.distortionConfig,\n    COLOR_CONFIG,\n  ];\n\n  #realRepetition: number;\n  #circle: Circle;\n  #color: Color;\n  #colorMap: ColorMap;\n\n  setUpDraw() {\n    super.setUpDraw();\n    const { n, rotation, margin, colorCount, repetition, distortion } =\n      this.config;\n    this.#realRepetition = repetition * 2 - 1;\n\n    const circleConfig = {\n      size: this.size,\n      n,\n      margin,\n      rotation,\n      distortion,\n    };\n\n    if (this.#circle) {\n      this.#circle.setConfig(circleConfig);\n    } else {\n      this.#circle = new Circle(circleConfig);\n    }\n\n    this.#color = new Color({\n      ...this.config,\n      colorCount: colorCount,\n    });\n\n    if (colorCount) {\n      this.#colorMap = this.#color.getColorMap({\n        stepCount: this.getStepCount(),\n        colorCount,\n      });\n    }\n  }\n\n  *drawSpiral({\n    shift = 0,\n    color = '#ffffff',\n  }: { shift?: number; color?: ColorValue } = {}): Generator<void> {\n    const { innerLength, n } = this.config;\n\n    let currentInnerLength = Math.round(innerLength * n);\n    let repetitionCount = 0;\n    this.renderer.setColor(color);\n    let prevPointIndex = shift;\n    let prevPoint = this.#circle.getPoint(prevPointIndex);\n    let isPrevPoint = false;\n\n    for (let i = 0; currentInnerLength > 0; i++) {\n      if (this.#colorMap) {\n        const stepColor = this.#colorMap.get(i);\n        if (stepColor) {\n          this.renderer.setColor(stepColor);\n        }\n      }\n\n      prevPointIndex = isPrevPoint\n        ? prevPointIndex - currentInnerLength + 1\n        : prevPointIndex + currentInnerLength;\n\n      if (repetitionCount === this.#realRepetition) {\n        currentInnerLength--;\n        repetitionCount = 0;\n        prevPointIndex++;\n      } else {\n        repetitionCount++;\n      }\n\n      const nextPoint = this.#circle.getPoint(prevPointIndex);\n\n      this.renderer.renderLines(prevPoint, nextPoint);\n      prevPoint = nextPoint;\n\n      yield;\n      isPrevPoint = !isPrevPoint;\n    }\n  }\n\n  *generateStrings(): Generator<void> {\n    yield* this.drawSpiral({\n      color: this.#color.getColor(0),\n    });\n  }\n\n  getStepCount(): number {\n    const { innerLength, repetition, n } = this.config;\n    return Math.round(n * (innerLength * 2) * repetition);\n  }\n\n  drawNails() {\n    this.#circle.drawNails(this.nails);\n  }\n\n  static thumbnailConfig = {\n    n: 60,\n  };\n}\n","import { ControlConfig, ControlsConfig } from '../../types/config.types';\nimport { copyConfig, mapControls } from '../config_utils';\nimport { ColorConfig, ColorMap, ColorValue } from './color.types';\nimport COLOR_CONTROLS from './color_controls';\n\nexport default class Color {\n  config: ColorConfig;\n  multiColorStep: number;\n  multiColorLightnessStep: number;\n  colors: Array<ColorValue>;\n\n  constructor(config: ColorConfig) {\n    this.config = config;\n\n    const {\n      multicolorRange,\n      colorCount,\n      multicolorByLightness,\n      minLightness = 0,\n      maxLightness = 100,\n      multicolorStart,\n      darkMode,\n      saturation,\n      reverseColors,\n      repeatColors,\n      mirrorColors,\n      isMultiColor,\n    } = config;\n\n    if (isMultiColor) {\n      this.multiColorStep = multicolorRange / Math.max(1, colorCount - 1);\n      this.multiColorLightnessStep = multicolorByLightness\n        ? (maxLightness - minLightness) / (Math.max(colorCount, 2) - 1)\n        : 1;\n\n      this.colors = new Array(colorCount).fill(null).map((_, colorIndex) => {\n        const lightness = multicolorByLightness\n          ? minLightness + this.multiColorLightnessStep * colorIndex\n          : darkMode\n          ? 50\n          : 40;\n        return `hsl(${\n          multicolorStart + colorIndex * this.multiColorStep\n        }, ${saturation}%, ${lightness}%)`;\n      });\n\n      if (repeatColors && mirrorColors) {\n        const [_firstColor, ...restColors] = this.colors;\n        restColors.pop();\n        this.colors = [...this.colors, ...restColors.reverse()];\n      }\n\n      if (reverseColors) {\n        this.colors.reverse();\n      }\n    }\n  }\n\n  /**\n   * Returns the color to be used in the provided layer index. If no multiColor is used, will use the 'color' config property.\n   * @param {number} colorIndex\n   * @returns string\n   */\n  getColor(colorIndex: number): ColorValue {\n    const { isMultiColor, colorCount, color, repeatColors } = this.config;\n\n    if (!isMultiColor) {\n      return color;\n    }\n\n    if (colorIndex >= colorCount) {\n      colorIndex = repeatColors\n        ? colorIndex % this.colors.length\n        : this.colors.length - 1;\n    }\n\n    return this.colors[colorIndex];\n  }\n\n  /**\n   * Returns the color with the opposite hue to the color at this index\n   */\n  static getOppositeColor(hslColor: ColorValue): ColorValue {\n    const hslMatch = hslColor.match(\n      /^hsl\\((\\d+)(?:deg)?(?:,?\\s?)(\\d+%?)(?:,?\\s?)(\\d+%?)\\)$/\n    );\n    if (hslMatch) {\n      const oppositeHue = (Number(hslMatch[1]) + 180) % 360;\n      return `hsl(${oppositeHue}, ${hslMatch[2]}, ${hslMatch[3]})`;\n    }\n\n    return null;\n  }\n\n  getColorMap({\n    stepCount,\n    colorCount,\n  }: {\n    stepCount: number;\n    colorCount: number;\n  }): ColorMap {\n    if (!colorCount) {\n      throw new Error(\"Can't get color map, no colorCount provided!\");\n    }\n    const stepsPerColor = Math.floor(stepCount / colorCount);\n    const colorMap = new Map();\n    for (let i = 0; i < colorCount; i++) {\n      colorMap.set(i * stepsPerColor, this.getColor(i));\n    }\n    return colorMap;\n  }\n\n  static getConfig<TCustomConfig = {}>({\n    include,\n    exclude,\n    defaults = {},\n    customControls,\n    propMapper,\n    groupLabel,\n    maxColorCount,\n  }: Partial<{\n    include: Array<keyof ColorConfig>;\n    exclude: Array<keyof ColorConfig>;\n    defaults: Partial<ColorConfig>;\n    customControls: ControlsConfig<TCustomConfig>;\n    propMapper: (\n      control: ControlConfig<ColorConfig>\n    ) => Partial<ControlConfig<ColorConfig>>;\n    groupLabel: string;\n    maxColorCount: number;\n  }>): ControlConfig<ColorConfig & TCustomConfig> {\n    const controls = mapControls(getControls(), propMapper);\n\n    return {\n      key: 'colorGroup',\n      label: groupLabel ?? 'Color',\n      type: 'group',\n      children: [...(customControls ?? []), ...controls],\n    };\n\n    function getControls(\n      controlsConfig?: ControlsConfig<ColorConfig>\n    ): ControlsConfig<ColorConfig> {\n      return (controlsConfig ?? copyConfig(COLOR_CONTROLS))\n        .filter(\n          ({ key }) =>\n            (!exclude || !exclude.includes(key)) &&\n            (!include || include.includes(key))\n        )\n        .map(control => {\n          const finalControl = {\n            ...control,\n            defaultValue: defaults[control.key] ?? control.defaultValue,\n          };\n\n          if (control.type === 'group') {\n            finalControl.children = getControls(control.children);\n          }\n\n          if (control.key === 'colorCount' && maxColorCount) {\n            finalControl.attr.max = maxColorCount;\n          }\n\n          return Object.freeze(finalControl);\n        });\n    }\n  }\n}\n","import type {\n  Config,\n  ControlConfig,\n  ControlsConfig,\n} from '../types/config.types';\n\ninterface ControlConfigNode<T> {\n  control: ControlConfig<T>;\n  parent: ControlConfigNode<T> | null;\n  index: number;\n}\n\nexport function* traverseConfig<T>(\n  controlsConfig: ControlsConfig<T>,\n  parent?: ControlConfigNode<T>\n): Generator<{\n  control: ControlConfig<T>;\n  parent: ControlConfigNode<T> | null;\n  index: number;\n}> {\n  let index = 0;\n\n  for (const control of controlsConfig) {\n    yield { control, index, parent };\n    if (control.children) {\n      yield* traverseConfig(control.children, { control, parent, index });\n    }\n    index++;\n  }\n}\n\nfunction findControlConfigNode<T>(\n  controlsConfig: ControlsConfig<T>,\n  findFn: (control: ControlConfig<T>) => any\n): ControlConfigNode<T> | null {\n  for (const node of traverseConfig(controlsConfig)) {\n    if (findFn(node.control)) {\n      return node;\n    }\n  }\n\n  return null;\n}\n\nfunction getControlConfigNodeByKey<T>(\n  controlsConfig: ControlsConfig<T>,\n  controlKey: string\n): ControlConfigNode<T> | null {\n  return findControlConfigNode(controlsConfig, ({ key }) => key === controlKey);\n}\n\nexport function withoutAttribute<T>(\n  controlConfig: ControlConfig<T>,\n  attributeName: string\n): ControlConfig<T> {\n  const attr = controlConfig.attr;\n  if (!attr) {\n    return controlConfig;\n  }\n\n  const attrCopy = { ...attr };\n  delete attrCopy[attributeName];\n  return {\n    ...controlConfig,\n    attr: attrCopy,\n  };\n}\n\n/**\n * Deep copy of a ControlsConfig\n * @param controlsConfig\n * @returns\n */\nexport function copyConfig<T>(\n  controlsConfig: ControlsConfig<T>\n): ControlsConfig<T> {\n  return controlsConfig.map(control => {\n    const copy = { ...control };\n    if (control.children) {\n      copy.children = copyConfig(control.children);\n    }\n    if (control.attr) {\n      copy.attr = { ...control.attr };\n    }\n\n    return copy;\n  });\n}\n\n/**\n * Gets the index path to a node with the given key. The path includes the index of controls in the 'children' prop of a group.\n * @returns\n */\nexport function getControlPath(\n  controlsConfig: ControlsConfig,\n  controlKey: string\n): Array<number> {\n  const controlNode = getControlConfigNodeByKey(controlsConfig, controlKey);\n  if (controlNode) {\n    const path = [controlNode.index];\n    let parentNode = controlNode.parent;\n    while (parentNode) {\n      path.unshift(parentNode.index);\n      parentNode = parentNode.parent;\n    }\n    return path;\n  }\n\n  return null;\n}\n\n// If the key to add after is found, returns a copy of the controls config (all the tree) with the added config\nexport function insertAfter<T>(\n  controlsConfig: ControlsConfig<T>,\n  insertAfterKey: string,\n  controlsConfigToInsert: ControlsConfig<T>\n) {\n  const configCopy = copyConfig(controlsConfig);\n  const nodeToAddAfter = getControlConfigNodeByKey(configCopy, insertAfterKey);\n\n  if (nodeToAddAfter) {\n    const { index, parent } = nodeToAddAfter;\n    let list = parent?.control.children ?? configCopy;\n    list.splice(index + 1, 0, ...controlsConfigToInsert);\n    return configCopy;\n  }\n\n  return controlsConfig;\n}\n\n/**\n * Maps the array of control configs to change properties using the mapper\n * @param {*} controlsConfig\n * @param {*} controlPropMapper\n * @returns\n */\nexport function mapControls<T>(\n  controlsConfig: ControlsConfig<T>,\n  controlPropMapper: (control: ControlConfig<T>) => Partial<ControlConfig<T>>\n): ControlsConfig<T> {\n  return controlPropMapper\n    ? controlsConfig.map(control => {\n        if (control.children) {\n          control = {\n            ...control,\n            children: mapControls(control.children, controlPropMapper),\n          };\n        }\n\n        return {\n          ...control,\n          ...controlPropMapper(control),\n        };\n      })\n    : controlsConfig;\n}\n\n/**\n * Returns config values for all controls\n * @param configControls\n * @returns\n */\nexport function getConfigDefaultValues<T>(\n  configControls: ControlsConfig<T>\n): Config<T> {\n  const defaultValues = {} as Config<T>;\n  for (const {\n    control: { key, defaultValue },\n  } of traverseConfig(configControls)) {\n    if (!(defaultValue instanceof Function)) {\n      defaultValues[key] = defaultValue;\n    }\n  }\n\n  return defaultValues;\n}\n\n/**\n * Returns an object whose properties are the keys of all controls in the config, with corresponding controls as values.\n * @param configControls\n * @returns\n */\nexport function getControlsIndex<T>(\n  configControls: ControlsConfig<T>\n): Record<keyof T, ControlConfig<T>> {\n  const configIndex = {} as Record<keyof T, ControlConfig<T>>;\n  for (const { control } of traverseConfig(configControls)) {\n    configIndex[control.key] = control;\n  }\n\n  return configIndex;\n}\n","import { ControlsConfig } from '../../types/config.types';\nimport { ColorConfig } from './color.types';\n\nconst COLOR_CONTROLS: ControlsConfig<ColorConfig> = [\n  {\n    key: 'isMultiColor',\n    label: 'Use multiple colors',\n    defaultValue: false,\n    type: 'checkbox',\n  },\n  {\n    key: 'colorCount',\n    label: 'Colors count',\n    defaultValue: 7,\n    type: 'range',\n    attr: {\n      min: 1,\n      max: 20,\n      step: 1,\n    },\n    show: ({ isMultiColor }) => isMultiColor,\n  },\n  {\n    key: 'color',\n    label: 'String color',\n    defaultValue: '#ff4d00',\n    type: 'color',\n    show: ({ isMultiColor }) => !isMultiColor,\n  },\n  {\n    key: 'multicolorStart',\n    label: 'Multicolor start',\n    defaultValue: 1,\n    type: 'hue',\n    attr: {\n      colorthumb: true,\n    },\n    show: ({ isMultiColor }) => isMultiColor,\n  },\n  {\n    key: 'multicolorRange',\n    label: 'Multicolor range',\n    defaultValue: 360,\n    type: 'hue',\n    attr: {\n      start: ({ multicolorStart }) => multicolorStart,\n      type: 'range',\n    },\n    show: ({ isMultiColor }) => isMultiColor,\n  },\n  {\n    key: 'saturation',\n    label: 'Saturation',\n    defaultValue: 100,\n    type: 'range',\n    attr: {\n      min: 0,\n      max: 100,\n      step: 1,\n    },\n    show: ({ isMultiColor }) => isMultiColor,\n  },\n  {\n    key: 'lightness',\n    label: 'Lightness',\n    type: 'group',\n    defaultValue: 'minimized',\n    show: ({ isMultiColor }) => isMultiColor,\n    children: [\n      {\n        key: 'multicolorByLightness',\n        label: 'Multi lightness',\n        defaultValue: false,\n        type: 'checkbox',\n        show: ({ isMultiColor }) => isMultiColor,\n      },\n      {\n        key: 'minLightness',\n        label: 'Minimum lightness',\n        defaultValue: 0,\n        type: 'range',\n        attr: {\n          min: 0,\n          max: 100,\n          step: 1,\n          snap: '50',\n          thumbcolor: ({ minLightness }) => `hsl(0 0 ${minLightness})`,\n          background: 'linear-gradient(to right, black, white)',\n        },\n        show: ({ multicolorByLightness, isMultiColor }) =>\n          multicolorByLightness && isMultiColor,\n      },\n      {\n        key: 'maxLightness',\n        label: 'Maximum lightness',\n        defaultValue: 100,\n        type: 'range',\n        attr: {\n          min: 0,\n          max: 100,\n          step: 1,\n          snap: '50',\n          thumbcolor: ({ maxLightness }) => `hsl(0 0 ${maxLightness})`,\n          background: 'linear-gradient(to right, black, white)',\n        },\n        show: ({ multicolorByLightness, isMultiColor }) =>\n          multicolorByLightness && isMultiColor,\n      },\n    ],\n  },\n  {\n    key: 'colorOrderGroup',\n    type: 'group',\n    label: 'Order',\n    defaultValue: 'minimized',\n    show: ({ isMultiColor }) => isMultiColor,\n    children: [\n      {\n        key: 'reverseColors',\n        label: 'Reverse colors order',\n        defaultValue: false,\n        type: 'checkbox',\n        show: ({ isMultiColor }) => isMultiColor,\n      },\n      {\n        key: 'repeatColors',\n        label: 'Repeat colors',\n        defaultValue: true,\n        type: 'checkbox',\n        show: ({ isMultiColor }) => isMultiColor,\n      },\n      {\n        key: 'mirrorColors',\n        label: 'Mirror Colors',\n        defaultValue: false,\n        type: 'checkbox',\n        show: ({ isMultiColor, repeatColors }) => isMultiColor && repeatColors,\n      },\n    ],\n  },\n];\n\nexport default COLOR_CONTROLS;\n","import {\n  getConfigDefaultValues,\n  getControlsIndex,\n} from './helpers/config_utils';\nimport Nails from './Nails';\nimport Renderer from './renderers/Renderer';\nimport type {\n  CommonConfig,\n  Config,\n  ControlConfig,\n  ControlsConfig,\n  PrimitiveValue,\n} from './types/config.types';\nimport { Coordinates, Dimensions } from './types/general.types';\n\nconst COLORS = {\n  dark: '#0e0e0e',\n  light: '#ffffff',\n};\n\nexport type Pattern<TConfig = Record<string, PrimitiveValue>> = new (\n  renderer?: Renderer\n) => StringArt<TConfig>;\n\nconst COMMON_CONFIG_CONTROLS: ControlsConfig = [\n  {\n    key: 'strings',\n    label: 'Strings',\n    type: 'group',\n    defaultValue: 'minimized',\n    children: [\n      {\n        key: 'showStrings',\n        label: 'Show strings',\n        defaultValue: true,\n        type: 'checkbox',\n        isDisabled: ({ showNails }) => !showNails,\n      },\n      {\n        key: 'stringWidth',\n        label: 'String width',\n        defaultValue: 1,\n        type: 'range',\n        attr: { min: 0.2, max: 4, step: 0.1, snap: '1' },\n        show: ({ showStrings }) => showStrings,\n      },\n    ],\n  },\n  {\n    key: 'nails',\n    label: 'Nails',\n    type: 'group',\n    defaultValue: 'minimized',\n    children: [\n      {\n        key: 'showNails',\n        label: 'Show nails',\n        defaultValue: true,\n        type: 'checkbox',\n        isDisabled: ({ showStrings }) => !showStrings,\n      },\n      {\n        key: 'showNailNumbers',\n        label: 'Show nail numbers',\n        defaultValue: false,\n        type: 'checkbox',\n        show: ({ showNails }) => showNails,\n      },\n      {\n        key: 'nailNumbersFontSize',\n        label: 'Nail numbers font size',\n        defaultValue: 10,\n        type: 'range',\n        attr: { min: 6, max: 24, step: 0.5 },\n        displayValue: ({ nailNumbersFontSize }) => `${nailNumbersFontSize}px`,\n        show: ({ showNails, showNailNumbers }) => showNails && showNailNumbers,\n      },\n      {\n        key: 'margin',\n        label: 'Margin',\n        defaultValue: 20,\n        type: 'number',\n        attr: { min: 0, max: 500, step: 1 },\n        displayValue: ({ margin }) => `${margin}px`,\n      },\n      {\n        key: 'nailRadius',\n        label: 'Nail size',\n        defaultValue: 1.5,\n        type: 'range',\n        attr: { min: 0.5, max: 5, step: 0.25, snap: '1.5' },\n        show: ({ showNails }) => showNails,\n      },\n      {\n        key: 'nailsColor',\n        label: 'Nails color',\n        defaultValue: '#ffffff',\n        type: 'color',\n        show: ({ showNails }) => showNails,\n      },\n    ],\n  },\n  {\n    key: 'background',\n    label: 'Background',\n    type: 'group',\n    defaultValue: 'minimized',\n    children: [\n      {\n        key: 'darkMode',\n        label: 'Dark mode',\n        defaultValue: true,\n        type: 'checkbox',\n        isDisabled: ({ enableBackground }) => !enableBackground,\n      },\n      {\n        key: 'customBackgroundColor',\n        label: 'Custom background color',\n        defaultValue: false,\n        type: 'checkbox',\n        isDisabled: ({ enableBackground }) => !enableBackground,\n      },\n      {\n        key: 'backgroundColor',\n        label: 'Background color',\n        defaultValue: COLORS.dark,\n        type: 'color',\n        show: ({ customBackgroundColor }) => customBackgroundColor,\n        isDisabled: ({ enableBackground }) => !enableBackground,\n      },\n      {\n        key: 'enableBackground',\n        label: 'Enable background',\n        defaultValue: true,\n        type: 'checkbox',\n      },\n    ],\n  },\n];\n\nabstract class StringArt<TConfig = Record<string, PrimitiveValue>> {\n  renderer: Renderer | null | undefined;\n  controls: ControlsConfig<TConfig> = [];\n  defaultValues: Partial<Config<TConfig>> = {};\n  stepCount: number | null = null;\n  size: Dimensions = null;\n  center: Coordinates = null;\n  nails: Nails = null;\n  position: number = 0;\n  stringsIterator: Iterator<void>;\n\n  id: string;\n  name: string;\n  link: string;\n  linkText: string;\n\n  #config: Config<TConfig>;\n  #controlsIndex: Record<keyof TConfig, ControlConfig<TConfig>>;\n  #defaultConfig: Config<TConfig> | null;\n\n  // TODO: Remove renderer from here, set it only in `draw`. Then StringArt can be instantiated independently of the renderer.\n  constructor(renderer?: Renderer) {\n    this.renderer = renderer;\n  }\n\n  abstract drawNails(): void;\n  abstract generateStrings(): Generator<void>;\n  abstract getStepCount(): number;\n\n  static thumbnailConfig: Partial<Config>;\n  static type: string;\n\n  getCommonControls(): ControlsConfig<Partial<CommonConfig>> {\n    return COMMON_CONFIG_CONTROLS;\n  }\n\n  get configControls(): ControlsConfig<TConfig> {\n    return (this.controls ?? []).concat(this.getCommonControls());\n  }\n\n  get controlsIndex(): Record<keyof TConfig, ControlConfig<TConfig>> {\n    if (!this.#controlsIndex) {\n      this.#controlsIndex = getControlsIndex<TConfig>(this.configControls);\n    }\n\n    return this.#controlsIndex;\n  }\n\n  get type(): string {\n    return (this.constructor as typeof StringArt<any>).type;\n  }\n\n  /**\n   * A pattern is considered a template if the id is the same as the type. These are built-in patterns.\n   */\n  get isTemplate(): boolean {\n    return this.type === this.id;\n  }\n\n  get defaultConfig(): Config<TConfig> {\n    if (!this.#defaultConfig) {\n      this.#defaultConfig = Object.freeze(\n        Object.assign(\n          getConfigDefaultValues(this.configControls),\n          this.defaultValues\n        ) as Config<TConfig>\n      );\n    }\n\n    return this.#defaultConfig;\n  }\n\n  get config(): Config<TConfig> {\n    return this.#config ?? this.defaultConfig;\n  }\n\n  set config(value: Partial<Config<TConfig>>) {\n    this.#config = Object.assign({}, this.defaultConfig, value);\n  }\n\n  /**\n   * Assigns the partial config to the current configuration of the StringArt\n   * @param config\n   */\n  assignConfig(config: Partial<Config<TConfig>>) {\n    this.#config = Object.assign({}, this.config, config);\n  }\n\n  /**\n   * Sets the config of the StringArt and updates using `onConfigChange`\n   * @param config\n   */\n  setConfig(config: Config<TConfig>) {\n    const currentConfig = this.config;\n    this.config = config;\n    if (this.onConfigChange) {\n      const changedControlKeys = Object.keys(currentConfig).filter(\n        key => config[key] !== currentConfig[key]\n      );\n\n      this.onConfigChange(\n        changedControlKeys.map(key => ({\n          control: this.controlsIndex[key],\n          value: config[key],\n        }))\n      );\n    }\n  }\n\n  /**\n   * Child classes can define this method to clear any structural cache when config values for `isStructural=true` controls change.\n   */\n  resetStructure() {}\n\n  onConfigChange(\n    controls: ReadonlyArray<{\n      control: ControlConfig<TConfig>;\n      value: PrimitiveValue | null;\n    }>\n  ) {\n    if (controls.some(({ control }) => control.isStructural)) {\n      this.resetStructure();\n      if (\n        this.stepCount != null &&\n        controls.some(({ control }) => control.affectsStepCount !== false)\n      ) {\n        this.stepCount = null;\n      }\n    }\n  }\n\n  onResize() {\n    this.resetStructure();\n  }\n\n  setConfigValue(controlKey: keyof TConfig, value: PrimitiveValue) {\n    if (this.#config && this.#config[controlKey] === value) {\n      return;\n    }\n\n    this.#config = Object.freeze({\n      ...(this.#config ?? this.defaultConfig),\n      [controlKey]: value,\n    });\n\n    if (this.onConfigChange) {\n      this.onConfigChange(\n        [{ control: this.controlsIndex[controlKey], value }].filter(\n          ({ control }) => !!control\n        )\n      );\n    }\n  }\n\n  getSize(): Dimensions {\n    this.#withRenderer();\n\n    return this.renderer.getSize();\n  }\n\n  setUpDraw() {\n    this.#withRenderer();\n\n    const previousSize = this.size;\n    this.renderer.reset();\n    const [width, height] = (this.size = this.getSize());\n    Object.assign(this, this.size);\n    this.center = this.size.map(value => value / 2) as Coordinates;\n\n    if (\n      previousSize &&\n      (previousSize[0] !== width || previousSize[1] !== height)\n    ) {\n      if (this.onResize) {\n        this.onResize();\n      }\n    }\n\n    if (this.nails) {\n      this.nails.setConfig(this.config);\n    } else {\n      this.nails = new Nails(this.config);\n    }\n\n    this.renderer.setLineWidth(this.config.stringWidth);\n  }\n\n  afterDraw() {\n    this.#withRenderer();\n\n    const { showNails, showNailNumbers } = this.config;\n    if (showNails) {\n      this.drawNails();\n      this.nails.draw(this.renderer, { drawNumbers: showNailNumbers });\n    }\n  }\n\n  initDraw() {\n    this.#withRenderer();\n\n    this.setUpDraw();\n    const {\n      showNails,\n      showNailNumbers,\n      darkMode,\n      backgroundColor,\n      customBackgroundColor,\n      enableBackground,\n    } = this.config;\n\n    if (enableBackground) {\n      this.renderer.setBackground(\n        customBackgroundColor\n          ? backgroundColor\n          : darkMode\n          ? COLORS.dark\n          : COLORS.light\n      );\n    }\n\n    if (showNails) {\n      this.drawNails();\n      this.nails.draw(this.renderer, { drawNumbers: showNailNumbers });\n    }\n  }\n\n  /**\n   * Draws the string art\n   * @param { step: number } renderConfig configuration for rendering. Accepts the step to render (leave undefined or null to render all)\n   */\n  draw({ position = Infinity }: { position?: number } = {}) {\n    this.#withRenderer();\n\n    this.initDraw();\n    const { showStrings } = this.config;\n\n    if (showStrings) {\n      this.stringsIterator = this.generateStrings();\n      this.position = 0;\n\n      while (!this.drawNext().done && this.position < position);\n      this.afterDraw();\n    }\n  }\n\n  goto(position: number) {\n    if (position === this.position) {\n      return;\n    }\n\n    if (this.stringsIterator && position > this.position) {\n      while (!this.drawNext().done && this.position < position);\n    } else {\n      this.draw({ position });\n    }\n  }\n\n  /**\n   *\n   * @returns Advance the strings iterator by one. If the iterator is done, calls this.afterDraw().\n   */\n  drawNext() {\n    const result = this.stringsIterator.next();\n\n    if (result.done) {\n      this.afterDraw();\n    } else {\n      this.position++;\n    }\n\n    return result;\n  }\n\n  #withRenderer(): asserts this is { renderer: Renderer } {\n    if (!this.renderer) {\n      throw new Error('Missing renderer for StringArt!');\n    }\n  }\n}\n\nexport default StringArt;\n","import { ColorValue } from './helpers/color/color.types';\nimport type Renderer from './renderers/Renderer';\nimport { NailsConfig } from './types/config.types';\nimport { Nail, NailsRenderOptions } from './types/stringart.types';\n\ntype NailsGroup = {\n  nails: ReadonlyArray<Nail>;\n  options: Partial<NailsRenderOptions>;\n};\nconst NUMBER_MARGIN = 4;\n\nconst DEFAULT_OPTIONS: NailsRenderOptions = {\n  color: '#ffffff',\n  fontSize: 10,\n  radius: 1.5,\n  renderNumbers: false,\n  margin: NUMBER_MARGIN,\n};\n\nexport default class Nails {\n  nailRadius: number = DEFAULT_OPTIONS.radius;\n  nailsColor: ColorValue = DEFAULT_OPTIONS.color;\n  nailNumbersFontSize: number = DEFAULT_OPTIONS.fontSize;\n  nails: Array<Nail>;\n  addedPoints: Set<string>;\n\n  #nailGroups: NailsGroup[] = [];\n\n  constructor(config: NailsConfig) {\n    this.setConfig(config);\n    this.nails = [];\n    this.addedPoints = new Set();\n  }\n\n  setConfig({ nailRadius, nailsColor, nailNumbersFontSize }: NailsConfig) {\n    this.nailRadius = nailRadius;\n    this.nailsColor = nailsColor;\n    this.nailNumbersFontSize = nailNumbersFontSize;\n    this.nails = [];\n    if (this.addedPoints) {\n      this.addedPoints.clear();\n    }\n  }\n\n  // Adds a nail to be rendered. nail: { point, number }\n  addNail(nail: Nail) {\n    const nailPoint = nail.point.map(Math.round).join('_');\n    if (!this.addedPoints.has(nailPoint)) {\n      this.nails.push(nail);\n      this.addedPoints.add(nailPoint);\n    }\n  }\n\n  addGroup(nails: ReadonlyArray<Nail>, options: Partial<NailsRenderOptions>) {\n    this.#nailGroups.push({ nails, options });\n  }\n\n  #render(\n    renderer: Renderer,\n    nails: ReadonlyArray<Nail>,\n    options: NailsRenderOptions\n  ) {\n    renderer.renderNails(nails, {\n      ...DEFAULT_OPTIONS,\n      ...options,\n    });\n  }\n\n  draw(renderer: Renderer, { drawNumbers = true } = {}) {\n    const options: NailsRenderOptions = {\n      color: this.nailsColor,\n      fontSize: this.nailNumbersFontSize,\n      radius: this.nailRadius,\n      renderNumbers: drawNumbers,\n    };\n\n    this.#render(renderer, this.nails, options);\n\n    this.nails = [];\n    this.addedPoints.clear();\n\n    this.#nailGroups.forEach(({ nails: groupNails, options: groupConfig }) => {\n      this.#render(renderer, groupNails, {\n        ...options,\n        ...groupConfig,\n      });\n    });\n\n    this.#nailGroups = [];\n  }\n}\n","import Nails from '../Nails';\nimport Renderer from '../renderers/Renderer';\nimport { ControlConfig, GroupValue } from '../types/config.types';\nimport { Coordinates, Dimensions } from '../types/general.types';\nimport { Nail } from '../types/stringart.types';\nimport { ColorValue } from './color/color.types';\nimport easing from './easing';\nimport { fitInside, PI2 } from './math_utils';\nimport { compareObjects } from './object_utils';\n\nexport interface CircleConfig {\n  n: number;\n  size: Dimensions;\n  margin?: number;\n  rotation: number;\n  center?: Coordinates;\n  radius?: number;\n  reverse?: boolean;\n  distortion?: number;\n  displacement?: GroupValue;\n  displacementFunc?: keyof typeof easing;\n  displacementMag?: number;\n  displacementFastArea?: number;\n  /**\n   * The angle at which to start rendering the circle (in radians)\n   */\n  angleStart?: number;\n  /**\n   * The angle at which to end rendering the circle (in radians)\n   */\n  angleEnd?: number;\n}\n\nexport interface CircleNailsOptions {\n  nailsNumberStart?: number;\n  getNumber?: (n: number) => number | string;\n  /**\n   * Ranges of nails to exclude from the circle\n   */\n  excludedNailRanges?: ReadonlyArray<[number, number]>;\n}\n\nexport default class Circle {\n  points: Map<number, Coordinates>;\n  easingFunction: Function;\n  config: CircleConfig;\n  center: Coordinates;\n  xyRadius: Dimensions;\n  rotationAngle: number = 0;\n  indexAngle: number;\n  isReverse: boolean = false;\n  radius: number;\n  arc: number = PI2;\n  isPartialArc: boolean = false;\n  excludedNailIndexes: ReadonlySet<number>;\n\n  constructor(config: CircleConfig) {\n    this.setConfig(config);\n  }\n\n  getPoint(index = 0) {\n    const realIndex = this.getNailIndex(index);\n\n    if (this.points.has(index)) {\n      return this.points.get(index);\n    }\n\n    const angle =\n      this.easingFunction(\n        realIndex / (this.config.n - (this.isPartialArc ? 1 : 0))\n      ) *\n        this.arc +\n      this.rotationAngle +\n      (this.config.angleStart ?? 0);\n\n    const point: Coordinates = [\n      this.center[0] + Math.sin(angle) * this.xyRadius[0],\n      this.center[1] + Math.cos(angle) * this.xyRadius[1],\n    ];\n\n    this.points.set(index, point);\n    return point;\n  }\n\n  getNailIndex(index = 0) {\n    let realIndex = this.isReverse ? this.config.n - 1 - index : index;\n    if (realIndex > this.config.n - 1) {\n      realIndex = realIndex % this.config.n;\n    }\n    return realIndex;\n  }\n\n  setConfig(config: CircleConfig) {\n    if (!compareObjects(config, this.config)) {\n      const {\n        n,\n        size,\n        margin = 0,\n        rotation = 0,\n        center: configCenter,\n        radius,\n        reverse = false,\n        angleStart,\n        angleEnd,\n      } = config;\n      const center = configCenter ?? size.map(v => v / 2);\n      const clampedRadius = radius ?? Math.min(...center) - margin;\n      let xyRadius = [clampedRadius, clampedRadius];\n\n      if (config.distortion) {\n        const distortedBox =\n          config.distortion < 0\n            ? [clampedRadius * (1 - Math.abs(config.distortion)), clampedRadius]\n            : [clampedRadius / (1 - config.distortion), clampedRadius];\n\n        xyRadius = fitInside(\n          distortedBox,\n          center.map(v => v - margin)\n        );\n      }\n\n      // Normally, the whole circle is rendered, but if angleStart and angleEnd are configured and valid, and arc between them is rendered:\n      this.isPartialArc = angleStart && angleEnd && angleEnd > angleStart;\n      const arc = this.isPartialArc ? angleEnd - angleStart : PI2;\n\n      const props = {\n        center,\n        radius: clampedRadius,\n        xyRadius,\n        indexAngle: arc / (this.isPartialArc ? n - 1 : n),\n        rotationAngle: -PI2 * rotation,\n        isReverse: reverse,\n        arc,\n      };\n\n      const easingFunction = config.displacementFunc\n        ? easing[config.displacementFunc]\n        : easing.linear;\n      const easingParams = [];\n      if (easingFunction.requirePower) {\n        easingParams.push(config.displacementMag);\n      }\n      if (easingFunction.requireFastArea) {\n        easingParams.push(config.displacementFastArea);\n      }\n      const easingFunctionWithParams = easingParams.length\n        ? easingFunction.bind(null, ...easingParams)\n        : easingFunction;\n\n      this.easingFunction = easingFunctionWithParams;\n      this.config = config;\n      Object.assign(this, props);\n      if (this.points) {\n        this.points.clear();\n      } else {\n        this.points = new Map();\n      }\n    }\n  }\n\n  *generateNails({\n    nailsNumberStart = 0,\n    getNumber,\n    excludedNailRanges,\n  }: CircleNailsOptions = {}): Generator<Nail> {\n    const { n } = this.config;\n\n    let excludedNailIndexes: Set<number>;\n    if (excludedNailRanges) {\n      excludedNailIndexes = new Set<number>();\n      excludedNailRanges.forEach(([start, end]) => {\n        const max = Math.min(end, n);\n        for (let i = Math.max(0, start); i <= max; i++) {\n          excludedNailIndexes.add(i);\n        }\n      });\n    }\n\n    let i = 0;\n    let j = 0;\n\n    while (j < this.config.n) {\n      if (!excludedNailIndexes?.has(j)) {\n        yield {\n          point: this.getPoint(j),\n          number: getNumber ? getNumber(i) : i + nailsNumberStart,\n        };\n\n        i++;\n      }\n      j++;\n    }\n  }\n\n  /**\n   * Given a Nails instance, uses it to draw the nails of this Circle\n   * @param {Nails} nails\n   * @param {{nailsNumberStart?: number, getNumber?: Function}} param1\n   */\n  drawNails(\n    nails: Nails,\n    props: CircleNailsOptions & {\n      color?: ColorValue;\n    } = {}\n  ) {\n    const arr = [];\n    const { color, ...restProps } = props;\n\n    for (const nail of this.generateNails(restProps)) {\n      arr.push(nail);\n    }\n    nails.addGroup(arr, { color });\n  }\n\n  *drawRing(\n    renderer: Renderer,\n    { ringSize, color }: { ringSize: number; color: ColorValue }\n  ): Generator<void> {\n    const { n } = this.config;\n    const ringDistance = Math.floor(ringSize * n);\n\n    let prevPoint: Coordinates;\n    let prevPointIndex = 0;\n    let isPrevSide = false;\n    renderer.setColor(color);\n\n    for (let i = 0; i < n; i++) {\n      if (!prevPoint) {\n        prevPoint = this.getPoint(0);\n      }\n\n      const startPoint = prevPoint;\n      const positions: Array<Coordinates> = [];\n      prevPointIndex = isPrevSide ? i : prevPointIndex + ringDistance;\n      prevPoint = this.getPoint(prevPointIndex);\n      positions.push(prevPoint);\n\n      if (i < n - 1) {\n        prevPointIndex++;\n        prevPoint = this.getPoint(prevPointIndex);\n        positions.push(prevPoint);\n      }\n\n      renderer.renderLines(startPoint, ...positions);\n      yield;\n\n      isPrevSide = !isPrevSide;\n    }\n  }\n\n  static rotationConfig: ControlConfig<{ rotation: number }> = {\n    key: 'rotation',\n    label: 'Rotation',\n    defaultValue: 0,\n    type: 'range',\n    attr: {\n      min: 0,\n      max: 1 + 1 / 360,\n      step: 1 / 360,\n      snap: '0.25, 0.5, 0.75',\n    },\n    displayValue: ({ rotation }) => `${Math.round(rotation * 360)}`,\n    isStructural: true,\n    affectsStepCount: false,\n  };\n\n  static nailsConfig = Object.freeze({\n    key: 'n',\n    label: 'Number of nails',\n    defaultValue: 144,\n    type: 'range',\n    attr: {\n      min: 3,\n      max: 300,\n      step: 1,\n    },\n    isStructural: true,\n  });\n\n  static displacementConfig: ControlConfig<CircleConfig> = {\n    key: 'displacement',\n    label: 'Displacement',\n    type: 'group',\n    children: [\n      {\n        key: 'displacementFunc',\n        label: 'Displacement function',\n        defaultValue: 'linear',\n        type: 'select',\n        options: Object.keys(easing),\n        isStructural: true,\n        affectsStepCount: false,\n      },\n      {\n        key: 'displacementMag',\n        label: 'Displacement magnitude',\n        defaultValue: 3,\n        type: 'range',\n        attr: {\n          min: 0,\n          max: 10,\n          step: 0.1,\n        },\n        show: ({ displacementFunc }) => easing[displacementFunc].requirePower,\n        isStructural: true,\n        affectsStepCount: false,\n      },\n      {\n        key: 'displacementFastArea',\n        label: 'Displacement fast area',\n        defaultValue: 0.4,\n        type: 'range',\n        attr: {\n          min: 0,\n          max: 0.5,\n          step: 0.01,\n        },\n        show: ({ displacementFunc }) =>\n          easing[displacementFunc].requireFastArea,\n        isStructural: true,\n        affectsStepCount: false,\n      },\n    ],\n  };\n\n  static distortionConfig: ControlConfig<{ distortion?: number }> = {\n    key: 'distortion',\n    label: 'Distortion',\n    defaultValue: 0,\n    type: 'range',\n    attr: {\n      min: -0.99,\n      max: 0.99,\n      step: 0.01,\n      snap: '0',\n    },\n    isStructural: true,\n    affectsStepCount: false,\n  };\n}\n","const easing = {\n  linear: x => x,\n  inOutCirc(x: number): number {\n    return x < 0.5\n      ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2\n      : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2;\n  },\n  easeOutQuint(x: number): number {\n    return 1 - Math.pow(1 - x, 5);\n  },\n  fastSlowFast(t: number): number {\n    // Clamp t to [0,1] just to be safe\n    t = Math.max(0, Math.min(1, t));\n    // Custom easing formula: accelerates, slows in middle, then accelerates again\n    return 0.5 * (1 - Math.cos(Math.PI * t)) ** 1.5;\n  },\n  fastInOutSquare(x: number): number {\n    return x <= 0.5\n      ? (1 - Math.pow(1 - x * 2, 2)) / 2\n      : 0.5 + Math.pow(x * 2 - 1, 2) / 2;\n  },\n  fastInOutCubic(x: number): number {\n    return x <= 0.5\n      ? (1 - Math.pow(1 - x * 2, 3)) / 2\n      : 0.5 + Math.pow(x * 2 - 1, 3) / 2;\n  },\n  fastInOutQuint(x: number): number {\n    return x <= 0.5\n      ? (1 - Math.pow(1 - x * 2, 5)) / 2\n      : 0.5 + Math.pow(x * 2 - 1, 5) / 2;\n  },\n  fastInOut(pow: number, x: number): number {\n    return x <= 0.5\n      ? (1 - Math.pow(1 - x * 2, pow)) / 2\n      : 0.5 + Math.pow(x * 2 - 1, pow) / 2;\n  },\n  fastInOutFixed(pow: number, fastArea: number, x: number): number {\n    if (x > fastArea && x < 1 - fastArea) {\n      const y1 = (1 - Math.pow(1 - fastArea * 2, pow)) / 2;\n      const y2 = 0.5 + Math.pow((1 - fastArea) * 2 - 1, pow) / 2;\n\n      return y1 + ((x - fastArea) * (y2 - y1)) / (1 - 2 * fastArea);\n    }\n    return x <= fastArea\n      ? (1 - Math.pow(1 - x * 2, pow)) / 2\n      : 0.5 + Math.pow(x * 2 - 1, pow) / 2;\n  },\n};\n\neasing.fastInOut.requirePower = true;\neasing.fastInOutFixed.requirePower = true;\neasing.fastInOutFixed.requireFastArea = true;\n\nexport default easing;\n","/**\n * Returns the greatest common divisor of two integers\n * https://en.wikipedia.org/wiki/Euclidean_algorithm\n * @param {number} int1\n * @param {number} int2\n * @returns number\n */\nexport function gcd(int1, int2) {\n  if (!int2) return int1;\n\n  return gcd(int2, int1 % int2);\n}\n\n/**\n * Fits the first size inside size2\n * @param {[number, number]} size1\n * @param {[number, number]} size2\n */\nexport function fitInside(size1, size2) {\n  const ratio = Math.min(size2[0] / size1[0], size2[1] / size1[1]);\n  return size1.map(v => v * ratio);\n}\n\nexport const PI2 = Math.PI * 2;\n","/**\n * Returns true if the two objects have the same values. Deep compares the objects.\n */\nexport function compareObjects(\n  obj1: Object,\n  obj2: Object,\n  /**\n   * An array of keys to compare. If not specified, all keys are compared.\n   */\n  props?: ReadonlyArray<string>\n): boolean {\n  if (obj1 === obj2) {\n    return true;\n  }\n\n  if (typeof obj1 === 'object' && typeof obj2 === 'object') {\n    if ((obj1 === null) !== (obj2 === null)) {\n      return false;\n    }\n\n    if (obj1 instanceof Array && obj2 instanceof Array) {\n      if (obj1.length !== obj2.length) {\n        return false;\n      }\n\n      for (let i = 0; i < obj1.length; i++) {\n        if (!compareObjects(obj1[i], obj2[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    if (!props) {\n      props = Object.keys(obj1);\n      if (props.length !== Object.keys(obj2).length) {\n        return false;\n      }\n    }\n\n    if (props && props.some(p => !compareObjects(obj1[p], obj2[p]))) {\n      return false;\n    }\n\n    return true;\n  }\n\n  return obj1 === obj2;\n}\n\n/**\n * Maps the keys of an object. The mapped accepts the original key and the value of that property\n * @returns\n */\nexport function mapKeys<T extends Record<string, any>, K extends string>(\n  obj: T,\n  mapper: (key: keyof T, value: T[keyof T]) => K\n): Record<K, T[keyof T]> {\n  const mappedObj = {} as Record<K, any>;\n  Object.entries(obj).forEach(\n    ([key, value]) => (mappedObj[mapper(key, value)] = value)\n  );\n  return mappedObj;\n}\n","import StringArt from '../StringArt';\nimport Circle from '../helpers/Circle';\nimport Color from '../helpers/color/Color';\nimport { ColorConfig, ColorMap } from '../helpers/color/color.types';\nimport { PI2 } from '../helpers/math_utils';\nimport { ControlsConfig } from '../types/config.types.js';\nimport { Coordinates } from '../types/general.types';\n\ninterface SpiralsConfig extends ColorConfig {\n  radiusIncrease: number;\n  angleStep: number;\n  nSpirals: number;\n  rotation: number;\n}\n\ninterface TCalc {\n  spiralRotations: number[];\n  rotationAngle: number;\n  nailsPerSpiral: number;\n  angleIncrease: number;\n}\n\nclass Spirals extends StringArt<SpiralsConfig> {\n  static type = 'spirals';\n\n  name = 'Spirals';\n  id = 'spirals';\n  link =\n    'https://www.etsy.com/il-en/listing/974865185/3d-string-art-spiral-mandala-wall?ref=shop_home_active_10&frs=1';\n  controls: ControlsConfig<SpiralsConfig> = [\n    {\n      key: 'radiusIncrease',\n      label: 'Radius change',\n      defaultValue: 5.7,\n      type: 'range',\n      attr: { min: 1, max: 20, step: 0.1 },\n    },\n    {\n      key: 'angleStep',\n      label: 'Angle step',\n      defaultValue: 0.45,\n      type: 'range',\n      attr: { min: 0, max: 1, step: 0.01 },\n    },\n    {\n      key: 'nSpirals',\n      label: 'Number of spirals',\n      defaultValue: 3,\n      type: 'range',\n      attr: { min: 1, max: 20, step: 1 },\n    },\n    {\n      ...Circle.rotationConfig,\n      defaultValue: 330 / 360,\n    },\n    Color.getConfig({\n      defaults: {\n        isMultiColor: true,\n        colorCount: 4,\n        color: '#00d5ff',\n        multicolorRange: 1,\n        multicolorStart: 190,\n        multicolorByLightness: true,\n        minLightness: 50,\n        maxLightness: 88,\n        reverseColors: true,\n      },\n    }),\n  ];\n\n  calc: TCalc;\n  color: Color;\n  colorMap: ColorMap;\n\n  getCalc(): TCalc {\n    const { nSpirals, rotation, margin, radiusIncrease, angleStep } =\n      this.config;\n    const maxRadius = Math.min(...this.size) / 2 - margin;\n\n    return {\n      spiralRotations: new Array(nSpirals)\n        .fill(null)\n        .map((_, i) => (i * PI2) / nSpirals),\n      rotationAngle: -PI2 * rotation,\n      nailsPerSpiral: Math.floor(maxRadius / radiusIncrease),\n      angleIncrease: angleStep / (maxRadius / 50),\n    };\n  }\n\n  setUpDraw() {\n    super.setUpDraw();\n\n    const { colorCount } = this.config;\n\n    this.calc = this.getCalc();\n    this.color = new Color(this.config);\n    this.colorMap = this.color.getColorMap({\n      stepCount: this.getStepCount(),\n      colorCount,\n    });\n  }\n\n  *generatePoints() {\n    const { nSpirals } = this.config;\n\n    for (let i = 0; i < this.calc.nailsPerSpiral; i++) {\n      for (let s = 0; s < nSpirals; s++) {\n        const point = this.getPoint(s, i);\n        yield { point, nailNumber: `${s}_${i}` };\n      }\n    }\n  }\n\n  getPoint(spiralIndex: number, index: number): Coordinates {\n    const [centerx, centery] = this.center;\n    const { radiusIncrease } = this.config;\n\n    const angle =\n      this.calc.rotationAngle +\n      this.calc.angleIncrease * index +\n      this.calc.spiralRotations[spiralIndex];\n    const radius = index * radiusIncrease;\n\n    return [\n      centerx + radius * Math.sin(angle),\n      centery + radius * Math.cos(angle),\n    ];\n  }\n\n  *generateStrings(): Generator<void> {\n    const points = this.generatePoints();\n    let index = 0;\n    this.renderer.setColor(this.color.getColor(0));\n    let lastPoint = this.center;\n\n    for (const { point } of points) {\n      if (this.colorMap) {\n        const stepColor = this.colorMap.get(index);\n        if (stepColor) {\n          this.renderer.setColor(stepColor);\n        }\n      }\n\n      if (lastPoint) {\n        this.renderer.renderLines(lastPoint, point);\n      }\n      lastPoint = point;\n      index++;\n      yield;\n    }\n  }\n\n  getStepCount(): number {\n    const { nSpirals, radiusIncrease, margin } = this.config;\n    const maxRadius = Math.min(...this.getSize()) / 2 - margin;\n    const n = Math.floor(maxRadius / radiusIncrease);\n    return n * nSpirals;\n  }\n\n  drawNails() {\n    const points = this.generatePoints();\n    for (const { point, nailNumber } of points) {\n      this.nails.addNail({ point, number: nailNumber });\n    }\n  }\n\n  static thumbnailConfig = {\n    radiusIncrease: 1.4,\n    angleStep: 0.11,\n  };\n}\n\nexport default Spirals;\n","import Color from '../helpers/color/Color';\nimport Circle from '../helpers/Circle';\nimport Mandala, { MandalaConfig } from './Mandala';\nimport { ControlsConfig } from '../types/config.types';\nimport { formatFractionAsPercent } from '../helpers/string_utils';\n\nexport interface WaveConfig {\n  layerSpread: number;\n}\n\nexport default class Wave extends Mandala<WaveConfig> {\n  static type = 'wave';\n\n  id = 'wave';\n  name = 'Wave';\n  link =\n    'https://www.etsy.com/il-en/listing/943140543/personalized-gift-string-art-mandala?ref=sim_rv-5&pro=1';\n  controls: ControlsConfig<MandalaConfig & WaveConfig> = [\n    {\n      ...Circle.nailsConfig,\n      defaultValue: 200,\n    },\n    {\n      key: 'layerFill',\n      label: 'Layer fill',\n      defaultValue: 0.5,\n      type: 'range',\n      attr: {\n        min: ({ n }) => 1 / n,\n        max: 1,\n        step: ({ n }) => 1 / n,\n      },\n      displayValue: ({ layerFill }) => formatFractionAsPercent(layerFill),\n    },\n    {\n      ...Circle.rotationConfig,\n      defaultValue: 176 / 360,\n    },\n    Circle.distortionConfig,\n    {\n      key: 'layers',\n      label: 'Layers',\n      defaultValue: 11,\n      type: 'range',\n      attr: { min: 1, max: 20, step: 1 },\n    },\n    {\n      key: 'layerSpread',\n      label: 'Layer spread',\n      defaultValue: 15 / 200,\n      type: 'range',\n      attr: {\n        min: 0,\n        max: 1,\n        step: ({ n }) => 1 / n,\n      },\n      displayValue: ({ layerSpread, n }) => Math.round(layerSpread * n),\n    },\n    {\n      key: 'reverse',\n      label: 'Reverse',\n      defaultValue: true,\n      type: 'checkbox',\n    },\n    Color.getConfig({\n      defaults: {\n        isMultiColor: true,\n        multicolorRange: 196,\n        multicolorStart: 273,\n        color: '#ffffff',\n        multicolorByLightness: true,\n        minLightness: 10,\n        maxLightness: 90,\n      },\n      exclude: ['colorCount'],\n    }),\n  ];\n\n  defaultValues = {\n    base: 2,\n  };\n\n  setUpDraw() {\n    super.setUpDraw();\n    const { n, layerSpread } = this.config;\n    this.calc.layerShift = Math.round(n * layerSpread);\n  }\n\n  *generateStrings() {\n    const { layers } = this.config;\n\n    for (let layer = 0; layer < layers; layer++) {\n      yield* this.drawTimesTable(layer);\n    }\n  }\n\n  static thumbnailConfig = {\n    n: 70,\n  };\n}\n","import Color from '../helpers/color/Color';\nimport StringArt from '../StringArt';\nimport Circle, { CircleConfig } from '../helpers/Circle';\nimport { ColorConfig } from '../helpers/color/color.types';\nimport { ControlsConfig, PrimitiveValue } from '../types/config.types.js';\n\nexport interface MandalaConfig extends ColorConfig {\n  n: number;\n  base: number;\n  layers: number;\n  rotation: number;\n  distortion: number;\n  layerFill?: number;\n  reverse?: boolean;\n}\n\ninterface TCalc {\n  n: number;\n  stringsPerLayer: number;\n  layerShift: number;\n}\n\nexport default class Mandala<TCustomConfig = void> extends StringArt<\n  MandalaConfig & TCustomConfig\n> {\n  static type = 'mandala';\n\n  name = 'Mandala';\n  id = 'mandala';\n  link = 'https://www.youtube.com/watch?v=qhbuKbxJsk8';\n  linkText = 'Learn';\n  controls: ControlsConfig<MandalaConfig & TCustomConfig> = [\n    {\n      key: 'n',\n      label: 'Number of nails',\n      defaultValue: 180,\n      type: 'range',\n      attr: { min: 3, max: 240, step: 1 },\n    },\n    {\n      key: 'base',\n      label: 'Multiplication',\n      defaultValue: 2,\n      type: 'range',\n      attr: { min: 2, max: 99, step: 1 },\n    },\n    {\n      key: 'layers',\n      label: 'Layers',\n      defaultValue: 7,\n      type: 'range',\n      attr: { min: 1, max: 20, step: 1 },\n    },\n    Circle.rotationConfig,\n    Circle.distortionConfig,\n    Color.getConfig({\n      defaults: {\n        isMultiColor: true,\n        multicolorRange: 165,\n        multicolorStart: 256,\n        color: '#ff4d00',\n      },\n      exclude: ['colorCount'],\n    }),\n  ];\n\n  circle: Circle;\n  color: Color;\n  calc: TCalc;\n\n  get n() {\n    return this.calc.n;\n  }\n\n  getCalc(): TCalc {\n    const { n: nConfig, layers, layerFill } = this.config;\n    const extraNails = nConfig % layers;\n    const n = nConfig - extraNails; // The number of nails should be a multiple of the layers, so the strings are exactly on the nails.\n\n    return {\n      n,\n      stringsPerLayer: layerFill ? Math.floor(n * layerFill) : n,\n      layerShift: Math.floor(n / layers),\n    };\n  }\n\n  setUpDraw() {\n    super.setUpDraw();\n\n    const { layers, rotation, distortion, margin, layerFill, base, reverse } =\n      this.config;\n    this.calc = this.getCalc();\n\n    const circleConfig: CircleConfig = {\n      size: this.size,\n      n: this.n,\n      margin,\n      rotation,\n      distortion,\n      reverse,\n    };\n\n    if (this.circle) {\n      this.circle.setConfig(circleConfig);\n    } else {\n      this.circle = new Circle(circleConfig);\n    }\n\n    this.color = new Color({\n      ...this.config,\n      colorCount: layers,\n    });\n  }\n\n  *drawTimesTable(layerIndex: number): Generator<void> {\n    const { reverse, base } = this.config;\n    const { n, layerShift, stringsPerLayer } = this.calc;\n\n    const shift = layerShift * layerIndex * (reverse ? 1 : -1);\n    const color = this.color.getColor(layerIndex);\n    this.renderer.setColor(color);\n\n    let point = this.circle.getPoint(shift);\n\n    for (let i = 1; i <= stringsPerLayer; i++) {\n      const startPoint = point;\n      point = this.circle.getPoint(i + shift);\n      const toIndex = (i * base) % n;\n      this.renderer.renderLines(\n        startPoint,\n        point,\n        this.circle.getPoint(toIndex + shift)\n      );\n\n      yield;\n    }\n  }\n\n  *generateStrings(): Generator<void> {\n    const { layers } = this.config;\n\n    for (let layer = 0; layer < layers; layer++) {\n      yield* this.drawTimesTable(layer);\n    }\n  }\n\n  drawNails() {\n    this.circle.drawNails(this.nails);\n  }\n\n  getStepCount(): number {\n    const { layers, layerFill } = this.config;\n    const { n } = this.getCalc();\n    const stringsPerLayer = layerFill ? Math.floor(n * layerFill) : n;\n    return (layers ?? 1) * stringsPerLayer;\n  }\n\n  static thumbnailConfig = {\n    n: 70,\n  };\n}\n","export function formatFractionAsPercent(value: number): string {\n  return `${Math.round(value * 100)}%`;\n}\n","import Color from '../helpers/color/Color.js';\nimport { ColorConfig, ColorValue } from '../helpers/color/color.types';\nimport StringArt from '../StringArt';\nimport { Config, ControlsConfig, GroupValue } from '../types/config.types';\nimport { Coordinates } from '../types/general.types';\n\ntype Side = 'left' | 'bottom' | 'right' | 'top';\nconst SIDES: [Side, Side, Side, Side] = ['left', 'bottom', 'right', 'top'];\nconst SIDES_ORDER: [Side, Side, Side, Side] = [\n  'left',\n  'bottom',\n  'right',\n  'top',\n];\n\nconst SIDES_ROTATION = {\n  left: 0,\n  bottom: Math.PI / 2,\n  right: Math.PI,\n  top: Math.PI * 1.5,\n};\n\ninterface EyeConfig extends ColorConfig {\n  n: number;\n  layers: number;\n  angle: number;\n  colorPerLayer: boolean;\n}\n\ninterface Layer {\n  layerAngle: number;\n  layerSize: number;\n  layerStart: Coordinates;\n  layerStringCount: number;\n}\ninterface TCalc {\n  maxSize: number;\n  nailSpacing: number;\n  layerAngle: number;\n  layers: ReadonlyArray<Layer>;\n}\n\nclass Eye extends StringArt<EyeConfig> {\n  static type = 'eye';\n\n  name = 'Eye';\n  id = 'eye';\n  link =\n    'https://www.etsy.com/listing/489853161/rose-of-space-string-art-sacred-geometry?ga_order=most_relevant&ga_search_type=all&ga_view_type=gallery&ga_search_query=string+art&ref=sr_gallery_1&epik=dj0yJnU9WXNpM1BDTnNkLVBtcWdCa3AxN1J5QUZRY1FlbkJ5Z18mcD0wJm49ZXdJb2JXZmVpNVVwN1NKQ3lXMy10ZyZ0PUFBQUFBR0ZuUzZv';\n  controls: ControlsConfig<EyeConfig> = [\n    {\n      key: 'n',\n      label: 'Number of nails per side',\n      defaultValue: 82,\n      type: 'range',\n      attr: { min: 2, max: 200, step: 1 },\n    },\n    {\n      key: 'layers',\n      label: 'Layers',\n      defaultValue: 13,\n      type: 'range',\n      attr: { min: 1, max: 20, step: 1 },\n    },\n    {\n      key: 'angle',\n      label: 'Layer angle',\n      defaultValue: 30,\n      displayValue: ({ angle }) => `${angle}`,\n      type: 'range',\n      attr: { min: 0, max: 45, step: 1 },\n    },\n    Color.getConfig({\n      defaults: {\n        isMultiColor: true,\n        color: '#ffffff',\n        multicolorRange: 107,\n        multicolorStart: 226,\n        multicolorByLightness: false,\n        minLightness: 40,\n        maxLightness: 50,\n        colorCount: 2,\n      },\n      customControls: [\n        {\n          key: 'colorPerLayer',\n          label: 'Color per layer',\n          defaultValue: false,\n          type: 'checkbox',\n          show: ({ isMultiColor }) => isMultiColor,\n        },\n      ],\n      exclude: ['colorCount', 'repeatColors'],\n    }),\n  ];\n\n  defaultValues: Partial<Config<EyeConfig>> = {\n    nailsColor: '#000000',\n  };\n\n  #calc: TCalc;\n  color: Color;\n\n  getCalc(): TCalc {\n    const { n, angle, layers, margin } = this.config;\n\n    const maxSize = Math.min(...this.size) - 2 * margin;\n    const nailSpacing = maxSize / (n - 1);\n    const layerAngle = (angle * Math.PI) / 180;\n\n    const getLayerProps = (layerIndex: number): Layer => {\n      const layerSize =\n        maxSize /\n        Math.pow(Math.cos(layerAngle) + Math.sin(layerAngle), layerIndex);\n      const layerStart: Coordinates = [\n        this.center[0] - layerSize / 2,\n        this.center[1] - layerSize / 2,\n      ];\n      const layerStringCount = Math.floor(layerSize / nailSpacing);\n\n      return {\n        layerAngle: layerAngle * layerIndex,\n        layerSize,\n        layerStart,\n        layerStringCount,\n      };\n    };\n\n    return {\n      maxSize,\n      nailSpacing,\n      layerAngle,\n      layers: new Array(layers)\n        .fill(null)\n        .map((_, layerIndex) => getLayerProps(layerIndex)),\n    };\n  }\n\n  setUpDraw() {\n    super.setUpDraw();\n    this.color = new Color({\n      ...this.config,\n      repeatColors: true,\n      colorCount: 2,\n    });\n    this.#calc = this.getCalc();\n  }\n\n  // Sides: top, right, bottom, left\n  getPoint({\n    index,\n    angle,\n    layerStart,\n    rotation,\n  }: {\n    index: number;\n    angle: number;\n    layerStart: Coordinates;\n    rotation: number;\n  }): Coordinates {\n    const theta = angle + rotation;\n\n    const point: Coordinates = [\n      layerStart[0],\n      layerStart[1] + this.#calc.nailSpacing * index,\n    ];\n\n    const pivot = this.center;\n\n    const cosAngle = Math.cos(theta);\n    const sinAngle = Math.sin(theta);\n\n    return [\n      cosAngle * (point[0] - pivot[0]) -\n        sinAngle * (point[1] - pivot[1]) +\n        pivot[0],\n      sinAngle * (point[0] - pivot[0]) +\n        cosAngle * (point[1] - pivot[1]) +\n        pivot[1],\n    ];\n  }\n\n  *drawSide({\n    side,\n    color = '#ffffff',\n    angle,\n    size,\n    layerStart,\n    layerStringCount,\n  }: {\n    side: Side;\n    color: ColorValue;\n    angle: number;\n    size: number;\n    layerStart: Coordinates;\n    layerStringCount: number;\n  }): Generator<void> {\n    const sideIndex = SIDES.indexOf(side);\n    const nextSide = SIDES[sideIndex === SIDES.length - 1 ? 0 : sideIndex + 1];\n    const rotation = SIDES_ROTATION[side];\n    const nextSideRotation = SIDES_ROTATION[nextSide];\n\n    const sideProps = { layerStringCount, size, layerStart, angle };\n    this.renderer.setColor(color);\n\n    for (let i = 0; i <= layerStringCount; i++) {\n      this.renderer.renderLines(\n        this.getPoint({ index: i, rotation, ...sideProps }),\n        this.getPoint({\n          index: i,\n          rotation: nextSideRotation,\n          ...sideProps,\n        })\n      );\n\n      yield;\n    }\n  }\n\n  *drawLayer(layerIndex: number): Generator<void> {\n    const { colorPerLayer } = this.config;\n\n    const { layerAngle, layerSize, layerStart, layerStringCount } =\n      this.#calc.layers[layerIndex];\n\n    for (let i = 0; i < SIDES.length; i++) {\n      yield* this.drawSide({\n        color: this.color.getColor(colorPerLayer ? layerIndex : i),\n        side: SIDES_ORDER[i],\n        angle: layerAngle,\n        size: layerSize,\n        layerStart,\n        layerStringCount,\n      });\n    }\n  }\n\n  *generateStrings() {\n    const { layers } = this.config;\n    for (let layer = layers - 1; layer >= 0; layer--) {\n      yield* this.drawLayer(layer);\n    }\n  }\n\n  getStepCount() {\n    let count = 0;\n    const { layers, angle, n, margin } = this.config;\n    const layerAngle = (angle * Math.PI) / 180;\n    const maxSize = Math.min(...this.renderer.getSize()) - 2 * margin;\n    const nailSpacing = maxSize / (n - 1);\n\n    for (let layer = 0; layer < layers; layer++) {\n      const layerSize =\n        maxSize / Math.pow(Math.cos(layerAngle) + Math.sin(layerAngle), layer);\n      count += 4 * (Math.floor(layerSize / nailSpacing) + 1);\n    }\n\n    return count;\n  }\n\n  drawNails() {\n    const { layers } = this.config;\n    for (let layer = layers - 1; layer >= 0; layer--) {\n      const {\n        layerAngle: angle,\n        layerSize: size,\n        layerStart,\n        layerStringCount,\n      } = this.#calc.layers[layer];\n\n      for (let s = 0; s < SIDES.length; s++) {\n        const sideOrder = SIDES_ORDER[s];\n        const rotation = SIDES_ROTATION[sideOrder];\n\n        for (let i = 0; i <= layerStringCount; i++) {\n          const sideProps = { layerStringCount, size, layerStart, angle };\n          this.nails.addNail({\n            point: this.getPoint({\n              index: i,\n              rotation,\n              ...sideProps,\n            }),\n            number: `${layer}_${s}_${i}`,\n          });\n        }\n      }\n    }\n  }\n\n  static thumbnailConfig = {\n    n: 25,\n    layers: 7,\n  };\n}\n\nexport default Eye;\n","import StringArt from '../StringArt.js';\nimport Circle, { CircleConfig } from '../helpers/Circle.js';\nimport StarShape, { StarShapeConfig } from '../helpers/StarShape.js';\nimport { ColorValue } from '../helpers/color/color.types.js';\nimport { withoutAttribute } from '../helpers/config_utils.js';\nimport { ControlsConfig, GroupValue } from '../types/config.types.js';\nimport { Coordinates } from '../types/general.types.js';\n\ninterface StarConfig {\n  sides: number;\n  sideNails: number;\n  centerRadius: number;\n  ringSize: number;\n  rotation: number;\n  distortion: number;\n  innerColor: ColorValue;\n  outerColor: ColorValue;\n  ringColor: ColorValue;\n  colorGroup: GroupValue;\n}\n\nexport default class Star extends StringArt<StarConfig> {\n  static type = 'star';\n\n  name = 'Star';\n  id = 'star';\n  link =\n    'https://www.etsy.com/listing/557818258/string-art-meditation-geometric-yoga?epik=dj0yJnU9Mm1hYmZKdks1eTc3bVY2TkVhS2p2Qlg0N2dyVWJxaTEmcD0wJm49MGlWSXE1SVJ2Vm0xZ0xtaGhITDBWQSZ0PUFBQUFBR0Zwd2lj';\n  controls: ControlsConfig<StarConfig> = [\n    {\n      key: 'sides',\n      label: 'Sides',\n      defaultValue: 3,\n      type: 'range',\n      attr: { min: 3, max: 20, step: 1 },\n    },\n    {\n      key: 'sideNails',\n      label: 'Nails per side',\n      defaultValue: 40,\n      type: 'range',\n      attr: { min: 1, max: 200, step: 1 },\n    },\n    StarShape.centerRadiusConfig,\n    {\n      key: 'ringSize',\n      label: 'Outer ring size',\n      defaultValue: 0.1,\n      type: 'range',\n      attr: {\n        min: 0,\n        max: 0.5,\n        step: ({ sideNails, sides }) => 1 / (sideNails * sides),\n      },\n      displayValue: ({ sideNails, sides, ringSize }) =>\n        Math.floor(ringSize * sideNails * sides),\n    },\n    withoutAttribute<StarConfig>(Circle.rotationConfig, 'snap'),\n    Circle.distortionConfig,\n    {\n      key: 'colorGroup',\n      label: 'Color',\n      type: 'group',\n      children: [\n        {\n          key: 'innerColor',\n          label: 'Star color',\n          defaultValue: '#2ec0ff',\n          type: 'color',\n        },\n        {\n          key: 'outerColor',\n          label: 'Outter color',\n          defaultValue: '#2a82c6',\n          type: 'color',\n        },\n        {\n          key: 'ringColor',\n          label: 'Ring color',\n          defaultValue: '#2ec0ff',\n          type: 'color',\n        },\n      ],\n    },\n  ];\n\n  #star: StarShape = null;\n  #circle: Circle;\n\n  setUpDraw() {\n    super.setUpDraw();\n\n    const { sides, rotation, distortion, sideNails, margin = 0 } = this.config;\n    const circleConfig: CircleConfig = {\n      size: this.size,\n      n: sideNails * sides,\n      margin,\n      rotation: rotation ? rotation / sides : 0,\n      distortion,\n    };\n\n    if (this.#circle) {\n      this.#circle.setConfig(circleConfig);\n    } else {\n      this.#circle = new Circle(circleConfig);\n    }\n\n    const starConfig: StarShapeConfig = {\n      ...this.config,\n      radius: this.#circle.radius,\n      size: this.size,\n    };\n\n    if (this.#star) {\n      this.#star.setConfig(starConfig);\n    } else {\n      this.#star = new StarShape(starConfig);\n    }\n  }\n\n  getArcPoint({\n    side,\n    sideIndex,\n  }: {\n    side: number;\n    sideIndex: number;\n  }): Coordinates {\n    return this.#circle.getPoint(side * this.config.sideNails + sideIndex);\n  }\n\n  *drawStar(): Generator<void> {\n    const { innerColor } = this.config;\n\n    this.renderer.setColor(innerColor);\n    yield* this.#star.generateStrings(this.renderer);\n  }\n\n  *drawCircle(): Generator<void> {\n    const { outerColor, sides, sideNails } = this.config;\n    this.renderer.setColor(outerColor);\n\n    let prevPoint = this.#star.getPoint(0, 0);\n    let alternate = false;\n    let isStar = false;\n\n    const rounds = sides % 2 ? Math.ceil(sideNails / 2) : sideNails;\n    let side = 0;\n    const linesPerRound = sides % 2 ? sides * 4 : sides * 2;\n\n    for (let round = 0; round <= rounds; round++) {\n      const linesPerThisRound =\n        linesPerRound - (round === rounds ? sides * 2 : 0);\n\n      for (let i = 0; i < linesPerThisRound; i++) {\n        const pointPosition = {\n          side,\n          sideIndex: alternate ? sideNails - round - 1 : round,\n        };\n\n        const nextPoint = isStar\n          ? this.#star.getPoint(pointPosition.side, pointPosition.sideIndex)\n          : this.getArcPoint(pointPosition);\n\n        this.renderer.renderLines(prevPoint, nextPoint);\n        prevPoint = nextPoint;\n\n        yield;\n        isStar = !isStar;\n\n        if (isStar) {\n          side = side !== sides - 1 ? side + 1 : 0;\n          alternate = !alternate;\n        }\n      }\n      prevPoint = this.#star.getPoint(0, round + 1);\n    }\n  }\n\n  *generateStrings(): Generator<void> {\n    yield* this.drawCircle();\n\n    const { ringSize, ringColor } = this.config;\n\n    if (ringSize !== 0) {\n      yield* this.#circle.drawRing(this.renderer, {\n        ringSize,\n        color: ringColor,\n      });\n    }\n    yield* this.drawStar();\n  }\n\n  drawNails(): void {\n    this.#circle.drawNails(this.nails);\n    this.#star.drawNails(this.nails);\n    this.#circle.drawNails(this.nails);\n  }\n\n  #getCircleStepCount(): number {\n    const { sides, sideNails } = this.config;\n    const circleRounds = sides % 2 ? Math.ceil(sideNails / 2) : sideNails;\n    const linesPerRound = sides % 2 ? sides * 4 : sides * 2;\n\n    return (circleRounds + 1) * linesPerRound - sides * 2;\n  }\n\n  getStepCount(): number {\n    const { sides, sideNails, ringSize } = this.config;\n\n    const ringCount = ringSize ? sideNails * sides : 0;\n    const circleCount = this.#getCircleStepCount();\n    const starCount = StarShape.getStepCount(this.config);\n    return circleCount + ringCount + starCount;\n  }\n\n  static thumbnailConfig = {\n    sideNails: 18,\n  };\n}\n","import Nails from '../Nails';\nimport Renderer from '../renderers/Renderer';\nimport {\n  ControlConfig,\n  ControlsConfig,\n  NailsConfig,\n} from '../types/config.types';\nimport { Coordinates, Dimensions } from '../types/general.types';\nimport { compareObjects } from './object_utils';\nimport { formatFractionAsPercent } from './string_utils';\n\nexport interface StarShapeConfig {\n  sideNails: number;\n  sides: number;\n  maxCurveSize?: number;\n  centerRadius: number;\n  rotation: number;\n  center?: Coordinates;\n  size?: Dimensions;\n  radius?: number;\n}\n\nexport default class StarShape {\n  config: StarShapeConfig;\n  center: Coordinates;\n  calc: ReturnType<typeof StarShape.getCalc>;\n\n  constructor(config: StarShapeConfig) {\n    this.setConfig(config);\n  }\n\n  static getCalc({\n    radius,\n    sides,\n    sideNails,\n    rotation,\n    centerRadius: centerRadiusFraction = 0,\n    maxCurveSize = 1,\n  }: StarShapeConfig) {\n    const centerRadius = radius * centerRadiusFraction;\n    const nailSpacing = (radius - centerRadius) / (sideNails - 1); // The distance between nails on the same side, in px\n    const sidesAngle = (Math.PI * 2) / sides; // The angle, in radians, between each side\n    const rotationAngle = rotation ? (-Math.PI * 2 * rotation) / sides : 0;\n\n    return {\n      sideAngle: sidesAngle,\n      nailSpacing,\n      centerRadius,\n      linesPerRound: sides % 2 ? sides * 2 : sides,\n      sidesConnectionCount: Math.floor(Math.min(1, maxCurveSize) * sideNails),\n      sideSize: radius - centerRadius,\n      sides: new Array(sides).fill(null).map((_, side) => {\n        const sideAngle = side * sidesAngle + rotationAngle;\n\n        return {\n          sinSideAngle: Math.sin(sideAngle),\n          cosSideAngle: Math.cos(sideAngle),\n        };\n      }),\n    };\n  }\n\n  getPoint(side = 0, index = 0): Coordinates {\n    const radius = this.calc.centerRadius + index * this.calc.nailSpacing;\n    const { sinSideAngle, cosSideAngle } = this.calc.sides[side];\n\n    return [\n      this.center[0] + sinSideAngle * radius,\n      this.center[1] + cosSideAngle * radius,\n    ];\n  }\n\n  setConfig(config: StarShapeConfig) {\n    if (\n      compareObjects(config, this.config, [\n        'radius',\n        'sides',\n        'sideNails',\n        'rotation',\n        'center',\n        'size',\n        'centerRadius',\n        'maxCurveSize',\n      ])\n    ) {\n      return;\n    }\n\n    const center =\n      config.center ?? (config.size.map(v => v / 2) as Coordinates);\n\n    this.config = config;\n    this.center = center;\n    this.calc = StarShape.getCalc(config);\n  }\n\n  /**\n   * Given a Nails instance, uses it to draw the nails of this Circle\n   */\n  drawNails(\n    nails: Nails,\n    {\n      getNumber,\n      reverseOrder,\n      ...nailsConfig\n    }: Partial<\n      {\n        getNumber: (side: number, sideIndex: number) => string;\n        reverseOrder: boolean;\n      } & NailsConfig\n    > = {}\n  ): void {\n    const { sides, sideNails } = this.config;\n\n    const groupNails = [];\n\n    for (let side = 0; side < sides; side++) {\n      for (let i = 0; i < sideNails; i++) {\n        const sideIndex = reverseOrder ? sideNails - i : i;\n        groupNails.push({\n          point: this.getPoint(side, sideIndex),\n          number: getNumber\n            ? getNumber(side, sideIndex)\n            : sideIndex || this.config.centerRadius\n            ? `${side}_${sideIndex}`\n            : 0,\n        });\n      }\n    }\n\n    nails.addGroup(groupNails, nailsConfig);\n  }\n\n  // In this pattern, strings are connected in a \"merry-go-round\" way, around the star.\n  // With even sides count, the strings go around the star once, while with odd sides count, each round goes twice around the star.\n  // The threading is: star at the center (or centerRadius, if > 0), then next side at the edge (outtermost nail) or the size param which represents the count of nails to use,\n  // then back to the center for the next side,   // until all sides have been connected both center and edge (for odd-side-count stars) or until all sides have been\n  // connected (for odd-side-count), then move up one nail from the center and start another round.\n  *generateStrings(\n    renderer: Renderer,\n    { size }: { size?: number } = {}\n  ): Generator<void> {\n    const { sideNails: sideNailsConfig, sides } = this.config;\n    const { sidesConnectionCount, linesPerRound } = this.calc;\n\n    const sideNails = size\n      ? Math.max(1, Math.min(Math.floor(size), sideNailsConfig))\n      : sideNailsConfig;\n\n    const minNailIndex = Math.max(0, sideNails - sidesConnectionCount);\n\n    let alternate = false;\n\n    const rounds =\n      sides % 2\n        ? Math.ceil(Math.min(sideNails, sidesConnectionCount) / 2)\n        : sideNails - minNailIndex;\n\n    let prevPointIndex = minNailIndex;\n    let prevPoint = this.getPoint(0, prevPointIndex);\n\n    for (let round = 0; round < rounds; round++) {\n      const isLastRound = round === rounds - 1;\n      let side = 0;\n\n      for (let i = 0; i < linesPerRound; i++) {\n        side = (side + 1) % sides;\n        alternate = !alternate;\n        prevPointIndex = alternate\n          ? sideNails - round - 1\n          : round + minNailIndex;\n        const nextPoint = this.getPoint(side, prevPointIndex);\n        renderer.renderLines(prevPoint, nextPoint);\n        prevPoint = nextPoint;\n        yield;\n\n        if (isLastRound && i === sides - 1 && sides % 2 && sideNails % 2) {\n          break;\n        }\n      }\n\n      if (!isLastRound) {\n        prevPointIndex = alternate ? prevPointIndex - 1 : prevPointIndex + 1;\n        const nextPoint = this.getPoint(0, prevPointIndex);\n        renderer.renderLines(prevPoint, nextPoint);\n        prevPoint = nextPoint;\n      }\n    }\n  }\n\n  getStepCount(size: number) {\n    return StarShape.getStepCount(this.config, { size });\n  }\n\n  static getStepCount(\n    {\n      sides,\n      sideNails: sideNailsConfig,\n      maxCurveSize = 1,\n    }: Partial<StarShapeConfig>,\n    { size }: { size?: number } = {}\n  ) {\n    const sidesConnectionCount = Math.floor(\n      Math.min(1, maxCurveSize) * sideNailsConfig\n    );\n    const sideNails = size\n      ? Math.min(Math.floor(size), sideNailsConfig)\n      : sideNailsConfig;\n    const minNailIndex = Math.max(0, sideNails - sidesConnectionCount);\n\n    const rounds =\n      sides % 2\n        ? Math.ceil(Math.min(sideNails, sidesConnectionCount) / 2)\n        : sideNails - minNailIndex;\n\n    const linesPerRound = sides % 2 ? sides * 2 : sides;\n    const isOdd = sides % 2 && sideNails % 2;\n    return rounds * linesPerRound - (isOdd ? sides : 0);\n  }\n\n  static nailsConfig: ControlConfig<StarShapeConfig> = Object.freeze({\n    key: 'sideNails',\n    label: 'Nails per side',\n    defaultValue: 40,\n    type: 'range',\n    attr: { min: 1, max: 200, step: 1 },\n    isStructural: true,\n  });\n\n  static sidesConfig: ControlConfig<StarShapeConfig> = Object.freeze({\n    key: 'sides',\n    label: 'Sides',\n    defaultValue: 3,\n    type: 'range',\n    attr: { min: 3, max: 40, step: 1 },\n    isStructural: true,\n  });\n\n  static maxCurveSize: ControlConfig<StarShapeConfig> = {\n    key: 'maxCurveSize',\n    label: 'Max curve size',\n    description:\n      'The maximum number of connections used to create a curve between two sides.',\n    defaultValue: 1,\n    type: 'range',\n    displayValue: ({ maxCurveSize, sideNails }) =>\n      Math.floor(maxCurveSize * sideNails),\n    attr: {\n      min: 0,\n      max: 1,\n      step: ({ sideNails }) => 1 / sideNails,\n    },\n    isStructural: true,\n  };\n\n  static centerRadiusConfig: ControlConfig<StarShapeConfig> = {\n    key: 'centerRadius',\n    label: 'Center radius',\n    defaultValue: 0,\n    type: 'range',\n    attr: {\n      min: 0,\n      max: ({ sideNails }) => (sideNails - 1) / sideNails,\n      step: 0.01,\n    },\n    displayValue: ({ centerRadius }) => formatFractionAsPercent(centerRadius),\n    isStructural: true,\n  };\n\n  static rotationConfig: ControlConfig<StarShapeConfig> = {\n    key: 'rotation',\n    label: 'Rotation',\n    defaultValue: 0,\n    type: 'range',\n    attr: {\n      min: 0,\n      max: 1,\n      step: 0.01,\n      snap: '0.5',\n    },\n    displayValue: ({ rotation, sides }) =>\n      `${Math.round((rotation * 360) / sides)}`,\n    isStructural: true,\n    affectsStepCount: false,\n  };\n\n  static StarConfig: ControlsConfig<StarShapeConfig> = [\n    StarShape.nailsConfig,\n    StarShape.sidesConfig,\n    StarShape.centerRadiusConfig,\n    StarShape.maxCurveSize,\n    StarShape.rotationConfig,\n  ];\n}\n","import StringArt from '../StringArt';\nimport Circle, { CircleConfig } from '../helpers/Circle';\nimport { ControlsConfig, GroupValue } from '../types/config.types.js';\nimport { Coordinates } from '../types/general.types';\n\nconst LAYER_DEFAULTS = [\n  { size: 0.25, end: 1, color: '#a94fb0' },\n  { size: 0.125, end: 0.888, color: '#ec6ad0' },\n  { size: 0, end: 0.826, color: '#f08ad5', reverse: true },\n];\n\ninterface AssymetryConfig extends CircleConfig {\n  layers: GroupValue;\n  layer1: GroupValue;\n  show1: boolean;\n  size1: number;\n  end1: number;\n  color1: number;\n  reverse1: number;\n\n  layer2: GroupValue;\n  show2: boolean;\n  size2: number;\n  end2: number;\n  color2: number;\n  reverse2: number;\n\n  layer3: GroupValue;\n  show3: boolean;\n  size3: number;\n  end3: number;\n  color3: number;\n  reverse3: number;\n\n  distortion: number;\n}\n\ninterface Layer {\n  enable: boolean;\n  size: number;\n  endIndex: number;\n  color: number;\n  isReverse: number;\n}\n\ninterface TCalc {\n  circle: Circle;\n  lineSpacing: number;\n  lineNailCount: number;\n  firstCirclePoint: Coordinates;\n  layers: ReadonlyArray<Layer>;\n  totalNailCount: number;\n  totalIndexCount: number;\n}\n\nexport default class Assymetry extends StringArt<AssymetryConfig> {\n  static type = 'assymetry';\n\n  name = 'Assymetry';\n  id = 'assymetry';\n  link =\n    'https://www.etsy.com/il-en/listing/1018950430/calming-wall-art-in-light-blue-for';\n  controls: ControlsConfig<AssymetryConfig> = [\n    Circle.nailsConfig,\n    Circle.rotationConfig,\n    Circle.distortionConfig,\n    {\n      key: 'layers',\n      label: 'Layers',\n      type: 'group',\n      // @ts-expect-error: dynamic key is safe because we know the keys match Layers\n      children: LAYER_DEFAULTS.map(({ size, end, color, reverse }, i) => {\n        const layer = i + 1;\n        return {\n          key: `layer${layer}`,\n          label: `Layer ${layer}`,\n          type: 'group',\n          children: [\n            {\n              key: `show${layer}`,\n              label: 'Enable',\n              defaultValue: true,\n              type: 'checkbox',\n            },\n            {\n              key: `size${layer}`,\n              label: 'Size',\n              defaultValue: size,\n              type: 'range',\n              attr: {\n                min: 0,\n                max: 0.5,\n                step: ({ n }) => 1 / n,\n              },\n              displayValue: config =>\n                Math.round(config.n * config[`size${layer}`]),\n              show: config => config[`show${layer}`],\n            },\n            {\n              key: `end${layer}`,\n              label: 'End Position',\n              defaultValue: end,\n              type: 'range',\n              attr: {\n                min: 0,\n                max: 1,\n                step: ({ n }) => 1 / n,\n              },\n              displayValue: config =>\n                Math.round(config.n * config[`end${layer}`]),\n              show: config => config[`show${layer}`],\n            },\n            {\n              key: `color${layer}`,\n              label: 'Color',\n              defaultValue: color,\n              type: 'color',\n              show: config => config[`show${layer}`],\n            },\n            {\n              key: `reverse${layer}`,\n              label: 'Reverse',\n              defaultValue: reverse === true,\n              type: 'checkbox',\n              show: config => config[`show${layer}`],\n            },\n          ],\n        };\n      }),\n    },\n  ];\n\n  #circle: Circle;\n  #calc: TCalc;\n\n  setUpDraw() {\n    super.setUpDraw();\n    this.#calc = this.#getCalc();\n  }\n\n  #getCalc() {\n    const { rotation, n, margin = 0, distortion } = this.config;\n    const size = this.getSize();\n\n    const circleConfig: CircleConfig = {\n      size,\n      n,\n      margin,\n      rotation: rotation - 0.25,\n      distortion,\n    };\n\n    let circle: Circle;\n    if (this.#calc?.circle) {\n      circle = this.#calc.circle;\n      this.#calc.circle.setConfig(circleConfig);\n    } else {\n      circle = new Circle(circleConfig);\n    }\n\n    let lineSpacing = circle.indexAngle * circle.radius;\n    const lineNailCount = Math.floor(circle.radius / lineSpacing) - 1;\n    lineSpacing +=\n      (circle.radius - lineSpacing * lineNailCount) / lineNailCount;\n    const firstCirclePoint = circle.getPoint(0);\n    const totalNailCount = lineNailCount + n;\n    const totalIndexCount = totalNailCount + lineNailCount;\n    const layers = new Array(3)\n      .fill(null)\n      .map((_, i) => getLayer.call(this, i + 1))\n      .filter(({ enable }) => enable);\n\n    return {\n      circle,\n      lineSpacing,\n      lineNailCount,\n      firstCirclePoint,\n      layers,\n      totalNailCount,\n      totalIndexCount,\n    };\n\n    function getLayer(layerIndex: number): Layer {\n      const size =\n        Math.round(n * this.config['size' + layerIndex]) + lineNailCount;\n      return {\n        size,\n        endIndex:\n          Math.round(\n            this.config['end' + layerIndex] * (totalNailCount + lineNailCount)\n          ) - size,\n        color: this.config['color' + layerIndex],\n        enable: this.config['show' + layerIndex],\n        isReverse: this.config['reverse' + layerIndex],\n      };\n    }\n  }\n\n  /**\n   * Returns the position of a point on the line\n   */\n  getPoint(index: number): Coordinates {\n    if (index < this.#calc.lineNailCount || index > this.#calc.totalNailCount) {\n      const linePosition =\n        index < this.#calc.lineNailCount\n          ? this.#calc.lineNailCount - index\n          : index - this.#calc.totalNailCount;\n\n      const indexLength = linePosition * this.#calc.lineSpacing;\n      return [\n        this.#calc.firstCirclePoint[0] -\n          indexLength * Math.sin(this.#calc.circle.rotationAngle),\n        this.#calc.firstCirclePoint[1] -\n          indexLength * Math.cos(this.#calc.circle.rotationAngle),\n      ];\n    } else {\n      const circleIndex = index - this.#calc.lineNailCount;\n      return this.#calc.circle.getPoint(circleIndex);\n    }\n  }\n\n  *drawCircle({ endIndex, color, isReverse, size }): Generator<void> {\n    let prevPoint: Coordinates;\n    let prevPointIndex: number;\n    let isPrevSide = false;\n    this.renderer.setColor(color);\n    const self = this;\n    const advance = isReverse ? -1 : 1;\n\n    for (let index = 0; index <= endIndex; index++) {\n      const startPoint = prevPoint ?? this.getPoint(getPointIndex(index));\n      const positions = [];\n      if (prevPoint) {\n        positions.push(this.getPoint(prevPointIndex + advance));\n      }\n      prevPointIndex = getPointIndex(isPrevSide ? index : index + size);\n      positions.push((prevPoint = this.getPoint(prevPointIndex)));\n\n      this.renderer.renderLines(startPoint, ...positions);\n\n      yield;\n\n      isPrevSide = !isPrevSide;\n    }\n\n    function getPointIndex(index: number): number {\n      return isReverse ? self.#calc.totalIndexCount - index : index;\n    }\n  }\n\n  *generateStrings() {\n    for (const layer of this.#calc.layers) {\n      yield* this.drawCircle(layer);\n    }\n  }\n\n  drawNails() {\n    this.#calc.circle.drawNails(this.nails, {\n      nailsNumberStart: this.#calc.lineNailCount,\n    });\n\n    for (let i = 0; i < this.#calc.lineNailCount; i++) {\n      this.nails.addNail({ point: this.getPoint(i), number: i });\n    }\n  }\n\n  getStepCount(): number {\n    const { layers } = this.#getCalc();\n    return layers.reduce(\n      (stepCount, layer) => stepCount + layer.endIndex + 1,\n      0\n    );\n  }\n\n  static thumbnailConfig = {\n    n: 50,\n  };\n}\n","import StringArt from '../StringArt';\nimport Circle from '../helpers/Circle';\nimport { ColorValue } from '../helpers/color/color.types';\nimport {\n  ControlConfig,\n  ControlsConfig,\n  ControlType,\n  GroupValue,\n} from '../types/config.types';\nimport { Coordinates } from '../types/general.types';\n\ninterface FreestyleConfig {\n  n: number;\n  minNailDistance: number;\n  color: ColorValue;\n  layers: GroupValue;\n\n  layer1: GroupValue;\n  show1: boolean;\n  radius1: number;\n  x1: number;\n  y1: number;\n  rotation1: number;\n  reverse1: boolean;\n\n  layer2: GroupValue;\n  show2: boolean;\n  radius2: number;\n  x2: number;\n  y2: number;\n  rotation2: number;\n  reverse2: boolean;\n\n  layer3: GroupValue;\n  show3: boolean;\n  radius3: number;\n  x3: number;\n  y3: number;\n  rotation3: number;\n  reverse3: boolean;\n}\n\nconst rotationConfig = {\n  label: 'Rotation',\n  defaultValue: 0,\n  type: 'range' as ControlType,\n  attr: {\n    min: 0,\n    max: 1 + 1 / 360,\n    step: 1 / 360,\n  },\n  isStructural: true,\n  affectsStepCount: false,\n};\n\ninterface Layer {\n  circle: Circle;\n  enable: boolean;\n  isReverse: boolean;\n  position: Coordinates;\n  radius: number;\n  rotation: number;\n}\n\ninterface TCalc {\n  layers: ReadonlyArray<Layer>;\n  maxShapeNailsCount: number;\n}\n\nexport default class Freestyle extends StringArt<FreestyleConfig> {\n  static type = 'freestyle';\n\n  name = 'Freestyle';\n  id = 'freestyle';\n  link =\n    'https://www.etsy.com/il-en/listing/1018950430/calming-wall-art-in-light-blue-for';\n  controls: ControlsConfig<FreestyleConfig> = [\n    {\n      key: 'n',\n      label: 'Circle nails',\n      defaultValue: 80,\n      type: 'range',\n      attr: { min: 1, max: 300, step: 1 },\n    },\n    {\n      key: 'minNailDistance',\n      label: 'Min nail distance',\n      defaultValue: 20,\n      type: 'range',\n      attr: { min: 1, max: 300, step: 1 },\n    },\n    {\n      key: 'color',\n      label: 'Color',\n      defaultValue: '#ec6ad0',\n      type: 'color',\n    },\n    {\n      key: 'layers',\n      label: 'Layers',\n      type: 'group',\n      children: [\n        {\n          key: 'layer1',\n          label: 'Layer 1',\n          type: 'group',\n          children: [\n            {\n              key: 'show1',\n              label: 'Enable',\n              defaultValue: true,\n              type: 'checkbox',\n            },\n            {\n              key: 'radius1',\n              label: 'Radius',\n              defaultValue: 0.5,\n              type: 'range',\n              attr: { min: 0.01, max: 1, step: 0.01 },\n              show: ({ show1 }) => show1,\n            },\n            {\n              key: 'x1',\n              label: 'Position X',\n              defaultValue: 0.5,\n              type: 'range',\n              attr: { min: 0, max: 1, step: 0.01 },\n              show: ({ show1 }) => show1,\n            },\n            {\n              key: 'y1',\n              label: 'Position Y',\n              defaultValue: 0,\n              type: 'range',\n              attr: { min: 0, max: 1, step: 0.01 },\n              show: ({ show1 }) => show1,\n            },\n            {\n              ...rotationConfig,\n              key: 'rotation1',\n              show: ({ show1 }) => show1,\n              displayValue: ({ rotation1 }) =>\n                `${Math.round(rotation1 * 360)}`,\n            },\n            {\n              key: 'reverse1',\n              label: 'Reverse',\n              defaultValue: false,\n              type: 'checkbox',\n              show: ({ show1 }) => show1,\n            },\n          ],\n        },\n        {\n          key: 'layer2',\n          label: 'Layer 2',\n          type: 'group',\n          children: [\n            {\n              key: 'show2',\n              label: 'Enable',\n              defaultValue: true,\n              type: 'checkbox',\n            },\n            {\n              key: 'radius2',\n              label: 'Radius',\n              defaultValue: 0.5,\n              type: 'range',\n              attr: { min: 0.01, max: 1, step: 0.01 },\n              show: ({ show2 }) => show2,\n            },\n            {\n              key: 'x2',\n              label: 'Position X',\n              defaultValue: 0,\n              type: 'range',\n              attr: { min: 0, max: 1, step: 0.01 },\n              show: ({ show2 }) => show2,\n            },\n            {\n              key: 'y2',\n              label: 'Position Y',\n              defaultValue: 1,\n              type: 'range',\n              attr: { min: 0, max: 1, step: 0.01 },\n              show: ({ show2 }) => show2,\n            },\n            {\n              ...rotationConfig,\n              key: 'rotation2',\n              show: ({ show2 }) => show2,\n              displayValue: ({ rotation2 }) =>\n                `${Math.round(rotation2 * 360)}`,\n            },\n            {\n              key: 'reverse2',\n              label: 'Reverse',\n              defaultValue: false,\n              type: 'checkbox',\n              show: ({ show2 }) => show2,\n            },\n          ],\n        },\n        {\n          key: 'layer3',\n          label: 'Layer 3',\n          type: 'group',\n          children: [\n            {\n              key: 'show3',\n              label: 'Enable',\n              defaultValue: true,\n              type: 'checkbox',\n            },\n            {\n              key: 'radius3',\n              label: 'Radius',\n              defaultValue: 0.5,\n              type: 'range',\n              attr: { min: 0.01, max: 1, step: 0.01 },\n              show: ({ show3 }) => show3,\n            },\n            {\n              key: 'x3',\n              label: 'Position X',\n              defaultValue: 1,\n              type: 'range',\n              attr: { min: 0, max: 1, step: 0.01 },\n              show: ({ show3 }) => show3,\n            },\n            {\n              key: 'y3',\n              label: 'Position Y',\n              defaultValue: 1,\n              type: 'range',\n              attr: { min: 0, max: 1, step: 0.01 },\n              show: ({ show3 }) => show3,\n            },\n            {\n              ...rotationConfig,\n              key: 'rotation3',\n              show: ({ show3 }) => show3,\n              displayValue: ({ rotation3 }) =>\n                `${Math.round(rotation3 * 360)}`,\n            },\n            {\n              key: 'reverse3',\n              label: 'Reverse',\n              defaultValue: false,\n              type: 'checkbox',\n              show: ({ show3 }) => show3,\n            },\n          ],\n        },\n      ],\n    },\n  ];\n\n  #calc: TCalc;\n\n  setUpDraw() {\n    super.setUpDraw();\n    this.#calc = this.getCalc();\n  }\n\n  getCalc(): TCalc {\n    const { n, margin = 0, minNailDistance } = this.config;\n    const size = this.getSize();\n\n    const maxRadius = Math.min(...size.map(v => v - 2 * margin)) / 2;\n    const layers = new Array(3)\n      .fill(null)\n      .map((_, i) => getLayer.call(this, i + 1))\n      .filter(({ enable }) => enable);\n\n    const maxShapeNailsCount = Math.max(\n      ...layers.map(({ circle }) => circle.config.n)\n    );\n\n    return {\n      layers,\n      maxShapeNailsCount,\n    };\n\n    function getLayer(layerIndex: number): Layer {\n      const prop = (prop: string) => this.config[prop + layerIndex];\n\n      const props = {\n        enable: prop('show'),\n        isReverse: prop('reverse'),\n        position: [prop('x'), prop('y')] as Coordinates,\n        radius: maxRadius * prop('radius'),\n        rotation: prop('rotation'),\n      };\n\n      const circumsference = Math.PI * 2 * props.radius;\n      const circleNails = Math.min(\n        n,\n        Math.floor(circumsference / minNailDistance)\n      );\n\n      const circle = new Circle({\n        radius: props.radius,\n        size: this.size,\n        center: props.position.map(\n          (v, i) =>\n            props.radius + margin + (size[i] - (props.radius + margin) * 2) * v\n        ) as Coordinates,\n        n: circleNails,\n        rotation: props.rotation,\n        reverse: props.isReverse,\n      });\n\n      return {\n        circle,\n        ...props,\n      };\n    }\n  }\n\n  getPoint(layer: Layer, index: number): Coordinates {\n    const { circle } = layer;\n    let circleIndex = Math.round(\n      (index * circle.config.n) / this.#calc.maxShapeNailsCount\n    );\n    return circle.getPoint(circleIndex);\n  }\n\n  *generateStrings(): Generator<void> {\n    const { color } = this.config;\n\n    this.renderer.setColor(color);\n    let prevCirclePoint: Coordinates;\n\n    for (let i = 0; i < this.#calc.maxShapeNailsCount; i++) {\n      for (\n        let layerIndex = 0;\n        layerIndex < this.#calc.layers.length;\n        layerIndex++\n      ) {\n        const layer = this.#calc.layers[layerIndex];\n        const startPoint = prevCirclePoint ?? this.getPoint(layer, i);\n\n        const positions: Coordinates[] = [];\n        if (layerIndex === 0 && i) {\n          positions.push(this.getPoint(layer, i));\n        }\n\n        let nextLayerIndex = layerIndex + 1;\n        if (nextLayerIndex === this.#calc.layers.length) {\n          nextLayerIndex = 0;\n        }\n\n        prevCirclePoint = this.getPoint(this.#calc.layers[nextLayerIndex], i);\n\n        this.renderer.renderLines(startPoint, prevCirclePoint);\n        yield;\n      }\n    }\n  }\n\n  drawNails() {\n    this.#calc.layers.forEach(({ circle }, layerIndex) =>\n      circle.drawNails(this.nails, {\n        getNumber: i => `${layerIndex + 1}_${i + 1}`,\n      })\n    );\n  }\n\n  getStepCount() {\n    const { layers, maxShapeNailsCount } = this.getCalc();\n    return layers.length * maxShapeNailsCount - 1;\n  }\n\n  static thumbnailConfig = {\n    minNailDistance: 3,\n    n: 40,\n  };\n}\n","import StringArt from '../StringArt.js';\nimport Circle from '../helpers/Circle.js';\nimport Polygon, { PolygonConfig } from '../helpers/Polygon.js';\nimport Color from '../helpers/color/Color.js';\nimport { ColorConfig, ColorMap } from '../helpers/color/color.types.js';\nimport { ControlsConfig } from '../types/config.types.js';\n\ninterface PolygonPatternConfig extends ColorConfig {\n  sides: number;\n  n: number;\n  bezier: number;\n  rotation: number;\n}\n\nconst COLOR_CONFIG = Color.getConfig({\n  defaults: {\n    isMultiColor: true,\n    color: '#ff0000',\n    multicolorRange: 1,\n    multicolorStart: 0,\n    multicolorByLightness: true,\n    minLightness: 20,\n    maxLightness: 50,\n  },\n  exclude: ['colorCount'],\n});\n\nexport default class PolygonPattern extends StringArt<PolygonPatternConfig> {\n  static type = 'polygon';\n\n  name = 'Polygon';\n  id = 'polygon';\n  controls: ControlsConfig<PolygonPatternConfig> = [\n    {\n      key: 'sides',\n      label: 'Sides',\n      defaultValue: 5,\n      type: 'range',\n      attr: {\n        min: 3,\n        max: 10,\n        step: 1,\n      },\n    },\n    {\n      key: 'n',\n      label: 'Nails per side',\n      defaultValue: 60,\n      type: 'range',\n      attr: {\n        min: 1,\n        max: 100,\n        step: 1,\n      },\n    },\n    {\n      key: 'bezier',\n      label: 'Bezier',\n      defaultValue: 2,\n      type: 'range',\n      attr: {\n        min: 1,\n        max: 4,\n        step: 1,\n      },\n      show: ({ sides }) => sides > 4,\n    },\n    Polygon.rotationConfig,\n    COLOR_CONFIG,\n  ];\n\n  defaultValues = {\n    nailsColor: '#5c5c5c',\n    nailRadius: 1,\n  };\n\n  #polygon: Polygon;\n  color: Color;\n  colorMap: ColorMap;\n\n  setUpDraw() {\n    super.setUpDraw();\n    const { n, rotation, sides, margin, isMultiColor } = this.config;\n    const size = this.getSize();\n\n    const polygonConfig: PolygonConfig = {\n      sides,\n      rotation: rotation / (sides * 2),\n      margin,\n      size,\n      nailsSpacing: 1 / n,\n      fitSize: true,\n    };\n\n    if (this.#polygon) {\n      this.#polygon.setConfig(polygonConfig);\n    } else {\n      this.#polygon = new Polygon(polygonConfig);\n    }\n\n    this.color = new Color({\n      ...this.config,\n      isMultiColor,\n      colorCount: sides,\n    });\n\n    if (isMultiColor) {\n      this.colorMap = this.color.getColorMap({\n        stepCount: this.getStepCount(),\n        colorCount: sides,\n      });\n    } else {\n      this.colorMap = null;\n    }\n  }\n\n  *generateStrings() {\n    const { sides, bezier } = this.config;\n    const limitedBezier = Math.min(bezier, Math.ceil(sides / 2) - 1);\n\n    let step = 0;\n    this.renderer.setColor(this.color.getColor(0));\n\n    for (let side = 0; side < sides; side++) {\n      const nextSide = (side + limitedBezier) % sides;\n\n      if (this.colorMap) {\n        this.renderer.setColor(this.colorMap.get(step));\n      }\n      for (let index = 0; index < this.#polygon.nailsPerSide; index++) {\n        this.renderer.renderLines(\n          this.#polygon.getSidePoint({ side, index }),\n          this.#polygon.getSidePoint({ side: nextSide, index })\n        );\n\n        yield;\n        step++;\n      }\n    }\n  }\n\n  getStepCount() {\n    const { sides, n } = this.config;\n    return sides * n;\n  }\n\n  drawNails() {\n    this.#polygon.drawNails(this.nails);\n  }\n\n  static thumbnailConfig = {\n    n: 20,\n  };\n}\n","import Nails from '../Nails.js';\nimport { ControlConfig } from '../types/config.types.js';\nimport { Coordinates, Dimensions } from '../types/general.types.js';\nimport { PI2 } from './math_utils.js';\nimport { compareObjects } from './object_utils.js';\n\nexport interface PolygonConfig {\n  size: Dimensions;\n  sides: number;\n  fitSize?: boolean;\n  nailsSpacing: number;\n  margin?: number;\n  rotation?: number;\n  center?: Coordinates;\n}\n\ninterface Side {\n  cos: number;\n  sin: number;\n  center: {\n    cos: number;\n    sin: number;\n  };\n}\n\ninterface BoundingRect {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n  width: number;\n  height: number;\n}\n\ninterface TCalc {\n  nailsPerSide: number;\n  center: Coordinates;\n  radius: number;\n  sideSize: number;\n  start: Coordinates;\n  nailsDistance: number;\n  radiusNailsCount: number;\n  radiusNailsDistance: number;\n  sides: ReadonlyArray<Side>;\n  sideAngle: number;\n}\n\nexport default class Polygon {\n  config: PolygonConfig;\n  #points: Map<string, Coordinates>;\n  #calc: TCalc;\n\n  constructor(config: PolygonConfig) {\n    this.setConfig(config);\n  }\n\n  setConfig(config: PolygonConfig) {\n    if (!compareObjects(config, this.config)) {\n      this.config = config;\n\n      if (this.#points) {\n        this.#points.clear();\n      } else {\n        this.#points = new Map();\n      }\n\n      this.#calc = this.#getCalc();\n\n      if (config.fitSize) {\n        const sizeAndCenter = this.#getSizeAndCenter();\n        this.#points.clear();\n        this.#calc = { ...this.#getCalc(), ...sizeAndCenter };\n      }\n    }\n  }\n\n  #getSizeAndCenter(): {\n    size: Dimensions;\n    center: Coordinates;\n  } {\n    const { size: configSize, margin } = this.config;\n\n    const boundingRect = this.getBoundingRect();\n    const scale = Math.min(\n      (configSize[0] - 2 * margin) / boundingRect.width,\n      (configSize[1] - 2 * margin) / boundingRect.height\n    );\n\n    const size = configSize.map(v => v * scale) as Dimensions;\n    const center = [\n      this.#calc.center[0] -\n        (scale * (boundingRect.left - configSize[0] + boundingRect.right)) / 2,\n      this.#calc.center[1] -\n        (scale * (boundingRect.top - configSize[1] + boundingRect.bottom)) / 2,\n    ] as Coordinates;\n\n    return { size, center };\n  }\n\n  #getCalc(): TCalc {\n    const {\n      size,\n      rotation = 0,\n      sides: sideCount,\n      center: configCenter,\n      margin,\n      nailsSpacing,\n    } = this.config;\n\n    const sideAngle = PI2 / sideCount;\n\n    const sides: ReadonlyArray<Side> = new Array(sideCount)\n      .fill(null)\n      .map((_, i) => {\n        const angle = sideAngle * i + PI2 * rotation;\n        const radiusAngle = -sideAngle * (i - 0.5) - PI2 * rotation;\n\n        return {\n          cos: Math.cos(angle),\n          sin: Math.sin(angle),\n          center: {\n            cos: Math.cos(radiusAngle),\n            sin: Math.sin(radiusAngle),\n          },\n        };\n      });\n\n    const center =\n      configCenter ?? (this.config.size.map(v => v / 2) as Coordinates);\n\n    const radius = Math.min(...size) / 2 - margin;\n    const sideSize = 2 * radius * Math.sin(sideAngle / 2);\n    const start: Coordinates = [\n      radius * Math.sin(sideAngle / 2),\n      radius * Math.cos(sideAngle / 2),\n    ];\n    const nailsDistance = sideSize * nailsSpacing;\n    const radiusNailsCount = Math.floor(radius / nailsDistance);\n    const radiusNailsDistance = radius / radiusNailsCount;\n\n    return {\n      nailsPerSide: 1 / nailsSpacing,\n      center,\n      radius,\n      sideSize,\n      start,\n      nailsDistance,\n      radiusNailsCount,\n      radiusNailsDistance,\n      sides,\n      sideAngle,\n    };\n  }\n\n  get nailsPerSide(): number {\n    return this.#calc.nailsPerSide;\n  }\n\n  get radiusNailsCount(): number {\n    return this.#calc.radiusNailsCount;\n  }\n\n  get sideSize(): number {\n    return this.#calc.sideSize;\n  }\n\n  getSidePoint({ side, index }): Coordinates {\n    const pointsMapIndex = [side, index].join('_');\n\n    if (this.#points.has(pointsMapIndex)) {\n      return this.#points.get(pointsMapIndex);\n    }\n\n    const startX = this.#calc.start[0] - index * this.#calc.nailsDistance;\n    const { cos, sin } = this.#calc.sides[side];\n\n    const point = [\n      cos * startX - sin * this.#calc.start[1] + this.#calc.center[0],\n      sin * startX + cos * this.#calc.start[1] + this.#calc.center[1],\n    ] as Coordinates;\n\n    this.#points.set(pointsMapIndex, point);\n    return point;\n  }\n\n  getCenterPoint({ side, index }): Coordinates {\n    const radius = index * this.#calc.radiusNailsDistance;\n    const { sin, cos } = this.#calc.sides[side].center;\n\n    return [\n      this.#calc.center[0] + sin * radius,\n      this.#calc.center[1] + cos * radius,\n    ];\n  }\n\n  getBoundingRect(): BoundingRect {\n    const points = this.#calc.sides.map((_, side) =>\n      this.getSidePoint({ side, index: 0 })\n    );\n    const firstPoint = points[0];\n\n    const boundingRect = points.slice(1).reduce(\n      (boundingRect, [x, y]) => ({\n        left: Math.min(boundingRect.left, x),\n        right: Math.max(boundingRect.right, x),\n        top: Math.min(boundingRect.top, y),\n        bottom: Math.max(boundingRect.bottom, y),\n      }),\n      {\n        left: firstPoint[0],\n        right: firstPoint[0],\n        top: firstPoint[1],\n        bottom: firstPoint[1],\n      }\n    );\n\n    return {\n      ...boundingRect,\n      height: boundingRect.bottom - boundingRect.top,\n      width: boundingRect.right - boundingRect.left,\n    };\n  }\n\n  drawNails(\n    nails: Nails,\n    {\n      drawCenter = false,\n      drawSides = true,\n      filterCenterNails,\n    }: {\n      drawCenter?: boolean;\n      drawSides?: boolean;\n      filterCenterNails?: (side: number, index: number) => boolean;\n    } = {}\n  ) {\n    for (let side = 0; side < this.config.sides; side++) {\n      const sideIndexStart = side * this.#calc.nailsPerSide;\n\n      if (drawSides) {\n        for (let index = 0; index < this.#calc.nailsPerSide; index++) {\n          nails.addNail({\n            point: this.getSidePoint({ side, index }),\n            number: sideIndexStart + index,\n          });\n        }\n      }\n\n      if (drawCenter) {\n        for (let index = 0; index < this.#calc.radiusNailsCount; index++) {\n          if (!filterCenterNails || filterCenterNails(side, index)) {\n            nails.addNail({\n              point: this.getCenterPoint({ side, index }),\n              number: `${side}_${index}`,\n            });\n          }\n        }\n      }\n    }\n  }\n\n  static rotationConfig: ControlConfig<{ rotation: number; sides: number }> = {\n    key: 'rotation',\n    label: 'Rotation',\n    defaultValue: 0,\n    type: 'range',\n    attr: {\n      min: 0,\n      max: 1,\n      step: 0.02,\n    },\n    displayValue: ({ rotation, sides }) =>\n      `${Math.round((rotation * 180) / sides)}`,\n    isStructural: true,\n    affectsStepCount: false,\n  };\n}\n","import StringArt from '../StringArt';\nimport Circle from '../helpers/Circle';\nimport Polygon from '../helpers/Polygon';\nimport Color from '../helpers/color/Color';\nimport { ColorConfig, ColorMap } from '../helpers/color/color.types';\nimport { ControlsConfig } from '../types/config.types.js';\n\nexport interface FlowerConfig extends ColorConfig {\n  sides: number;\n  n: number;\n  layers: number;\n  rotation: number;\n}\n\nconst COLOR_CONFIG = Color.getConfig({\n  defaults: {\n    isMultiColor: true,\n    color: '#29f1ff',\n    multicolorRange: 132,\n    multicolorStart: 53,\n    multicolorByLightness: false,\n    minLightness: 30,\n    maxLightness: 70,\n  },\n  exclude: ['colorCount'],\n});\n\nexport default class Flower extends StringArt<FlowerConfig> {\n  static type = 'flower';\n\n  name = 'Flower';\n  id = 'flower';\n  link = 'https://www.sqrt.ch/Buch/fadenmodell4_100.svg';\n  controls: ControlsConfig<FlowerConfig> = [\n    {\n      key: 'sides',\n      label: 'Sides',\n      defaultValue: 4,\n      type: 'range',\n      attr: {\n        min: 3,\n        max: 10,\n        step: 1,\n      },\n    },\n    {\n      key: 'n',\n      label: 'Nails per side',\n      defaultValue: 60,\n      type: 'range',\n      attr: {\n        min: 1,\n        max: 100,\n        step: 1,\n      },\n    },\n    {\n      key: 'layers',\n      label: 'Layers',\n      defaultValue: 2,\n      type: 'range',\n      attr: {\n        min: 1,\n        max: 10,\n        step: 1,\n      },\n    },\n    Polygon.rotationConfig,\n    COLOR_CONFIG,\n  ];\n\n  defaultValues = {\n    nailsColor: '#29f1ff',\n    nailRadius: 1,\n    stringWidth: 0.5,\n  };\n\n  #polygons: ReadonlyArray<Polygon>;\n  color: Color;\n  colorMap: ColorMap;\n\n  setUpDraw() {\n    super.setUpDraw();\n    const { n, rotation, sides, layers, margin, isMultiColor } = this.config;\n    const size = this.getSize();\n\n    const layerAngleShift = 1 / (sides * layers);\n\n    this.#polygons = new Array(layers).fill(null).map((_, i) => {\n      const polygonConfig = {\n        sides,\n        rotation: rotation / sides + i * layerAngleShift,\n        margin,\n        size,\n        nailsSpacing: 1 / n,\n      };\n\n      return new Polygon(polygonConfig);\n    });\n\n    this.color = new Color({\n      ...this.config,\n      isMultiColor,\n      colorCount: layers,\n    });\n\n    if (isMultiColor) {\n      this.colorMap = this.color.getColorMap({\n        stepCount: this.getStepCount(),\n        colorCount: layers,\n      });\n    } else {\n      this.colorMap = null;\n    }\n  }\n\n  *generateStrings() {\n    const { sides, layers } = this.config;\n\n    let step = 0;\n    this.renderer.setColor(this.color.getColor(0));\n\n    for (let layer = 0; layer < layers; layer++) {\n      const polygon = this.#polygons[layer];\n\n      for (let side = 0; side < sides; side++) {\n        const leftSide = side === sides - 1 ? 0 : side + 1;\n\n        for (let index = 0; index <= polygon.nailsPerSide; index++) {\n          if (this.colorMap?.has(step)) {\n            this.renderer.setColor(this.colorMap.get(step));\n          }\n\n          const centerIndexes = this.getCenterIndexes({\n            polygon,\n            sideIndex: index,\n          });\n\n          this.renderer.renderLines(\n            polygon.getCenterPoint({\n              side: side,\n              index: centerIndexes[0],\n            }),\n            polygon.getSidePoint({ side, index }),\n            polygon.getCenterPoint({\n              side: leftSide,\n              index: centerIndexes[1],\n            })\n          );\n\n          yield;\n          step++;\n        }\n      }\n    }\n  }\n\n  getCenterIndexes({\n    polygon,\n    sideIndex,\n  }: {\n    polygon: Polygon;\n    sideIndex: number;\n  }): [number, number] {\n    const extraNailCount = polygon.nailsPerSide - polygon.radiusNailsCount;\n\n    return [\n      sideIndex < extraNailCount\n        ? -extraNailCount + sideIndex\n        : sideIndex - extraNailCount,\n      polygon.radiusNailsCount - sideIndex,\n    ];\n  }\n\n  getStepCount(): number {\n    const { sides, n, layers } = this.config;\n    return sides * (n + 1) * layers;\n  }\n\n  drawNails() {\n    const firstNailIndex =\n      this.#polygons[0].radiusNailsCount - this.#polygons[0].nailsPerSide;\n    const filterCenterNails =\n      firstNailIndex > 0 ? (_, index) => index >= firstNailIndex : null;\n\n    this.#polygons.forEach(polygon =>\n      polygon.drawNails(this.nails, { drawCenter: true, filterCenterNails })\n    );\n  }\n\n  static thumbnailConfig = {\n    n: 20,\n  };\n}\n","import StringArt from '../StringArt';\nimport Circle from '../helpers/Circle';\nimport Color from '../helpers/color/Color';\nimport { ColorConfig, ColorMap } from '../helpers/color/color.types';\nimport { gcd, PI2 } from '../helpers/math_utils';\nimport { ControlsConfig } from '../types/config.types.js';\nimport { Coordinates, Dimensions } from '../types/general.types';\n\nexport interface MaurerRoseConfig extends ColorConfig {\n  n: number;\n  maxSteps: number;\n  angle: number;\n  rotation: number;\n}\n\nconst COLOR_CONFIG = Color.getConfig({\n  defaults: {\n    isMultiColor: true,\n    color: '#ffffff',\n    multicolorRange: 102,\n    multicolorStart: 239,\n    multicolorByLightness: false,\n    minLightness: 30,\n    maxLightness: 70,\n    colorCount: 4,\n  },\n  exclude: ['repeatColors', 'mirrorColors'],\n});\n\ninterface TCalc {\n  angleRadians: number;\n  radius: number;\n  currentSize: Dimensions;\n  rotationAngle: number;\n}\n\nexport default class MaurerRose extends StringArt<MaurerRoseConfig> {\n  static type = 'maurer_rose';\n\n  name = 'Maurer Rose';\n  id = 'maurer_rose';\n  link = 'https://blog.glitch.land/en/posts/maurer-rose/';\n  linkText = 'Learn';\n  controls: ControlsConfig<MaurerRoseConfig> = [\n    {\n      key: 'n',\n      label: 'N',\n      defaultValue: 4,\n      type: 'range',\n      attr: {\n        min: 1,\n        max: 12,\n        step: 1,\n      },\n      isStructural: true,\n    },\n    {\n      key: 'maxSteps',\n      label: 'Max steps',\n      defaultValue: 512,\n      type: 'range',\n      attr: {\n        min: 3,\n        max: 720,\n        step: 1,\n      },\n      isStructural: true,\n    },\n    {\n      key: 'angle',\n      label: 'Angle',\n      defaultValue: 341,\n      type: 'range',\n      attr: {\n        min: 1,\n        max: 720,\n        step: 1,\n      },\n      displayValue: ({ angle }) => `${angle}`,\n      isStructural: true,\n    },\n    Circle.rotationConfig,\n    COLOR_CONFIG,\n  ];\n\n  calc: TCalc;\n  points: Map<number, Coordinates>;\n  color: Color;\n  colorMap: ColorMap;\n\n  resetStructure() {\n    super.resetStructure();\n\n    if (this.points) {\n      this.points.clear();\n    }\n    this.calc = null;\n  }\n\n  setUpDraw() {\n    super.setUpDraw();\n    const { isMultiColor, colorCount } = this.config;\n\n    if (!this.calc) {\n      this.calc = this.getCalc();\n    }\n\n    if (!this.points) {\n      this.points = new Map();\n    }\n\n    if (!this.stepCount) {\n      this.stepCount = this.getStepCount();\n    }\n\n    this.color = new Color({\n      ...this.config,\n      isMultiColor,\n      colorCount,\n    });\n\n    if (isMultiColor) {\n      this.colorMap = this.color.getColorMap({\n        stepCount: this.stepCount,\n        colorCount,\n      });\n    } else {\n      this.colorMap = null;\n    }\n  }\n\n  getCalc(): TCalc {\n    const { angle, rotation, maxSteps } = this.config;\n    const size = this.getSize();\n\n    return {\n      angleRadians: (PI2 * angle) / maxSteps,\n      radius: Math.min(...size) / 2,\n      currentSize: size,\n      rotationAngle: -Math.PI * 2 * rotation,\n    };\n  }\n\n  getPoint(index: number): Coordinates {\n    const { rotationAngle, angleRadians, radius } = this.calc;\n\n    if (this.points.has(index)) {\n      return this.points.get(index);\n    }\n\n    const k = index * angleRadians;\n    const r = radius * Math.sin(this.config.n * k);\n\n    const point = [\n      this.center[0] - r * Math.cos(k - rotationAngle),\n      this.center[1] - r * Math.sin(k - rotationAngle),\n    ] as Coordinates;\n    this.points.set(index, point);\n    return point;\n  }\n\n  *generatePoints(): Generator<{ point: Coordinates; index: number }> {\n    const count = this.stepCount;\n\n    for (let i = 0; i < count + 1; i++) {\n      yield { point: this.getPoint(i), index: i };\n    }\n  }\n\n  *generateStrings(): Generator<void> {\n    const points = this.generatePoints();\n\n    let prevPoint: Coordinates;\n    this.renderer.setColor(this.color.getColor(0));\n\n    for (const { point, index } of points) {\n      if (!prevPoint) {\n        prevPoint = point;\n        continue;\n      }\n\n      if (this.colorMap) {\n        const stepColor = this.colorMap.get(index);\n        if (stepColor) {\n          this.renderer.setColor(stepColor);\n        }\n      }\n\n      this.renderer.renderLines(prevPoint, point);\n      prevPoint = point;\n\n      yield;\n    }\n  }\n\n  getStepCount(): number {\n    if (this.stepCount) {\n      return this.stepCount;\n    }\n\n    const { maxSteps, angle, n } = this.config;\n    const angleGcd = gcd(maxSteps, angle);\n\n    let steps = maxSteps / angleGcd;\n    if (!(steps % 2) && n % 2) {\n      steps /= 2;\n    }\n    return Math.round(steps);\n  }\n\n  drawNails() {\n    const points = this.generatePoints();\n    for (const { point, index } of points) {\n      this.nails.addNail({ point, number: index });\n    }\n  }\n\n  static thumbnailConfig = {};\n}\n","import { PI2 } from '../helpers/math_utils';\nimport StringArt from '../StringArt';\nimport Color from '../helpers/color/Color';\nimport Polygon from '../helpers/Polygon';\nimport Circle, { CircleConfig } from '../helpers/Circle';\nimport { formatFractionAsPercent } from '../helpers/string_utils';\nimport {\n  ColorConfig,\n  ColorMap,\n  ColorValue,\n} from '../helpers/color/color.types';\nimport { ControlsConfig, GroupValue } from '../types/config.types';\nimport { Coordinates } from '../types/general.types';\n\ninterface FlowerOfLifeConfig extends ColorConfig {\n  levels: number;\n  density: number;\n  globalRotation: number;\n  fillGroup: GroupValue;\n  fill: boolean;\n  fillColor: ColorValue;\n  ringGroup: GroupValue;\n  renderRing: boolean;\n  ringSize: number;\n  ringNailCount: number;\n  ringPadding: number;\n  ringColor: ColorValue;\n  renderTriangles: boolean;\n  renderCaps: boolean;\n  colorPerLevel: boolean;\n}\n\ninterface TCalc {\n  edgeSize: number;\n  triangleHeight: number;\n  nailsLength: number;\n  triangleCenterDistance: number;\n  nailDistance: number;\n  triangleCount: number;\n  countPerLevelSide: number[];\n  globalRotationRadians: number;\n  radius: number;\n}\n\nconst COLOR_CONFIG = Color.getConfig({\n  defaults: {\n    isMultiColor: true,\n    color: '#29f1ff',\n    multicolorRange: 30,\n    multicolorStart: 25,\n    multicolorByLightness: true,\n    minLightness: 40,\n    maxLightness: 95,\n    colorCount: 3,\n    repeatColors: true,\n    saturation: 83,\n    reverseColors: true,\n  },\n  customControls: [\n    {\n      key: 'colorPerLevel',\n      label: 'Color per level',\n      defaultValue: true,\n      type: 'checkbox',\n    },\n  ],\n});\n\ntype Points = Coordinates[][][][];\n\nconst ANGLE = -PI2 / 6; // The angle of a equilateral triangle;\nconst SIDE_ANGLES = new Array(6)\n  .fill(null)\n  .map((_, i) => Math.PI / 2 + ANGLE * i);\n\nexport default class FlowerOfLife extends StringArt<FlowerOfLifeConfig> {\n  static type = 'flower_of_life';\n\n  name = 'Flower of Life';\n  id = 'flower_of_life';\n  link =\n    'https://www.reddit.com/r/psychedelicartwork/comments/mk97gi/rainbow_flower_of_life_uv_reactive_string_art/';\n  controls: ControlsConfig<FlowerOfLifeConfig> = [\n    {\n      key: 'levels',\n      label: 'Levels',\n      defaultValue: 3,\n      type: 'range',\n      attr: {\n        min: 1,\n        max: 10,\n        step: 1,\n      },\n      isStructural: true,\n    },\n    {\n      key: 'density',\n      label: 'Density',\n      defaultValue: 10,\n      type: 'range',\n      attr: {\n        min: 1,\n\n        max: 50,\n        step: 1,\n      },\n      isStructural: true,\n    },\n    {\n      key: 'globalRotation',\n      label: 'Rotation',\n      defaultValue: 0,\n      type: 'range',\n      attr: {\n        min: 0,\n        max: 30,\n        step: 1,\n      },\n      displayValue: ({ globalRotation }) => `${globalRotation}`,\n      isStructural: true,\n      affectsStepCount: false,\n    },\n    {\n      key: 'fillGroup',\n      label: 'Fill',\n      type: 'group',\n      children: [\n        {\n          key: 'fill',\n          label: 'Show fill',\n          defaultValue: true,\n          type: 'checkbox',\n          isStructural: true,\n        },\n        {\n          key: 'fillColor',\n          label: 'Fill color',\n          defaultValue: '#292e29',\n          type: 'color',\n          show: ({ fill }) => fill,\n        },\n      ],\n    },\n    {\n      key: 'ringGroup',\n      label: 'Ring',\n      type: 'group',\n      children: [\n        {\n          key: 'renderRing',\n          label: 'Show outer ring',\n          type: 'checkbox',\n          defaultValue: true,\n          isStructural: true,\n        },\n        {\n          key: 'ringNailCount',\n          label: 'Ring nail count',\n          defaultValue: 144,\n          type: 'range',\n          attr: {\n            min: 3,\n            max: 360,\n            step: 1,\n          },\n          show: ({ renderRing }) => renderRing,\n          isStructural: true,\n        },\n        {\n          key: 'ringSize',\n          label: 'Outer ring size',\n          defaultValue: 0.23,\n          type: 'range',\n          attr: {\n            min: 0,\n            max: 0.5,\n            step: 0.01,\n          },\n          show: ({ renderRing }) => renderRing,\n          displayValue: ({ ringSize }) => formatFractionAsPercent(ringSize),\n          isStructural: true,\n        },\n        {\n          key: 'ringPadding',\n          label: 'Ring padding',\n          defaultValue: 0.06,\n          type: 'range',\n          attr: {\n            min: 0,\n            max: 0.5,\n            step: 0.01,\n          },\n          show: ({ renderRing }) => renderRing,\n          isStructural: true,\n          displayValue: ({ ringPadding }) =>\n            formatFractionAsPercent(ringPadding),\n        },\n        {\n          key: 'ringColor',\n          label: 'Ring color',\n          defaultValue: '#e8b564',\n          type: 'color',\n          show: ({ renderRing }) => renderRing,\n        },\n      ],\n    },\n    {\n      key: 'renderTriangles',\n      label: 'Show triangles',\n      defaultValue: true,\n      type: 'checkbox',\n      isStructural: true,\n    },\n    {\n      key: 'renderCaps',\n      label: 'Show caps',\n      defaultValue: true,\n      type: 'checkbox',\n      show: ({ renderTriangles }) => renderTriangles,\n      isStructural: true,\n    },\n    COLOR_CONFIG,\n  ];\n\n  defaultValues = {\n    nailsColor: '#474747',\n  };\n\n  #calc: TCalc;\n  points: Points;\n  color: Color;\n  colorMap: ColorMap;\n  #circle: Circle;\n\n  getCalc(): TCalc {\n    const {\n      levels,\n      density,\n      margin,\n      globalRotation,\n      renderCaps,\n      renderRing,\n      ringNailCount,\n      ringSize,\n      ringPadding,\n    } = this.config;\n    const globalRotationRadians =\n      (globalRotation * Math.PI) / 180 + Math.PI / 6;\n\n    const radius = renderRing\n      ? Math.min(...(this.size ?? this.getSize()).map(v => v / 2 - margin))\n      : null;\n    const ringDistance = renderRing\n      ? Math.floor((ringSize * ringNailCount) / 2)\n      : 0; // The number of nails to count for strings in the outer ring\n    const ringWidth = renderRing\n      ? radius * (1 - Math.cos((PI2 * (ringDistance / ringNailCount)) / 2))\n      : 0;\n\n    const polygon = new Polygon({\n      sides: 6,\n      size: this.getSize(),\n      margin:\n        margin +\n        ringWidth +\n        (renderRing && ringSize ? ringPadding * radius : 0),\n      rotation: globalRotationRadians,\n      fitSize: false,\n      nailsSpacing: 2,\n    });\n\n    const edgeSize = polygon.sideSize / levels;\n    const nailsLength = edgeSize / (2 * Math.cos(Math.PI / 6));\n\n    const countPerLevelSide = new Array(levels + (renderCaps ? 1 : 0))\n      .fill(null)\n      .map((_, level) => level * 2 + 1);\n\n    return {\n      edgeSize,\n      triangleHeight: (edgeSize * Math.sqrt(3)) / 2,\n      nailsLength,\n      triangleCenterDistance: edgeSize / 2,\n      nailDistance: nailsLength / density,\n      triangleCount: 6 * levels ** 2,\n      countPerLevelSide,\n      globalRotationRadians,\n      radius,\n    };\n  }\n\n  resetStructure() {\n    super.resetStructure();\n\n    this.points = null;\n    this.#calc = null;\n  }\n\n  setUpDraw() {\n    super.setUpDraw();\n\n    const {\n      isMultiColor,\n      levels,\n      colorPerLevel,\n      colorCount,\n      renderRing,\n      ringSize,\n      ringNailCount,\n      ...config\n    } = this.config;\n\n    if (!this.#calc) {\n      this.#calc = this.getCalc();\n    }\n\n    if (renderRing && ringSize) {\n      const circleConfig: CircleConfig = {\n        size: this.size,\n        n: ringNailCount,\n        margin: config.margin,\n        rotation: config.globalRotation,\n      };\n\n      if (this.#circle) {\n        this.#circle.setConfig(circleConfig);\n      } else {\n        this.#circle = new Circle(circleConfig);\n      }\n    } else {\n      this.#circle = null;\n    }\n\n    if (!this.points) {\n      this.points = this.getPoints();\n    }\n\n    if (!this.stepCount) {\n      this.stepCount = this.getStepCount(this.#calc);\n    }\n\n    const realColorCount = isMultiColor\n      ? colorPerLevel\n        ? levels\n        : Math.min(colorCount, levels)\n      : 1;\n\n    this.color = new Color({\n      ...config,\n      isMultiColor,\n      colorCount: realColorCount,\n    });\n\n    if (isMultiColor) {\n      this.colorMap = this.color.getColorMap({\n        stepCount: realColorCount,\n        colorCount: realColorCount,\n      });\n    } else {\n      this.colorMap = null;\n    }\n  }\n\n  getTrianglePoints({\n    center,\n    rotation,\n    isCapLevel,\n    triangleIndexInSide,\n  }: {\n    center: Coordinates;\n    rotation: number;\n    isCapLevel: boolean;\n    triangleIndexInSide: number;\n  }): Coordinates[][] {\n    let missingSide: number;\n    if (isCapLevel) {\n      const triangleIndex = (triangleIndexInSide + 2) % 3;\n      missingSide = this.#getNextIndexInTriangle(triangleIndex);\n    }\n\n    // For each side of the triangle, the first point is the center of the triangle:\n    const trianglePoints = new Array(3)\n      .fill(null)\n      .map((_, i) => (i === missingSide ? [] : [center]));\n\n    for (let side = 0; side < 3; side++) {\n      if (isCapLevel && side === missingSide) {\n        continue;\n      }\n      const sideAngle = rotation + side * (PI2 / 3);\n      const triangleSidePoints = trianglePoints[side];\n\n      const cosSideAngle = Math.cos(sideAngle);\n      const sinSideAngle = Math.sin(sideAngle);\n\n      for (let n = 1; n <= this.config.density; n++) {\n        const nNailDistance = n * this.#calc.nailDistance;\n\n        triangleSidePoints.push([\n          center[0] + nNailDistance * cosSideAngle,\n          center[1] + nNailDistance * sinSideAngle,\n        ]);\n      }\n    }\n\n    return trianglePoints;\n  }\n\n  getPoints(): Points {\n    if (this.points) {\n      return this.points;\n    }\n\n    const { levels, renderCaps } = this.config;\n\n    const largeDistance = this.#calc.nailsLength;\n    const smallDistance = this.#calc.triangleHeight - largeDistance;\n    const levelsPoints: Points = [];\n\n    const levelsCount = renderCaps ? levels + 1 : levels;\n\n    for (let level = 0; level < levelsCount; level++) {\n      const isCapLevel = renderCaps && level === levels;\n\n      const levelTrianglesPoints: Coordinates[][][] = [];\n      levelsPoints.push(levelTrianglesPoints);\n\n      const levelSideTriangleCount = this.#calc.countPerLevelSide[level];\n\n      // Caching distances to avoid repeated calculations for each side:\n      const levelPositions = new Array(levelSideTriangleCount)\n        .fill(null)\n        .map((_, n) => {\n          const isFlipped = n % 2 === 0;\n          const trianglePosition = [\n            this.#calc.triangleCenterDistance * (n - level),\n            level * this.#calc.triangleHeight +\n              (isFlipped ? largeDistance : smallDistance),\n          ];\n\n          return {\n            rotation: Math.atan(trianglePosition[0] / trianglePosition[1]),\n            distanceFromCenter: Math.sqrt(\n              trianglePosition[0] ** 2 + trianglePosition[1] ** 2\n            ),\n          };\n        });\n\n      for (let side = 0; side < 6; side++) {\n        const sideRotation = SIDE_ANGLES[side];\n\n        for (let n = 0; n < levelSideTriangleCount; n++) {\n          if (isCapLevel && n % 2 === 0) {\n            // Cap triangles are only odd indexes\n            levelTrianglesPoints.push(null);\n            continue;\n          }\n\n          const { distanceFromCenter, rotation } = levelPositions[n];\n\n          const triangleCenterAngle =\n            sideRotation - rotation - this.#calc.globalRotationRadians;\n\n          const rotatedTrianglePosition = [\n            this.center[0] + distanceFromCenter * Math.cos(triangleCenterAngle),\n            this.center[1] - distanceFromCenter * Math.sin(triangleCenterAngle),\n          ] as Coordinates;\n\n          const trianglePoints = this.getTrianglePoints({\n            center: rotatedTrianglePosition,\n            rotation:\n              sideRotation +\n              (side * PI2) / 3 -\n              n * ANGLE +\n              this.#calc.globalRotationRadians,\n            isCapLevel,\n            triangleIndexInSide: n,\n          });\n\n          levelTrianglesPoints.push(trianglePoints);\n        }\n      }\n    }\n\n    return levelsPoints;\n  }\n\n  *generateTriangleStrings({\n    points,\n    level,\n    indexInSide,\n  }: {\n    points: Coordinates[][];\n    level: number;\n    indexInSide: number;\n  }): Generator<void> {\n    this.renderer.setColor(this.color.getColor(level));\n    const { density, levels } = this.config;\n    const isCapLevel = level === levels;\n\n    const initialSide = isCapLevel\n      ? this.#getNextIndexInTriangle(indexInSide % 3)\n      : 0;\n    const lastSide = isCapLevel ? initialSide : 2;\n    const lastIndex = isCapLevel ? density : density - 1;\n\n    for (let side = initialSide; side <= lastSide; side++) {\n      const nextSide = this.#getNextIndexInTriangle(side);\n      let prevPoint = points[side][0];\n\n      for (let n = 0; n <= lastIndex; n++) {\n        const isNextSide = n % 2 === 0;\n\n        const positions = [];\n        const nextSidePoint = isNextSide ? this.config.density - n : n;\n        const targetSide = isNextSide ? nextSide : side;\n        positions.push(points[targetSide][nextSidePoint]);\n\n        if (n < density) {\n          positions.push(\n            points[targetSide][\n              isNextSide ? nextSidePoint - 1 : nextSidePoint + 1\n            ]\n          );\n        }\n\n        this.renderer.renderLines(prevPoint, ...positions);\n        prevPoint = positions[positions.length - 1];\n\n        yield;\n      }\n    }\n  }\n\n  *generateStringsBetweenTriangles({\n    triangle1,\n    triangle2,\n    level,\n    triangleIndex,\n    triangleIndexInSide,\n    isNextLevel,\n  }: {\n    triangle1: Coordinates[][];\n    triangle2: Coordinates[][];\n    level: number;\n    triangleIndex: number;\n    triangleIndexInSide: number;\n    isNextLevel?: boolean;\n  }): Generator<void> {\n    const { density, fillColor } = this.config;\n    const levelSideCount = this.#calc.countPerLevelSide[level];\n    const angleShift = (triangleIndex % levelSideCount) % 3;\n\n    this.renderer.setColor(fillColor);\n\n    const isLastTriangleInSide = triangleIndexInSide === levelSideCount - 1;\n    const firstSide = angleShift;\n\n    const sideIndex = isNextLevel\n      ? [\n          this.#getNextIndexInTriangle(angleShift),\n          this.#getNextIndexInTriangle(angleShift, -1),\n        ]\n      : [\n          firstSide,\n          this.#getNextIndexInTriangle(\n            firstSide,\n            triangleIndexInSide % 2 ? 1 : -1\n          ),\n        ];\n\n    for (let s = 0; s < 2; s++) {\n      const order = generateOrderInSide.call(this, s);\n\n      for (const { pointIndex, triangle1Points, triangle2Points } of order) {\n        this.renderer.renderLines(\n          triangle1Points[pointIndex],\n          triangle2Points[pointIndex]\n        );\n\n        yield;\n      }\n    }\n\n    function* generateOrderInSide(side: number): Generator<{\n      pointIndex: number;\n      triangle1Points: Coordinates[];\n      triangle2Points: Coordinates[];\n    }> {\n      const t1Side = sideIndex[side];\n      const t2Side = getNextTriangleSide.call(this);\n\n      const triangle1Points = triangle1[t1Side];\n      const triangle2Points = triangle2[t2Side];\n\n      const last = side ? density : density - 1;\n\n      if (side === 0) {\n        for (let n = 0; n <= last; n++) {\n          yield { pointIndex: density - n, triangle1Points, triangle2Points };\n        }\n      } else {\n        for (let n = last; n >= 1; n--) {\n          yield { pointIndex: density - n, triangle1Points, triangle2Points };\n        }\n      }\n\n      function getNextTriangleSide() {\n        if (isNextLevel) {\n          return this.#getNextIndexInTriangle(t1Side);\n        } else {\n          if (side === 0 && isLastTriangleInSide) {\n            return 1;\n          } else {\n            if (side === 1 && isLastTriangleInSide) {\n              return 0;\n            } else {\n              return this.#getNextIndexInTriangle(t1Side, 1);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  #getNextIndexInTriangle(index: number, direction = 1): number {\n    const result = index + direction;\n    if (result < 0) {\n      return 2;\n    }\n    if (result > 2) {\n      return 0;\n    }\n    return result;\n  }\n\n  *generateStrings(): Generator<void> {\n    const {\n      fill,\n      renderTriangles,\n      renderCaps,\n      levels,\n      renderRing,\n      ringSize,\n      ringColor,\n    } = this.config;\n\n    const triangleLevels = this.getPoints();\n\n    let levelIndex = -1;\n\n    for (const level of triangleLevels) {\n      levelIndex++;\n      const isCapLevel = levelIndex === levels;\n\n      let triangleIndex = -1;\n      const lastIndexInLevel = level.length - 1;\n\n      for (const triangle of level) {\n        triangleIndex++;\n        const levelSideCount = this.#calc.countPerLevelSide[levelIndex];\n        const triangleIndexInSide = triangleIndex % levelSideCount;\n\n        if (fill && !isCapLevel) {\n          if (triangleIndex === 0) {\n            yield* this.generateStringsBetweenTriangles({\n              triangle1: level[lastIndexInLevel],\n              triangle2: triangle,\n              level: levelIndex,\n              triangleIndex: lastIndexInLevel,\n              triangleIndexInSide: lastIndexInLevel % levelSideCount,\n            });\n          }\n          if (triangleIndex !== lastIndexInLevel) {\n            yield* this.generateStringsBetweenTriangles({\n              triangle1: triangle,\n              triangle2: level[triangleIndex + 1],\n              level: levelIndex,\n              triangleIndex,\n              triangleIndexInSide,\n            });\n          }\n\n          if (\n            triangleIndexInSide % 2 === 0 &&\n            (renderCaps || levelIndex < levels - 1)\n          ) {\n            const side = Math.floor(triangleIndex / levelSideCount);\n            const nextLevelSideCount =\n              this.#calc.countPerLevelSide[levelIndex + 1];\n            const nextLevelTriangleIndex =\n              side * nextLevelSideCount + triangleIndexInSide + 1;\n\n            yield* this.generateStringsBetweenTriangles({\n              triangle1: triangle,\n              triangle2: triangleLevels[levelIndex + 1][nextLevelTriangleIndex],\n              level: levelIndex,\n              triangleIndex,\n              triangleIndexInSide,\n              isNextLevel: true,\n            });\n          }\n        }\n\n        const indexInSide =\n          triangleIndex % this.#calc.countPerLevelSide[levelIndex];\n\n        if (renderTriangles && (!isCapLevel || indexInSide % 2)) {\n          yield* this.generateTriangleStrings({\n            points: triangle,\n            level: levelIndex,\n            indexInSide,\n          });\n        }\n      }\n    }\n\n    if (renderRing && ringSize) {\n      yield* this.#circle.drawRing(this.renderer, {\n        ringSize: ringSize / 2,\n        color: ringColor,\n      });\n    }\n  }\n\n  getStepCount(calc?: TCalc): number {\n    if (this.stepCount) {\n      return this.stepCount;\n    }\n\n    if (!calc) {\n      calc = this.getCalc();\n    }\n\n    const {\n      levels,\n      density,\n      fill,\n      renderTriangles,\n      renderCaps,\n      ringNailCount = 0,\n    } = this.config;\n    const { triangleCount } = calc;\n\n    const fillStepsPerTriangle = fill ? density * 2 : 0;\n    const triangleSteps = renderTriangles ? density * 3 : 0;\n\n    const stepsPerTriangle = triangleSteps + fillStepsPerTriangle;\n\n    const levelsWithFillBetween = levels + (renderCaps ? 1 : 0);\n    const fillStepsBetweenLevels =\n      (fillStepsPerTriangle *\n        (levelsWithFillBetween - 1) *\n        6 *\n        levelsWithFillBetween) /\n      2;\n    const stepsPerCap = density + 1;\n    const capSteps =\n      renderTriangles && renderCaps ? 6 * levels * stepsPerCap : 0;\n\n    return (\n      triangleCount * stepsPerTriangle +\n      capSteps +\n      fillStepsBetweenLevels +\n      ringNailCount\n    );\n  }\n\n  drawNails() {\n    const triangleLevels = this.getPoints();\n    let index = 0;\n    for (const level of triangleLevels) {\n      for (const triangle of level) {\n        if (triangle != null) {\n          // A cap level has nulls between caps\n          for (const triangleSide of triangle) {\n            for (const point of triangleSide) {\n              this.nails.addNail({ point, number: index++ });\n            }\n          }\n        }\n      }\n    }\n\n    if (this.#circle) {\n      this.#circle.drawNails(this.nails);\n    }\n  }\n\n  static thumbnailConfig = {\n    levels: 3,\n    density: 3,\n    fill: false,\n    renderRing: true,\n  };\n}\n","import StringArt from '../StringArt.js';\nimport Circle, { CircleConfig } from '../helpers/Circle.js';\nimport Color from '../helpers/color/Color.js';\nimport { ColorConfig } from '../helpers/color/color.types.js';\nimport { PI2 } from '../helpers/math_utils.js';\nimport { ControlsConfig } from '../types/config.types.js';\n\ntype SpreadModeType = 'evenly' | 'distance';\n\ninterface CometConfig extends CircleConfig, ColorConfig {\n  layers: number;\n  ringSize: number;\n  layerSpread: SpreadModeType;\n  layerDistance: number;\n  colorPerLayer: boolean;\n}\n\ninterface SpreadMode {\n  f: (layerIndex: number, config: CometConfig) => number;\n  name: string;\n}\n\nconst spreadModes: Record<SpreadModeType, SpreadMode> = {\n  evenly: {\n    f: (layerIndex, { ringSize, layers, n }) => {\n      const firstLayerDistance = Math.floor(n * ringSize);\n      return Math.floor(((layers - layerIndex) * firstLayerDistance) / layers);\n    },\n    name: 'Evenly',\n  },\n  distance: {\n    f: (layerIndex, { n, ringSize, layerDistance }) => {\n      const firstLayerDistance = Math.floor(n * ringSize);\n\n      if (layerIndex > 0) {\n        return firstLayerDistance - layerIndex * layerDistance;\n      }\n\n      return firstLayerDistance;\n    },\n    name: 'Specific distance',\n  },\n};\n\nconst COLOR_CONFIG = Color.getConfig({\n  defaults: {\n    isMultiColor: true,\n    color: '#ff0000',\n    multicolorRange: 133,\n    multicolorStart: 239,\n    multicolorByLightness: false,\n    minLightness: 30,\n    maxLightness: 70,\n    colorCount: 4,\n  },\n  customControls: [\n    {\n      key: 'colorPerLayer',\n      label: 'Color per layer',\n      defaultValue: true,\n      type: 'checkbox',\n    },\n  ],\n});\n\nexport default class Comet extends StringArt<CometConfig> {\n  static type = 'comet';\n\n  name = 'Comet';\n  id = 'comet';\n  controls: ControlsConfig<CometConfig> = [\n    Circle.nailsConfig,\n    {\n      key: 'layers',\n      label: 'Layers',\n      defaultValue: 5,\n      type: 'range',\n      attr: {\n        min: 1,\n        max: 20,\n        step: 1,\n      },\n      isStructural: true,\n    },\n    {\n      key: 'ringSize',\n      label: 'First layer size',\n      description:\n        'Nail count from the top center nail to the first connected nail in the first layer',\n      defaultValue: 0.3,\n      type: 'range',\n      attr: {\n        min: 0,\n        max: 1,\n        step: 0.01,\n      },\n      displayValue: ({ ringSize, n }) => Math.floor(n * ringSize),\n      isStructural: true,\n    },\n    {\n      key: 'layerSpread',\n      label: 'Layer Spread',\n      type: 'select',\n      defaultValue: 'distance',\n      options: Object.entries(spreadModes).map(([key, { name }]) => ({\n        value: key,\n        label: name,\n      })),\n      isStructural: true,\n    },\n    {\n      key: 'layerDistance',\n      label: 'Layer Distance',\n      type: 'range',\n      attr: {\n        min: 1,\n        max: ({ n, layers }) => Math.floor(n / 2 / layers),\n        step: 1,\n      },\n      defaultValue: 1,\n      isStructural: true,\n      show: ({ layerSpread }) => layerSpread !== 'evenly',\n    },\n    Circle.rotationConfig,\n    Circle.distortionConfig,\n    Circle.displacementConfig,\n    COLOR_CONFIG,\n  ];\n\n  defaultValues: Partial<CometConfig> = {\n    n: 51,\n    layers: 11,\n    colorPerLayer: true,\n    multicolorRange: 203,\n    multicolorStart: 137,\n    ringSize: 0.47,\n    rotation: 90 / 360,\n    distortion: 0.38,\n    displacementFunc: 'fastInOut',\n    displacementMag: 1.8,\n    displacementFastArea: 0.43,\n    layerSpread: 'distance',\n    layerDistance: 1,\n  };\n\n  #circle: Circle;\n  color: Color;\n\n  setUpDraw() {\n    super.setUpDraw();\n    const circleConfig = {\n      size: this.size,\n      n: this.config.n,\n      margin: this.config.margin,\n      rotation: this.config.rotation,\n      distortion: this.config.distortion,\n      displacementFunc: this.config.displacementFunc,\n      displacementMag: this.config.displacementMag,\n      displacementFastArea: this.config.displacementFastArea,\n    };\n\n    if (this.#circle) {\n      this.#circle.setConfig(circleConfig);\n    } else {\n      this.#circle = new Circle(circleConfig);\n    }\n\n    if (!this.stepCount) {\n      this.stepCount = this.getStepCount();\n    }\n\n    const { isMultiColor, colorCount, layers, colorPerLayer } = this.config;\n    const realColorCount = isMultiColor\n      ? colorPerLayer\n        ? layers\n        : Math.min(colorCount, layers)\n      : 1;\n\n    this.color = new Color({\n      ...this.config,\n      isMultiColor,\n      colorCount: realColorCount,\n    });\n  }\n\n  getLayerRingDistance(layerIndex: number): number {\n    const spread = spreadModes[this.config.layerSpread];\n    if (!spread) {\n      throw new Error(`Invalid spread mode, \"${this.config.layerSpread}\"!`);\n    }\n\n    return spread.f(layerIndex, this.config);\n  }\n\n  getLayerRingStepCount(layerIndex: number): number {\n    const layerRingDistance = this.getLayerRingDistance(layerIndex);\n    return (this.config.n - layerRingDistance + 1) * 2 - 1;\n  }\n\n  *drawLayer(layerIndex = 0): Generator<void> {\n    const { n } = this.config;\n    const ringDistance = this.getLayerRingDistance(layerIndex);\n    const stepCount = n - ringDistance + 1;\n\n    let prevPoint = this.#circle.getPoint(0);\n    let prevPointIndex = 0;\n    this.renderer.setColor(this.color.getColor(layerIndex));\n\n    for (let i = 0; i < n - ringDistance + 1; i++) {\n      const pointIndex = i + ringDistance;\n      const point = this.#circle.getPoint(pointIndex);\n\n      this.renderer.renderLines(prevPoint, point);\n      yield;\n\n      if (i !== stepCount - 1) {\n        prevPointIndex = i + 1;\n        prevPoint = this.#circle.getPoint(prevPointIndex);\n\n        this.renderer.renderLines(point, prevPoint);\n\n        yield;\n      }\n    }\n  }\n\n  *generateStrings() {\n    for (let layer = 0; layer < this.config.layers; layer++) {\n      yield* this.drawLayer(layer);\n    }\n  }\n\n  getStepCount(): number {\n    if (this.stepCount) {\n      return this.stepCount;\n    }\n\n    const { layers } = this.config;\n    return new Array(layers)\n      .fill(0)\n      .reduce(\n        (totalStepCount, _, layerIndex) =>\n          totalStepCount + this.getLayerRingStepCount(layerIndex),\n        0\n      );\n  }\n\n  drawNails() {\n    this.#circle.drawNails(this.nails);\n  }\n\n  static thumbnailConfig = {\n    n: 24,\n    layers: 8,\n  };\n}\n","import StringArt from '../StringArt';\nimport Circle, { CircleConfig } from '../helpers/Circle';\nimport Color from '../helpers/color/Color';\nimport StarShape, { StarShapeConfig } from '../helpers/StarShape';\nimport { insertAfter } from '../helpers/config_utils';\nimport { mapKeys } from '../helpers/object_utils';\nimport { formatFractionAsPercent } from '../helpers/string_utils';\nimport type {\n  ControlConfig,\n  ControlsConfig,\n  GroupValue,\n} from '../types/config.types';\nimport { ColorConfig, ColorValue } from '../helpers/color/color.types';\nimport { Coordinates } from '../types/general.types';\n\ninterface SunConfig extends StarShapeConfig, ColorConfig {\n  layers: number;\n  layerSpread: number;\n  starRadius: number;\n  backdrop: GroupValue;\n  backdropColorCount: number;\n  backdropNailsRadius: number;\n  backdropSize: number;\n  backdropRadius: number;\n  backdropShift: number;\n  backdropSkip: boolean;\n  backdropNailsColor: ColorValue;\n  backdropIsMultiColor: boolean;\n  starGroup: GroupValue;\n}\n\ninterface TCalc {\n  backdropNails: number;\n}\n\nexport default class Sun extends StringArt<SunConfig> {\n  static type = 'sun';\n\n  name = 'Sun';\n  id = 'sun';\n  controls: ControlsConfig<SunConfig> = [\n    {\n      key: 'starGroup',\n      label: 'Star',\n      type: 'group',\n      children: [\n        ...insertAfter<SunConfig>(\n          [\n            ...StarShape.StarConfig,\n            Color.getConfig({\n              defaults: {\n                isMultiColor: true,\n                multicolorRange: 1,\n                multicolorStart: 237,\n                color: '#ffffff',\n                saturation: 40,\n                multicolorByLightness: true,\n                minLightness: 20,\n                maxLightness: 97,\n              },\n              exclude: ['colorCount'],\n            }),\n          ],\n          'sides',\n          [\n            {\n              key: 'layers',\n              label: 'Layers',\n              defaultValue: 4,\n              type: 'range',\n              attr: {\n                min: 1,\n                max: 20,\n                step: 1,\n              },\n              isStructural: true,\n            },\n            {\n              key: 'layerSpread',\n              label: 'Layer spread',\n              defaultValue: 0.1625,\n              type: 'range',\n              displayValue: ({ layerSpread }) =>\n                formatFractionAsPercent(layerSpread),\n              attr: {\n                min: 0.01,\n                max: 1,\n                step: 0.02,\n              },\n              show: ({ layers }) => layers !== 1,\n              isStructural: true,\n            },\n            {\n              key: 'starRadius',\n              label: 'Star Radius',\n              defaultValue: 1,\n              type: 'range',\n              displayValue: ({ starRadius }) =>\n                formatFractionAsPercent(starRadius),\n              attr: {\n                min: 0.2,\n                max: 1,\n                step: 0.01,\n              },\n              isStructural: true,\n              affectsStepCount: false,\n            },\n          ]\n        ),\n      ],\n    },\n    {\n      key: 'backdrop',\n      label: 'Backdrop',\n      type: 'group',\n      children: [\n        {\n          key: 'backdropSize',\n          label: 'Backdrop size',\n          defaultValue: 0.5,\n          type: 'range',\n          displayValue: ({ backdropSize }) =>\n            formatFractionAsPercent(backdropSize),\n          attr: {\n            min: 0,\n            max: 1,\n            step: ({ sideNails }) => 1 / sideNails,\n          },\n          isStructural: true,\n        },\n        {\n          key: 'backdropRadius',\n          label: 'Backdrop radius',\n          defaultValue: 1,\n          type: 'range',\n          displayValue: ({ backdropRadius }) =>\n            formatFractionAsPercent(backdropRadius),\n          attr: {\n            min: 0,\n            max: 1,\n            step: 0.01,\n          },\n          isStructural: true,\n          affectsStepCount: false,\n        },\n        {\n          key: 'backdropShift',\n          label: 'Backdrop shift',\n          defaultValue: 0,\n          type: 'range',\n          displayValue: ({ backdropShift }) =>\n            formatFractionAsPercent(backdropShift),\n          attr: {\n            min: 0,\n            max: 1,\n            step: ({ sideNails, backdropSize }) =>\n              (1 / (sideNails * (1 - backdropSize))).toFixed(3),\n          },\n          isStructural: true,\n          affectsStepCount: false,\n        },\n        {\n          key: 'backdropSkip',\n          label: 'Backdrop skip',\n          description:\n            \"If yes, connections in the backdrop are from the backdrop's nail to the second-nearest side, not the ones near it\",\n          defaultValue: false,\n          type: 'checkbox',\n          isStructural: true,\n          affectsStepCount: false,\n          show: ({ sides }) => sides > 3,\n        },\n        Color.getConfig<SunConfig>({\n          defaults: {\n            isMultiColor: true,\n            multicolorRange: 20,\n            multicolorStart: 0,\n            color: '#ffffff',\n            saturation: 57,\n            multicolorByLightness: true,\n            minLightness: 20,\n            maxLightness: 40,\n          },\n          propMapper: ({ key, show }) => {\n            const newKey = 'backdrop' + key[0].toUpperCase() + key.slice(1);\n            const control: Partial<ControlConfig<any>> = {\n              key: 'backdrop' + key[0].toUpperCase() + key.slice(1),\n              show: show\n                ? ({ backdropIsMultiColor }) =>\n                    key === 'color'\n                      ? !backdropIsMultiColor\n                      : backdropIsMultiColor\n                : null,\n            };\n\n            if (key === 'multicolorRange') {\n              control.attr = {\n                start: ({ backdropMulticolorStart }) => backdropMulticolorStart,\n                type: 'range',\n              };\n            }\n            return control;\n          },\n          groupLabel: 'Backdrop color',\n          maxColorCount: 2,\n        }),\n      ],\n    },\n  ];\n\n  getCommonControls(): ControlsConfig<Partial<SunConfig>> {\n    return insertAfter<Partial<SunConfig>>(\n      super.getCommonControls(),\n      'nailsColor',\n      [\n        {\n          key: 'backdropNailsColor',\n          label: 'Backdrop nails color',\n          type: 'color',\n          defaultValue: '#ffffff',\n          show: ({ showNails }) => showNails,\n        },\n        {\n          key: 'backdropNailsRadius',\n          label: 'Backdrop nails radius',\n          type: 'range',\n          defaultValue: 1.5,\n          attr: { min: 0.5, max: 5, step: 0.25 },\n          show: ({ showNails }) => showNails,\n        },\n      ]\n    );\n  }\n\n  #circle: Circle = null;\n  #star: StarShape = null;\n  #calc: TCalc;\n  #color: Color;\n  #backdropColor: Color;\n\n  defaultValues = {\n    sideNails: 50,\n    sides: 16,\n    layers: 4,\n    layerSpread: 0.77,\n    backdropSize: 0.26,\n    backdropRadius: 0.9,\n    backdropShift: 0.59,\n    backdropColorCount: 2,\n    centerRadius: 0.2,\n    maxCurveSize: 32 / 50,\n    rotation: 0.5,\n    saturation: 73,\n    multicolorStart: 206,\n    multicolorRange: 1,\n    multicolorByLightness: true,\n    minLightness: 35,\n    maxLightness: 100,\n    nailsColor: '#000000',\n    backdropNailsColor: '#ffffff',\n    backdropNailsRadius: 2.275,\n  };\n\n  getCalc(): TCalc {\n    const { sideNails, backdropSize, layers } = this.config;\n\n    return {\n      backdropNails: Math.floor(sideNails * backdropSize),\n    };\n  }\n\n  resetStructure() {\n    super.resetStructure();\n\n    this.#calc = null;\n  }\n\n  setUpDraw() {\n    super.setUpDraw();\n\n    const {\n      margin = 0,\n      layers,\n      backdropRadius: backdropRadiusConfig = 1,\n      backdropSize,\n      rotation,\n      sides,\n      starRadius: starRadiusConfig = 1,\n      backdropColorCount,\n    } = this.config;\n    const center = this.size.map(v => v / 2);\n    const radius = Math.min(...center) - margin;\n    const starRadius =\n      backdropSize && starRadiusConfig < backdropRadiusConfig\n        ? (radius * starRadiusConfig) / backdropRadiusConfig\n        : radius;\n    const backdropRadius =\n      backdropRadiusConfig < starRadiusConfig\n        ? (radius * backdropRadiusConfig) / starRadiusConfig\n        : radius;\n\n    if (!this.#calc) {\n      this.#calc = this.getCalc();\n    }\n\n    const starConfig: StarShapeConfig = {\n      ...this.config,\n      radius: starRadius,\n      size: this.size,\n    };\n\n    if (this.#star) {\n      this.#star.setConfig(starConfig);\n    } else {\n      this.#star = new StarShape(starConfig);\n    }\n\n    this.#color = new Color({\n      ...this.config,\n      colorCount: layers,\n    });\n\n    // @ts-ignore this is fine for now, until the color config is managed in a single control\n    this.#backdropColor = new Color({\n      ...mapKeys(this.config, key => {\n        const match = key.match(/^backdrop(\\w)(.+)/);\n        return match ? match[1].toLowerCase() + match[2] : key;\n      }),\n      colorCount: backdropColorCount,\n    });\n    const circleConfig: CircleConfig = {\n      size: this.size,\n      n: sides,\n      rotation: -1 / sides / 2 + (rotation ? rotation / sides : 0),\n      radius: backdropRadius,\n    };\n\n    if (this.#circle) {\n      this.#circle.setConfig(circleConfig);\n    } else {\n      this.#circle = new Circle(circleConfig);\n    }\n  }\n\n  *drawStar(size?: number): Generator<void> {\n    yield* this.#star.generateStrings(this.renderer, { size });\n  }\n\n  *generateLayers(): Generator<void> {\n    const { sideNails, layerSpread, layers } = this.config;\n\n    for (let layer = 0; layer < layers; layer++) {\n      const color = this.#color.getColor(layer);\n      this.renderer.setColor(color);\n\n      const layerSize = this.#getLayerSize(layer);\n      yield* this.drawStar(layerSize);\n    }\n  }\n\n  *drawBackdrop(): Generator<void> {\n    // For each side, add a nail between two star sides, at the specified backdropRadius.\n    // For the backdrop size, connect the nail to the number of points in the star for the two sides near the backdrop nail\n\n    const { backdropNails } = this.#calc;\n    const { sides, backdropShift, sideNails, backdropSkip } = this.config;\n\n    const shouldSkip = backdropSkip && sides > 3;\n    let prevPoint: Coordinates;\n    let currentSide = 0;\n    const shift = Math.floor(backdropShift * (sideNails - backdropNails));\n\n    let currentSideIndex = shift + backdropNails - 1;\n\n    for (let side = 0; side < sides; side++) {\n      this.renderer.setColor(this.#backdropColor.getColor(side % 2 ? 0 : 1));\n      const backdropPoint = this.#circle.getPoint(\n        shouldSkip ? (side + 1) % sides : side\n      );\n      let alternate = false;\n      const direction = side % 2 ? 1 : -1; // 1 if backdrop threading starts at the bottom and goes up, -1 if it goes down\n      prevPoint = this.#star.getPoint(side, currentSideIndex);\n\n      for (let i = 0; i < backdropNails; i++) {\n        this.renderer.renderLines(prevPoint, backdropPoint);\n        yield;\n\n        currentSide = (alternate ? side : side + (shouldSkip ? 3 : 1)) % sides;\n        prevPoint = this.#star.getPoint(currentSide, currentSideIndex);\n        this.renderer.renderLines(backdropPoint, prevPoint);\n        yield;\n\n        if (i < backdropNails - 1) {\n          alternate = !alternate;\n          currentSideIndex += direction;\n          const nextPoint = this.#star.getPoint(currentSide, currentSideIndex);\n          this.renderer.renderLines(prevPoint, nextPoint);\n          prevPoint = nextPoint;\n        }\n      }\n    }\n  }\n\n  *generateStrings() {\n    yield* this.drawBackdrop();\n    yield* this.generateLayers();\n  }\n\n  drawNails() {\n    const { backdropSize, backdropNailsColor, backdropNailsRadius } =\n      this.config;\n\n    this.#star.drawNails(this.nails);\n    if (backdropSize) {\n      const circleNails = [];\n      for (const circleNail of this.#circle.generateNails()) {\n        circleNails.push(circleNail);\n      }\n      this.nails.addGroup(circleNails, {\n        color: backdropNailsColor,\n        radius: backdropNailsRadius,\n      });\n    }\n  }\n\n  #getLayerSize(layer: number): number {\n    const { layers, layerSpread, sideNails } = this.config;\n    return Math.max(\n      1,\n      sideNails -\n        layer * Math.max(1, Math.floor((sideNails / layers) * layerSpread))\n    );\n  }\n\n  getStepCount() {\n    const { layers, sides } = this.config;\n    const { backdropNails } = this.getCalc();\n\n    const backdropStepCount = sides * backdropNails * 2;\n\n    let stepCount = backdropStepCount;\n    for (let layer = 0; layer < layers; layer++) {\n      const layerSize = this.#getLayerSize(layer);\n      stepCount += StarShape.getStepCount(this.config, { size: layerSize });\n    }\n\n    return stepCount;\n  }\n\n  static thumbnailConfig = {\n    sideNails: 10,\n    backdropNailsRadius: 0.5,\n  };\n}\n","import StringArt from '../StringArt';\nimport Circle, { CircleConfig } from '../helpers/Circle';\nimport Color from '../helpers/color/Color';\nimport type { ControlsConfig } from '../types/config.types';\nimport { ColorConfig, ColorValue } from '../helpers/color/color.types';\nimport { Coordinates, Dimensions } from '../types/general.types';\nimport { withoutAttribute } from '../helpers/config_utils';\nimport { PI2 } from '../helpers/math_utils';\nimport { formatFractionAsPercent } from '../helpers/string_utils';\n\ninterface LotusConfig extends ColorConfig {\n  sides: number;\n  density: number;\n  rotation: number;\n  removeSections: number;\n  fit: boolean;\n  renderCenter: boolean;\n  renderCenterNails: boolean;\n  radialColor: boolean;\n  centerRadius: number;\n}\n\ninterface TCalc {\n  circles: ReadonlyArray<Circle>;\n  circleNailsCount: number;\n  sideAngle: number;\n  sections: number;\n  nailsPerSection: number;\n  nailsPerCircle: number;\n  removedSections: number;\n  centerCircle?: Circle;\n}\n\nexport default class Lotus extends StringArt<LotusConfig> {\n  static type = 'lotus';\n\n  name = 'Lotus';\n  id = 'lotus';\n  controls: ControlsConfig<LotusConfig> = [\n    {\n      key: 'sides',\n      label: 'Sides',\n      description: 'How many petals there are in the Lotus',\n      type: 'range',\n      defaultValue: 16,\n      attr: {\n        min: 5,\n        max: 64,\n        step: 1,\n      },\n      isStructural: true,\n    },\n    {\n      key: 'density',\n      label: 'Density',\n      type: 'range',\n      defaultValue: 144,\n      attr: {\n        min: 1,\n        max: 500,\n        step: ({ sides }) => sides,\n      },\n      isStructural: true,\n    },\n    withoutAttribute(Circle.rotationConfig, 'snap'),\n    {\n      key: 'removeSections',\n      label: 'Remove sections',\n      type: 'range',\n      attr: {\n        min: 0,\n        max: 1,\n        step: ({ sides, renderCenter }) =>\n          1 / getSectionCountToRemove(sides, renderCenter),\n      },\n      defaultValue: 0,\n      displayValue: ({ removeSections, sides, renderCenter }) =>\n        Math.round(\n          removeSections * getSectionCountToRemove(sides, renderCenter)\n        ),\n      isStructural: true,\n    },\n    {\n      key: 'fit',\n      label: 'Fit',\n      type: 'checkbox',\n      defaultValue: true,\n      show: ({ removeSections }) => removeSections,\n      isStructural: true,\n    },\n    {\n      key: 'renderCenter',\n      label: 'Render center',\n      type: 'checkbox',\n      defaultValue: true,\n      isStructural: true,\n    },\n    {\n      key: 'centerRadius',\n      label: 'Center radius',\n      type: 'range',\n      defaultValue: 0,\n      attr: {\n        min: 0,\n        max: 1,\n        step: 0.01,\n      },\n      displayValue: ({ centerRadius }) => formatFractionAsPercent(centerRadius),\n      show: ({ renderCenter }) => renderCenter,\n      isStructural: true,\n    },\n    {\n      key: 'renderCenterNails',\n      label: 'Render center nails',\n      type: 'checkbox',\n      defaultValue: false,\n      isStructural: true,\n      show: ({ renderCenter }) => renderCenter,\n    },\n    Color.getConfig({\n      defaults: {\n        isMultiColor: true,\n        multicolorStart: 20,\n        multicolorRange: 26,\n        multicolorByLightness: true,\n        minLightness: 32,\n        maxLightness: 85,\n        saturation: 100,\n        colorCount: 8,\n      },\n      customControls: [\n        {\n          key: 'radialColor',\n          label: 'Radial color',\n          defaultValue: false,\n          type: 'checkbox',\n        },\n      ],\n      maxColorCount: 32,\n    }),\n  ];\n\n  defaultValues = {\n    nailsColor: '#a08346',\n  };\n\n  #calc: TCalc;\n  #color: Color;\n\n  getCalc(): TCalc {\n    const {\n      sides,\n      density,\n      margin,\n      rotation,\n      removeSections,\n      fit,\n      centerRadius: centerRadiusPercent,\n      renderCenter,\n    } = this.config;\n    const d = 0.5; // The helper circle's center is right between the pattern center and the edge\n    const size = this.getSize();\n    let radius = (Math.min(...size) * d) / 2;\n\n    const sideAngle = PI2 / sides;\n    const densityNailCount = fixNailsCount(density);\n    const baseCircleConfig: CircleConfig = {\n      n: densityNailCount,\n      center: [0, 0],\n      size: [0, 0],\n      radius: 0,\n      rotation: 0,\n    };\n\n    let petalSectionsToRemove = 0;\n\n    if (removeSections) {\n      const maxPetalSectionsToRemove = getSectionCountToRemove(\n        sides,\n        renderCenter\n      );\n      petalSectionsToRemove = Math.min(\n        maxPetalSectionsToRemove,\n        Math.round(removeSections * maxPetalSectionsToRemove)\n      );\n\n      const angleStart = sideAngle * petalSectionsToRemove;\n\n      if (fit) {\n        // Since we removed sections and now the pattern is smaller than the canvas size, we fit the remaining shape to fit on canvas\n        // this is done by:\n        // 1. Calculating the new outer edge of the shape, after removing sections\n        // 2. Increase the size of the circles that create petals by the inverse ratio of the new to original size\n        // 3. Since the circles are now larger, increase the number of nails in the circles by the size ratio, to maintain density.\n        const topSectionHeight =\n          2 * radius * Math.sin((Math.PI - angleStart) / 2);\n        const fitAspectRatio = (2 * radius - margin) / topSectionHeight;\n        baseCircleConfig.n = removeSectionsNailCount(\n          fixNailsCount(density * fitAspectRatio),\n          petalSectionsToRemove\n        );\n        radius *= fitAspectRatio;\n      } else {\n        // the `density` config is for a full circle, so making the number of nails on a petal relative to the size of the petal arc relative to a full circle\n        baseCircleConfig.n = removeSectionsNailCount(\n          densityNailCount,\n          petalSectionsToRemove\n        );\n      }\n\n      Object.assign(baseCircleConfig, {\n        angleStart,\n        angleEnd: PI2 - angleStart,\n      });\n    }\n\n    Object.assign(baseCircleConfig, {\n      size: [radius - margin / 2, radius - margin / 2],\n      radius: radius - margin / 2,\n    });\n\n    // Draw circles around the center point. For this, create a helper Circle, so its points can be used as centers for the lotus circles:\n    const helperCircle = new Circle({\n      n: sides,\n      size: size.map(v => v * d - margin) as Dimensions,\n      center: this.center,\n      radius: radius - margin / 2,\n      rotation,\n    });\n\n    const circles = new Array(sides).fill(null).map(\n      (_, i) =>\n        new Circle({\n          ...baseCircleConfig,\n          center: helperCircle.getPoint(i),\n          rotation: rotation - i / sides,\n        })\n    );\n\n    const calc: TCalc = {\n      circles,\n      circleNailsCount: baseCircleConfig.n,\n      sideAngle,\n      sections: getSectionsCount(sides),\n      removedSections: petalSectionsToRemove,\n      nailsPerSection: Math.floor(\n        baseCircleConfig.n / (sides - 2 * petalSectionsToRemove)\n      ),\n      nailsPerCircle: baseCircleConfig.n,\n    };\n\n    if (renderCenter && centerRadiusPercent) {\n      const lastSection = calc.sections - 1 - calc.removedSections;\n      const maxCenterRadiusPoint = circles[0].getPoint(\n        lastSection * calc.nailsPerSection\n      );\n      const maxCenterRadius = Math.floor(\n        Math.sqrt(\n          Math.abs(helperCircle.center[0] - maxCenterRadiusPoint[0]) ** 2 +\n            Math.abs(helperCircle.center[1] - maxCenterRadiusPoint[1]) ** 2\n        )\n      );\n      const centerCircleRadius = centerRadiusPercent * maxCenterRadius;\n      calc.centerCircle = new Circle({\n        n: sides,\n        center: helperCircle.center,\n        size: [centerCircleRadius, centerCircleRadius],\n        radius: centerCircleRadius,\n        rotation: -Math.ceil((sides - 4) / 2) / 2 / sides,\n      });\n    }\n\n    return calc;\n\n    function fixNailsCount(nailsCount: number): number {\n      return Math.max(sides, nailsCount - (nailsCount % sides));\n    }\n\n    function removeSectionsNailCount(\n      fullCircleNailCount: number,\n      sectionsToRemove: number\n    ): number {\n      return Math.round(\n        fullCircleNailCount * (1 - (2 * sectionsToRemove) / sides) + 1\n      );\n    }\n  }\n\n  resetStructure() {\n    super.resetStructure();\n\n    this.#calc = null;\n  }\n\n  setUpDraw() {\n    super.setUpDraw();\n\n    if (!this.#calc) {\n      this.#calc = this.getCalc();\n    }\n    let colorCount = this.config.radialColor\n      ? this.#calc.sections - this.#calc.removedSections - 1\n      : this.config.colorCount;\n\n    if (!this.config.renderCenter && this.config.radialColor) {\n      colorCount--;\n    }\n\n    this.#color = new Color({\n      ...this.config,\n      colorCount,\n    });\n  }\n\n  #getPatchColor(circleIndex: number, section: number): ColorValue {\n    const { radialColor } = this.config;\n    const { removedSections } = this.#calc;\n\n    return this.#color.getColor(\n      radialColor ? section - removedSections : circleIndex\n    );\n  }\n\n  *#drawPatch(circleIndex: number, section: number): Generator<void> {\n    const { sides } = this.config;\n    const {\n      circles,\n      sections,\n      nailsPerSection,\n      nailsPerCircle,\n      removedSections,\n    } = this.#calc;\n\n    const color = this.#getPatchColor(circleIndex, section);\n    const circle = circles[circleIndex];\n\n    this.renderer.setColor(color);\n\n    const prevCircle =\n      this.#calc.circles[circleIndex === 0 ? sides - 1 : circleIndex - 1];\n\n    if (section === 0) {\n      // For first section (outtermost): connectPoint is `prevCircle[sideAngle * 2]\n      const connectPoint: Coordinates = prevCircle.getPoint(\n        nailsPerSection * 2\n      );\n      for (let i = nailsPerCircle - nailsPerSection; i < nailsPerCircle; i++) {\n        this.renderer.renderLines(circle.getPoint(i), connectPoint);\n        yield;\n      }\n      for (let i = 0; i <= nailsPerSection; i++) {\n        this.renderer.renderLines(circle.getPoint(i), connectPoint);\n        yield;\n      }\n    } else {\n      // For middle sections, connectPoint is `circleIndex - 1`, (sideAngle * section + 1). Connect circleIndex[section] and `circleIndex + section`[section]\n\n      const isLastSection = section === sections - 2;\n      const connectPoint: Coordinates =\n        isLastSection && this.#calc.centerCircle\n          ? this.#calc.centerCircle.getPoint(circleIndex)\n          : prevCircle.getPoint(\n              nailsPerSection * (section + 2 - removedSections) -\n                (sides % 2 && section === sections - 2\n                  ? nailsPerSection / 2\n                  : 0)\n            );\n      const firstCircle = circles[(circleIndex + section) % sides];\n      const firstCircleStart =\n        nailsPerCircle -\n        (section + 1 - removedSections) * nailsPerSection -\n        (removedSections ? 1 : 0);\n\n      for (let i = 0; i <= nailsPerSection; i++) {\n        this.renderer.renderLines(\n          firstCircle.getPoint(firstCircleStart + i),\n          connectPoint\n        );\n        yield;\n      }\n\n      const startIndex = (section - removedSections) * nailsPerSection + 1;\n      for (let i = startIndex; i < startIndex + nailsPerSection; i++) {\n        this.renderer.renderLines(circle.getPoint(i), connectPoint);\n        yield;\n      }\n    }\n  }\n\n  *generateStrings(): Generator<void> {\n    for (const { side, section } of this.#generatePatches()) {\n      yield* this.#drawPatch(side, section);\n    }\n  }\n\n  *#generatePatches(): Generator<{ side: number; section: number }> {\n    const { radialColor, sides, renderCenter } = this.config;\n    const { sections, removedSections } = this.#calc;\n\n    const lastSection = sections - (renderCenter ? 1 : 2);\n\n    if (radialColor) {\n      for (let section = removedSections; section < lastSection; section++) {\n        for (let side = 0; side < sides; side++) {\n          yield { side, section };\n        }\n      }\n    } else {\n      for (let side = 0; side < sides; side++) {\n        for (let section = removedSections; section < lastSection; section++) {\n          yield { side, section };\n        }\n      }\n    }\n  }\n\n  drawNails() {\n    const { renderCenter, renderCenterNails } = this.config;\n    const { circles, circleNailsCount, centerCircle } = this.#calc;\n\n    circles.forEach((circle, circleIndex) => {\n      circle.drawNails(this.nails, {\n        getNumber: i => `${circleIndex + 1}_${i}`,\n        excludedNailRanges: renderCenterNails\n          ? null\n          : this.#getCenterExcludedNails(),\n      });\n    });\n\n    if (renderCenter) {\n      if (centerCircle) {\n        centerCircle.drawNails(this.nails, { getNumber: i => `C_${i + 1}` });\n      } else {\n        this.nails.addNail({ point: this.center, number: 'C' });\n      }\n    }\n  }\n\n  #getCenterExcludedNails(): [[number, number]] {\n    const { renderCenter } = this.config;\n    const { sections, nailsPerSection, nailsPerCircle, removedSections } =\n      this.#calc;\n\n    const innerSectionNailsStart =\n      (sections - 1 - removedSections - (renderCenter ? 0 : 1)) *\n        nailsPerSection +\n      1;\n    const innerSectionNailsEnd = nailsPerCircle - innerSectionNailsStart;\n\n    return [[innerSectionNailsStart, innerSectionNailsEnd]];\n  }\n\n  getStepCount() {\n    const { nailsPerSection, sections, removedSections } = this.getCalc();\n    const { sides } = this.config;\n\n    const patchCount = 2 * nailsPerSection + 1;\n    const sideStepCount = patchCount * (sections - removedSections - 1);\n\n    return sides * sideStepCount;\n  }\n\n  static thumbnailConfig = {};\n}\n\nfunction getSectionsCount(sides: number): number {\n  return sides % 2 ? Math.ceil(sides / 2) : sides / 2;\n}\n\nfunction getSectionCountToRemove(sides: number, renderCenter: boolean): number {\n  return getSectionsCount(sides) - (renderCenter ? 2 : 3);\n}\n","import StringArtHueInput from '../components/StringArtHueInput';\nimport StringArtRangeInput from '../components/StringArtRangeInput';\nimport type {\n  Config,\n  ConfigValueOrFunction,\n  ControlConfig,\n  ControlsConfig,\n  ControlType,\n  PrimitiveValue,\n} from '../types/config.types';\n\nconst elements = {\n  controls: document.querySelector('#controls') as HTMLElement,\n  controlsPanel: document.querySelector('#controls_panel') as HTMLElement,\n  sidebarForm: document.querySelector('#sidebar_form') as HTMLElement,\n};\n\ntype EditorControlsEvent = 'input' | 'change' | 'control';\nconst EVENTS = new Set<EditorControlsEvent>(['input', 'change']);\nconst STATE_LOCAL_STORAGE_KEY = 'controls_state';\nconst RANGE_SCROLL_LOCK_TIMEOUT = 120;\n\nlet inputTimeout: number;\n\ninterface EditorState {\n  groups: {\n    [groupId: string]: boolean;\n  };\n}\n\ntype ControlInputElement = (\n  | HTMLInputElement\n  | StringArtRangeInput\n  | StringArtHueInput\n  | HTMLSelectElement\n) & {\n  updateTimeout?: number;\n};\n\ninterface Control<TConfig> {\n  config: ControlConfig<TConfig>;\n  input: ControlInputElement;\n  element: HTMLElement;\n  displayValueElement: HTMLSpanElement;\n}\n\nexport type ControlValueChangeEvent<\n  TConfig,\n  TControl extends keyof TConfig = keyof TConfig\n> = {\n  control: TControl;\n  value: TConfig[TControl];\n  originalEvent: Event;\n};\n\nexport type OnControlValueChangedEventHandler<TConfig> = (\n  event: ControlValueChangeEvent<TConfig>\n) => any;\n\nexport default class EditorControls<TConfig> {\n  config: Config<TConfig>;\n  controlsConfig: ControlsConfig<TConfig>;\n  state: EditorState;\n  eventHandlers: {\n    input: Set<string>;\n    change: Set<string>;\n  };\n  controlElements: Partial<Record<keyof TConfig, Control<TConfig>>> = {};\n\n  #postponeRangeInput: boolean = false;\n  #postponeRangeInputTimeout: number;\n  #wrappedOnInput;\n  #wrappedOnTouchStart;\n  #wrappedOnTouchEnd;\n  #wrappedOnRangeScroll;\n  #currentInputRange: StringArtRangeInput | StringArtHueInput;\n  #currentInputRangeValue: number;\n  #rangeLockTimeout: number;\n  #lockRange: boolean = false;\n  #boundToggleFieldset;\n\n  constructor(\n    controlsConfig: ControlsConfig<TConfig>,\n    config: Config<TConfig>\n  ) {\n    this.config = config;\n    this.controlsConfig = controlsConfig;\n\n    this.state = this._getState() ?? { groups: {} };\n\n    this.eventHandlers = {\n      input: new Set(),\n      change: new Set(),\n    };\n\n    this.#wrappedOnInput = this.#onInput.bind(this);\n    elements.controls.addEventListener('input', this.#wrappedOnInput);\n    this.#wrappedOnTouchStart = this.#onTouchStart.bind(this);\n    elements.controls.addEventListener('touchstart', this.#wrappedOnTouchStart);\n    elements.controls.addEventListener('mousedown', this.#onMouseDown);\n    this.#boundToggleFieldset = this.#toggleFieldset.bind(this);\n    elements.sidebarForm.addEventListener('click', this.#boundToggleFieldset);\n    elements.sidebarForm.addEventListener(\n      'keydown',\n      this.#toggleFieldSetOnEnter\n    );\n    this.controlElements = {};\n    this.renderControls();\n  }\n\n  destroy() {\n    elements.controls.removeEventListener('input', this.#wrappedOnInput);\n    elements.sidebarForm.removeEventListener(\n      'click',\n      this.#boundToggleFieldset\n    );\n    elements.sidebarForm.removeEventListener(\n      'keydown',\n      this.#toggleFieldSetOnEnter\n    );\n    elements.controls.removeEventListener(\n      'touchstart',\n      this.#wrappedOnTouchStart\n    );\n    elements.controls.removeEventListener('mousedown', this.#onMouseDown);\n    elements.controls.innerHTML = '';\n  }\n\n  #toggleFieldset(this: EditorControls<TConfig>, e) {\n    if (e.target.nodeName === 'LEGEND') {\n      e.target.parentElement.classList.toggle('minimized');\n      const groupId = e.target.parentElement.dataset.group;\n      this.state = {\n        ...this.state,\n        groups: {\n          ...this.state.groups,\n          [groupId]: !e.target.parentElement.classList.contains('minimized'),\n        },\n      };\n      this._updateState(this.state);\n    }\n  }\n\n  #toggleFieldSetOnEnter(e) {\n    if (e.target.nodeName === 'LEGEND' && e.key === 'Enter') {\n      this.#toggleFieldset(e);\n    }\n  }\n\n  addEventListener(\n    event: EditorControlsEvent,\n    eventHandler: OnControlValueChangedEventHandler<TConfig>\n  ) {\n    if (!EVENTS.has(event)) {\n      throw new Error(`Unsupported event for EditorControls, \"${event}\"!`);\n    }\n\n    if (!(eventHandler instanceof Function)) {\n      throw new Error('Invalid event handler.');\n    }\n\n    this.eventHandlers[event].add(eventHandler);\n  }\n\n  _triggerEvent(event, eventData) {\n    for (const eventHandler of this.eventHandlers[event]) {\n      eventHandler(eventData);\n    }\n  }\n\n  #onMouseDown() {\n    // Clearing selection when starting to click in the controls, do avoid a buggy behavior,\n    // when if a control's display value was selected (can happen by mistake), the drag of range input doesn't work.\n    const selection = window.getSelection();\n    if (selection) {\n      selection.removeAllRanges();\n    }\n  }\n\n  /**\n   * Needed for range inputs, to avoid changing the value when the user drags to\n   * scroll and accidentally touches a range input when intending to scroll.\n   * @param {Event} e\n   */\n  #onTouchStart(e: TouchEvent) {\n    if (isRangeInput(e.target)) {\n      this.#postponeRangeInput = true;\n      this.#currentInputRange = e.target;\n      this.#currentInputRangeValue = e.target.value;\n      this.#rangeLockTimeout = window.setTimeout(() => {\n        this.#postponeRangeInput = false;\n      }, RANGE_SCROLL_LOCK_TIMEOUT);\n      this.#wrappedOnTouchEnd = this.#onTouchEnd.bind(this);\n      document.body.addEventListener('touchend', this.#wrappedOnTouchEnd);\n      this.#wrappedOnRangeScroll = this.#onRangeScroll.bind(this);\n      elements.controlsPanel.addEventListener(\n        'scroll',\n        this.#wrappedOnRangeScroll\n      );\n    }\n  }\n\n  #onTouchEnd(this: EditorControls<TConfig>) {\n    document.body.removeEventListener('touchend', this.#wrappedOnTouchEnd);\n    elements.controlsPanel.removeEventListener(\n      'scroll',\n      this.#wrappedOnRangeScroll\n    );\n\n    if (this.#lockRange) {\n      this.#lockRange = false;\n      if (this.#currentInputRange) {\n        this.#currentInputRange.value = this.#currentInputRangeValue;\n      }\n    }\n\n    this.#currentInputRange = this.#currentInputRangeValue = null;\n  }\n\n  #onRangeScroll(this: EditorControls<TConfig>) {\n    this.#lockRange = true;\n  }\n\n  #onInput(e: InputEvent) {\n    clearTimeout(inputTimeout);\n    clearTimeout(this.#postponeRangeInputTimeout);\n\n    if (this.#postponeRangeInput && isRangeInput(e.target)) {\n      e.preventDefault();\n      this.#postponeRangeInputTimeout = window.setTimeout(() => {\n        this.#onInput(e);\n      }, RANGE_SCROLL_LOCK_TIMEOUT);\n      return false;\n    }\n    if (this.#lockRange) {\n      e.preventDefault();\n      return false;\n    }\n\n    if (\n      e.target instanceof HTMLInputElement ||\n      isRangeInput(e.target) ||\n      e.target instanceof HTMLSelectElement\n    ) {\n      this.updateInput({\n        inputElement: e.target,\n        originalEvent: e,\n        deferChange: true,\n      });\n    }\n  }\n\n  updateControlDisplayValue(controlKey: keyof TConfig) {\n    const { config, displayValueElement, input } = this.controlElements[\n      controlKey\n    ] as Control<TConfig>;\n    if (displayValueElement) {\n      const formattedValue = config.displayValue\n        ? config.displayValue(this.config)\n        : input.value;\n      displayValueElement.innerText = String(formattedValue);\n    }\n  }\n\n  updateInput({\n    inputElement,\n    originalEvent,\n    deferChange = true,\n  }: {\n    inputElement: ControlInputElement;\n    originalEvent?: InputEvent;\n    deferChange?: boolean;\n  }) {\n    const inputValue = getInputValue(inputElement);\n    const controlKey = inputElement.id.replace(/^config_/, '') as keyof TConfig;\n\n    if (this.config[controlKey] === inputValue) {\n      return;\n    }\n\n    const eventData = Object.freeze({\n      control: controlKey,\n      value: inputValue,\n      originalEvent,\n    });\n\n    this._triggerEvent('input', eventData);\n\n    const triggerChange = () => {\n      this._triggerEvent('change', eventData);\n      this.updateControlsVisibility();\n    };\n\n    this.updateControlsAttributes();\n    this.updateControlDisplayValue(controlKey);\n\n    if (deferChange) {\n      inputTimeout = window.setTimeout(triggerChange, 100);\n    } else {\n      triggerChange();\n    }\n  }\n\n  _getState(): EditorState | null {\n    const state = localStorage.getItem(STATE_LOCAL_STORAGE_KEY);\n    if (state) {\n      try {\n        return JSON.parse(state);\n      } catch (e) {\n        return null;\n      }\n    }\n\n    return null;\n  }\n\n  _updateState(newState) {\n    if (newState) {\n      localStorage.setItem(STATE_LOCAL_STORAGE_KEY, JSON.stringify(newState));\n    } else {\n      localStorage.removeItem(STATE_LOCAL_STORAGE_KEY);\n    }\n  }\n\n  updateControlsAttributes(controlsConfig?: ControlsConfig<TConfig>) {\n    if (!controlsConfig) {\n      controlsConfig = this.controlsConfig;\n    }\n    controlsConfig.forEach(control => {\n      if (control.type === 'group') {\n        this.updateControlsAttributes(control.children);\n      } else if (control.attr) {\n        const functionAttrs = Object.entries(control.attr).filter(\n          ([_, value]) => value instanceof Function\n        );\n        if (functionAttrs.length) {\n          const inputEl = this.controlElements[control.key].input;\n          if (inputEl) {\n            functionAttrs.forEach(([name, attributeValueFn]) => {\n              const newAttrValue = this.getConfigValue(\n                attributeValueFn,\n                this.config\n              );\n              if (newAttrValue != inputEl.getAttribute(name)) {\n                inputEl.setAttribute(name, String(newAttrValue));\n                // If the min or max of the input changed and they're not within the new min/max, update the value of the input\n                if (\n                  (name === 'min' && inputEl.value < newAttrValue) ||\n                  (name === 'max' && inputEl.value > newAttrValue)\n                ) {\n                  inputEl.value = String(newAttrValue);\n                  clearTimeout(inputEl.updateTimeout);\n                  inputEl.updateTimeout = window.setTimeout(() => {\n                    this.updateInput({ inputElement: inputEl });\n                  }, 100);\n                } else {\n                  this.updateControlDisplayValue(control.key);\n                }\n              }\n            });\n          }\n        }\n      }\n    });\n  }\n\n  updateControlsVisibility(controlsConfig?: ControlsConfig<TConfig>) {\n    (controlsConfig ?? this.controlsConfig).forEach(control => {\n      if (control.show) {\n        const shouldShowControl = control.show(this.config);\n        const controlEl = this.controlElements[control.key].element;\n        if (controlEl) {\n          if (shouldShowControl) {\n            controlEl.removeAttribute('hidden');\n          } else {\n            controlEl.setAttribute('hidden', 'hidden');\n          }\n        }\n      }\n\n      if (control.isDisabled) {\n        const shouldDisableControl = control.isDisabled(this.config);\n        const inputEl = this.controlElements[control.key].input;\n        if (inputEl) {\n          if (shouldDisableControl) {\n            inputEl.setAttribute('disabled', 'disabled');\n          } else {\n            inputEl.removeAttribute('disabled');\n          }\n        }\n      }\n\n      if (control.children) {\n        this.updateControlsVisibility(control.children);\n      }\n    });\n  }\n\n  renderControls(\n    containerEl: HTMLElement | undefined = elements.controls,\n    _controlsConfig?: ControlsConfig<TConfig>,\n    indexStart?: number\n  ) {\n    const controlsConfig = _controlsConfig ?? this.controlsConfig;\n    containerEl.innerHTML = '';\n    const controlsFragment = document.createDocumentFragment();\n    indexStart = indexStart ?? 1;\n\n    controlsConfig.forEach((controlConfig, controlIndex) => {\n      const controlId = `config_${String(controlConfig.key)}`;\n\n      let controlEl: HTMLElement;\n      let inputEl: ControlInputElement;\n      let displayValueElement: HTMLSpanElement;\n\n      if (controlConfig.type === 'group') {\n        controlEl = document.createElement('fieldset');\n        controlEl.setAttribute('data-group', String(controlConfig.key));\n        const groupTitleEl = document.createElement('legend');\n        groupTitleEl.setAttribute('tabindex', '0');\n        groupTitleEl.innerText = controlConfig.label;\n        controlEl.appendChild(groupTitleEl);\n        controlEl.className = 'control control_group';\n        if (controlConfig.defaultValue === 'minimized') {\n          controlEl.classList.add('minimized');\n          this.state.groups[String(controlConfig.key)] = false;\n        }\n        const childrenContainer = document.createElement('div');\n        controlEl.appendChild(childrenContainer);\n        this.renderControls(childrenContainer, controlConfig.children);\n      } else {\n        controlEl = document.createElement('div');\n        controlEl.className = 'control';\n\n        const label = document.createElement('label');\n        label.innerHTML = controlConfig.label;\n        label.setAttribute('for', controlId);\n\n        inputEl = document.createElement(\n          getElementTagNameForControlType(controlConfig.type)\n        ) as ControlInputElement;\n        if (isRangeInput(inputEl)) {\n          inputEl.classList.add('range-input');\n        }\n        inputEl.setAttribute('tabindex', String(controlIndex));\n        const inputValue =\n          this.config[controlConfig.key] ??\n          this.getConfigValue(controlConfig.defaultValue, this.config);\n\n        if (controlConfig.type === 'select') {\n          const selectOptions = document.createDocumentFragment();\n          controlConfig.options.forEach(_option => {\n            const { value, label } =\n              typeof _option === 'string'\n                ? { value: _option, label: _option }\n                : _option;\n            const optionEl = document.createElement('option');\n            optionEl.setAttribute('value', value);\n            optionEl.innerText = label;\n            selectOptions.appendChild(optionEl);\n          });\n          inputEl.appendChild(selectOptions);\n          (inputEl as HTMLSelectElement).value = String(inputValue);\n          controlEl.appendChild(label);\n          controlEl.appendChild(inputEl);\n        } else {\n          if (controlConfig.type !== 'range') {\n            inputEl.setAttribute('type', controlConfig.type);\n          }\n\n          if (controlConfig.type === 'checkbox') {\n            (inputEl as HTMLInputElement).checked = !!inputValue;\n            controlEl.appendChild(inputEl);\n            controlEl.appendChild(label);\n          } else {\n            controlEl.appendChild(label);\n            controlEl.appendChild(inputEl);\n            setTimeout(() => {\n              inputEl.value = String(inputValue);\n            });\n            displayValueElement = document.createElement('span');\n            displayValueElement.id = `config_${String(\n              controlConfig.key\n            )}_value`;\n            displayValueElement.innerText = String(\n              controlConfig.displayValue\n                ? controlConfig.displayValue(this.config)\n                : inputValue\n            );\n            displayValueElement.className = 'control_input_value';\n            controlEl.appendChild(displayValueElement);\n          }\n        }\n\n        if (controlConfig.attr) {\n          Object.entries(controlConfig.attr).forEach(([attr, value]) => {\n            const realValue = this.getConfigValue(value, this.config);\n            inputEl.setAttribute(attr, String(realValue));\n          });\n        }\n\n        inputEl.id = controlId;\n      }\n\n      this.controlElements[controlConfig.key] = {\n        config: controlConfig,\n        displayValueElement,\n        input: inputEl,\n        element: controlEl,\n      };\n      controlEl.id = `control_${String(controlConfig.key)}`;\n      controlsFragment.appendChild(controlEl);\n    });\n\n    containerEl.appendChild(controlsFragment);\n    this.updateGroupsState();\n    requestAnimationFrame(() => this.updateControlsVisibility());\n  }\n\n  updateGroupsState() {\n    const groups = elements.sidebarForm.querySelectorAll('[data-group]');\n    groups.forEach(groupEl => {\n      if (groupEl instanceof HTMLFieldSetElement) {\n        const groupId = groupEl.dataset.group;\n        const groupState = this.state.groups[groupId];\n        if (typeof groupState === 'boolean') {\n          if (groupState) {\n            groupEl.classList.remove('minimized');\n          } else {\n            groupEl.classList.add('minimized');\n          }\n        }\n      }\n    });\n  }\n\n  getConfigValue(\n    valueOrFn: ConfigValueOrFunction<TConfig>,\n    config: Config<TConfig>\n  ): PrimitiveValue {\n    if (valueOrFn instanceof Function) {\n      return valueOrFn(config);\n    }\n\n    return valueOrFn;\n  }\n}\n\nfunction getInputValue(inputElement: EventTarget) {\n  if (isRangeInput(inputElement)) {\n    return Number(inputElement.value);\n  }\n\n  if (inputElement instanceof HTMLInputElement) {\n    const type = inputElement.type;\n\n    switch (type) {\n      case 'range':\n        return parseFloat(inputElement.value);\n      case 'hue':\n        return inputElement.value;\n      case 'checkbox':\n        return inputElement.checked;\n      case 'number':\n        return parseFloat(inputElement.value);\n      default:\n        return inputElement.value;\n    }\n  } else if (inputElement instanceof HTMLSelectElement) {\n    return inputElement.value;\n  }\n}\n\nfunction getElementTagNameForControlType(controlType: ControlType): string {\n  switch (controlType) {\n    case 'select':\n      return 'select';\n    case 'range':\n      return 'string-art-range-input';\n    case 'hue':\n      return 'string-art-hue-input';\n    default:\n      return 'input';\n  }\n}\n\nfunction isRangeInput(\n  element: EventTarget\n): element is StringArtRangeInput | StringArtHueInput {\n  return (\n    element instanceof StringArtRangeInput ||\n    element instanceof StringArtHueInput\n  );\n}\n","import StringArtRangeInput from './StringArtRangeInput';\n\nconst DEFAULT_THUMB_COLOR = 'white';\nconst FULL_GAMUT_GRADIENT =\n  'linear-gradient(to right in hsl longer hue, hsl(1 100 50), hsl(360 100 50))';\n\nexport default class StringArtHueInput extends HTMLElement {\n  static formAssociated = true;\n  internals: ElementInternals;\n\n  start: number = 1; // hue to start with\n  colorThumb: boolean = false;\n  reverse: boolean = false;\n  type: 'hue' | 'range' = 'hue';\n\n  #input: StringArtRangeInput = null;\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open', delegatesFocus: true });\n\n    this.shadowRoot.innerHTML = `\n        <string-art-range-input min=\"1\" max=\"360\" step=\"1\" />\n    `;\n\n    this.#input = this.shadowRoot.querySelector('string-art-range-input');\n    this.internals = this.attachInternals();\n  }\n\n  static get observedAttributes() {\n    return ['start', 'colorthumb', 'value', 'reverse', 'type'];\n  }\n\n  attributeChangedCallback(name: string, oldVal: string, newVal: string) {\n    if (name === 'value') {\n      this.value = newVal;\n    }\n\n    if (name === 'start') {\n      this.start = parseInt(newVal, 10);\n      this.#setBackground();\n    }\n\n    if (name === 'reverse') {\n      this.reverse = !!newVal;\n      this.#setBackground();\n    }\n\n    if (name === 'colorthumb') {\n      this.colorThumb = !!newVal;\n      this.#setThumbColor();\n      // Update color thumb\n    }\n\n    if (name === 'type') {\n      this.type = newVal === 'range' ? 'range' : 'hue';\n      this.#setBackground();\n    }\n  }\n\n  get value(): number {\n    return this.#input.value;\n  }\n\n  set value(v: number | string) {\n    this.#input.value = v;\n    this.#setBackground();\n\n    if (this.colorThumb) {\n      this.#setThumbColor();\n    }\n  }\n\n  connectedCallback() {\n    if (this.hasAttribute('value')) {\n      this.value = parseInt(this.getAttribute('value'));\n    }\n\n    if (this.hasAttribute('colorthumb')) {\n      this.colorThumb = true;\n    }\n    this.#setThumbColor();\n\n    this.#input.addEventListener('input', e => this.#handleInput(e));\n  }\n\n  #handleInput(e: Event) {\n    const value = this.value;\n\n    this.internals.setFormValue(String(value));\n\n    this.dispatchEvent(\n      new CustomEvent('input', {\n        detail: { value },\n      })\n    );\n\n    this.#setBackground();\n    this.#setThumbColor();\n  }\n  disconnectedCallback() {\n    // Destroy EditorControls here\n  }\n\n  focus() {}\n\n  blur() {}\n\n  #setBackground(): void {\n    const background =\n      this.type === 'range'\n        ? `linear-gradient(to ${this.reverse ? 'left' : 'right'} in hsl ${\n            this.value >= 180 ? 'longer' : 'shorter'\n          } hue, hsl(${this.start} 100 50), hsl(${\n            // Fixes a bug in Chrome, that for a 180 deg hue gradient, it always goes in reverse\n            this.start + (this.value === 180 ? 181 : this.value)\n          } 100 50))`\n        : FULL_GAMUT_GRADIENT;\n\n    this.#input.setAttribute('background', background);\n  }\n\n  #setThumbColor(): void {\n    const thumbColor = this.colorThumb\n      ? `hsl(${this.value}deg 100 50)`\n      : DEFAULT_THUMB_COLOR;\n\n    this.#input.setAttribute('thumbcolor', thumbColor);\n  }\n}\n\ncustomElements.define('string-art-hue-input', StringArtHueInput);\n","const DEFAULT_SNAP_DISTANCE = 0.05;\nconst THUMB_RADIUS = 8;\nconst TICK_WIDTH = 2;\nconst TICK_COLOR = 'rgba(0,0,0,.2)';\nconst FAR_VALUES_DISTANCE = 0.2; // values are considered far from each other if they are at least a fifth of the width of the input apart\n\nexport default class StringArtRangeInput extends HTMLElement {\n  static formAssociated = true;\n  internals: ElementInternals;\n\n  min: number;\n  max: number;\n\n  #input: HTMLInputElement = null;\n  #backgroundStyle: HTMLStyleElement = null;\n  #snap: number = DEFAULT_SNAP_DISTANCE;\n  #prevValue: number = null;\n  #prevSnapValue: number = null;\n  #tickValues: Array<number> = null;\n  #snapDistance: number = null;\n  #background: string = null;\n  #thumbColor: string = null;\n  #snapDisabledTick: number = null;\n  #resizeObserver: ResizeObserver;\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open', delegatesFocus: true });\n\n    this.shadowRoot.innerHTML = `\n          <style>\n            input[type=\"range\"] {\n              width: 100%;\n              appearance: none;\n              -webkit-appearance: none; /* remove iOS default */\n              background: transparent;\n              border: none;\n              margin: 2px;\n              cursor: pointer;\n            }\n\n            input[type=\"range\"]::-webkit-slider-thumb {\n              appearance: none;\n              -webkit-appearance: none;\n              width: ${THUMB_RADIUS * 2}px;\n              height: ${THUMB_RADIUS * 2}px;\n              border-radius: 50%;\n              background: var(--color-input);\n              cursor: pointer;\n              border: none;\n              margin-top: -4px;\n              z-index: 10;\n              box-shadow: 0 0 5px rgba(0,0,0,.5)\n            }\n\n            input[type=\"range\"]::-webkit-slider-thumb:hover {\n              background: var(--color-input-hover);\n            }\n              \n            input[type=\"range\"]:active::-webkit-slider-thumb {\n              background: var(--color-input-active);\n            }\n\n            input[type=\"range\"]::-webkit-slider-runnable-track {\n              height: 8px;\n              border-radius: 4px;\n              margin: 0;\n            }\n          </style>\n          <style id=\"background\"></style>\n          <input type=\"range\">\n        `;\n\n    this.#input = this.shadowRoot.querySelector('input[type=\"range\"]');\n    this.#backgroundStyle = this.shadowRoot.querySelector('#background');\n    this.#snap = DEFAULT_SNAP_DISTANCE;\n    this.#prevSnapValue = null;\n\n    this.internals = this.attachInternals();\n  }\n\n  static get observedAttributes() {\n    return ['min', 'max', 'value', 'step', 'snap', 'background', 'thumbcolor'];\n  }\n\n  attributeChangedCallback(name, oldVal, newVal) {\n    if (name === 'snap') {\n      this.#tickValues = this.getTickValues();\n    } else if (this.#input) {\n      this.#input[name] = newVal;\n    }\n\n    if (name === 'min' || name === 'max') {\n      this[name] = Number(newVal);\n    }\n\n    let value: number;\n    if (name === 'value') {\n      value = Number(newVal);\n    }\n\n    if (name === 'background') {\n      this.#background = newVal;\n    }\n\n    if (name === 'thumbcolor') {\n      this.#thumbColor = newVal;\n    }\n\n    if (this.min != null && this.max != null) {\n      if (this.min > this.max) {\n        this.max = this.min;\n        this.#input.max = String(this.min);\n      }\n\n      this.#snapDistance =\n        (this.max - this.min) * this.#snap || DEFAULT_SNAP_DISTANCE;\n\n      if (this.#tickValues && this.value != null) {\n        const snappedValue = this.getClosestTick(value);\n        if (snappedValue != null) {\n          this.#prevSnapValue = snappedValue;\n        }\n      }\n    }\n\n    this.#setStyle();\n  }\n\n  get value(): number {\n    return Number(this.#input.value);\n  }\n\n  set value(v: string | number) {\n    this.#input.value = String(v);\n    this.#setStyle();\n  }\n\n  connectedCallback() {\n    ['min', 'max', 'value', 'step'].forEach(attr => {\n      if (this.hasAttribute(attr)) {\n        this.#input[attr] = this.getAttribute(attr);\n      }\n    });\n\n    this.#tickValues = this.getTickValues();\n    this.#resizeObserver = new ResizeObserver(entries => {\n      for (let entry of entries) {\n        const width = entry.contentRect.width;\n        this.#setStyle();\n      }\n    });\n    this.#resizeObserver.observe(this.#input);\n\n    this.#input.addEventListener('input', () => this.handleInput());\n    this.#input.addEventListener('keydown', e => this.handleKeydown(e));\n    this.#input.addEventListener(\n      'change',\n      () => (this.#snapDisabledTick = null)\n    );\n\n    this.tabIndex = 0;\n  }\n\n  disconnectedCallback() {\n    this.#resizeObserver.unobserve(this);\n  }\n\n  getTickValues() {\n    const ticks = this.getAttribute('snap');\n    const ticksMatch = ticks?.match(/\\d+(\\.\\d+)?/g);\n    if (!ticksMatch) return [];\n    return ticksMatch\n      .map(Number)\n      .filter(n => !isNaN(n))\n      .sort();\n  }\n\n  #shouldAvoidSnap(newValue, closestTick) {\n    if (closestTick == null) {\n      closestTick = this.getClosestTick(newValue);\n    }\n\n    if (closestTick == null) {\n      return true;\n    }\n\n    // If moving away from the snap value, don't snap:\n    const distanceFromTick = Math.abs(newValue - closestTick);\n\n    if (\n      distanceFromTick >= this.#snapDistance / 2 &&\n      distanceFromTick > Math.abs(this.#prevValue - closestTick)\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Checks whether two values are far apart,\n  #areValuesFar(value1: number, value2: number): boolean {\n    const distance = Math.abs(value1 - value2) / (this.max - this.min);\n    return distance >= FAR_VALUES_DISTANCE;\n  }\n\n  focus() {\n    this.#input.focus();\n  }\n\n  blur() {\n    this.#input.blur();\n  }\n\n  handleInput() {\n    const value = Number(this.#input.value);\n    const closestTick = this.getClosestTick(value);\n\n    this.internals.setFormValue(this.#input.value);\n\n    if (\n      closestTick != null &&\n      this.#snapDisabledTick !== closestTick &&\n      this.#shouldAvoidSnap(value, closestTick)\n    ) {\n      this.#snapDisabledTick = closestTick;\n    }\n\n    if (closestTick !== this.#snapDisabledTick) {\n      if (closestTick !== null) {\n        this.#input.value = String(closestTick);\n        if (closestTick !== this.#prevSnapValue) {\n          this.#vibrate();\n          this.#prevSnapValue = closestTick;\n        }\n      } else if (this.#prevSnapValue != null) {\n        this.#prevSnapValue = null;\n      }\n    }\n\n    if (\n      this.#snapDisabledTick != null &&\n      closestTick == null &&\n      this.#areValuesFar(value, this.#snapDisabledTick)\n    ) {\n      this.#snapDisabledTick = null;\n    }\n\n    this.#setStyle();\n    this.#prevValue = value;\n\n    this.dispatchEvent(\n      new CustomEvent('input', {\n        detail: { value: this.#input.value },\n      })\n    );\n  }\n\n  handleKeydown(event: KeyboardEvent) {\n    event.preventDefault();\n    const step = Number(this.#input.step || 1);\n    const value = Number(this.#input.value);\n\n    let newValue;\n\n    if (event.key === 'ArrowLeft') {\n      newValue = Math.max(this.min, value - step);\n    } else if (event.key === 'ArrowRight') {\n      newValue = Math.min(this.max, value + step);\n    } else if (event.key === 'ArrowUp') {\n      const next = this.#tickValues.find(t => t > value);\n      if (next !== undefined) {\n        newValue = next;\n      } else if (value !== this.max) {\n        // no next tick found, go to max\n        newValue = this.max;\n      }\n    } else if (event.key === 'ArrowDown') {\n      const reversed = [...this.#tickValues].reverse();\n      const prev = reversed.find(t => t < value);\n      if (prev !== undefined) {\n        newValue = prev;\n      } else if (value !== this.min) {\n        newValue = this.min;\n      }\n    }\n\n    if (newValue != null) {\n      this.value = newValue;\n      this.#prevValue = newValue;\n      // emit event and prevent default for arrow keys\n      this.dispatchEvent(\n        new CustomEvent('input', {\n          detail: { value: newValue },\n          bubbles: true,\n          composed: true,\n        })\n      );\n    }\n\n    return false;\n  }\n\n  getClosestTick(value: number): number {\n    if (!this.#tickValues || this.#tickValues.length === 0) return null;\n\n    for (const tickValue of this.#tickValues) {\n      const distance = Math.abs(value - tickValue);\n      if (distance <= this.#snapDistance) {\n        return tickValue;\n      }\n    }\n\n    return null;\n  }\n\n  #vibrate() {\n    if ('vibrate' in navigator) {\n      navigator.vibrate(10);\n    }\n  }\n\n  #setStyle() {\n    const inputWidth = this.#input.clientWidth;\n    if (!inputWidth) {\n      return;\n    }\n\n    const valueInRange = this.value - this.min;\n    const range = this.max - this.min;\n    const availableWidth = inputWidth - 2 * THUMB_RADIUS;\n    const valueWidth = THUMB_RADIUS + (availableWidth * valueInRange) / range;\n\n    // The center of the thumb of the range input doesn't reach 0 and 100%, so the actual range to display leaves out the thumb's radius on the left and right.\n    // Due to this, the ticks are placed in the constricted range of [THUMB_RADIUS::inputWidth - 2 * THUMB_RADIUS]\n    const tickPositions = this.#tickValues\n      ?.filter(v => v !== this.min && v !== this.max)\n      .map(\n        v =>\n          THUMB_RADIUS +\n          (availableWidth * (v - this.min)) / range -\n          TICK_WIDTH / 2\n      );\n\n    const tickPositionsInGradient = tickPositions\n      ?.map(\n        p =>\n          `transparent ${p}px, ${TICK_COLOR} ${p}px, ${TICK_COLOR} ${\n            p + TICK_WIDTH\n          }px, transparent ${p + TICK_WIDTH}px`\n      )\n      .join(', ');\n    const ticksBackground = tickPositions?.length\n      ? `linear-gradient(to right, ${tickPositionsInGradient}), `\n      : null;\n\n    const styles = [\n      `input[type=\"range\"]::-webkit-slider-runnable-track {\n        background: ${ticksBackground ? ticksBackground : ''}${\n        this.#background ??\n        `linear-gradient(to right, var(--color-input) ${valueWidth}px, #ddd ${valueWidth}px)`\n      };\n      }${\n        this.#background\n          ? ''\n          : `\n       input[type=\"range\"]:hover::-webkit-slider-runnable-track {\n        background: ${\n          ticksBackground ? ticksBackground : ''\n        }linear-gradient(to right, var(--color-input-hover) ${valueWidth}px, #ddd ${valueWidth}px);\n      }\n        input[type=\"range\"]:active::-webkit-slider-runnable-track {\n        background: ${\n          ticksBackground ? ticksBackground : ''\n        }linear-gradient(to right, var(--color-input-active) ${valueWidth}px, #ddd ${valueWidth}px);\n      }`\n      }`,\n    ];\n\n    if (this.#thumbColor != null) {\n      styles.push(\n        `input[type=\"range\"]::-webkit-slider-thumb { background: ${\n          this.#thumbColor\n        } !important}`\n      );\n    }\n    this.#backgroundStyle.innerHTML = styles.join('\\n');\n  }\n}\n\ncustomElements.define('string-art-range-input', StringArtRangeInput);\n","import { Dimensions } from '../types/general.types';\n\nconst sizeControls = document.querySelector('#size_controls');\n\nconst elements = {\n  sizeSelect: sizeControls.querySelector('#size_select'),\n  sizeCustom: sizeControls.querySelector('#size_custom'),\n  width: sizeControls.querySelector('#size_custom_width'),\n  height: sizeControls.querySelector('#size_custom_height'),\n  orientationSelect: sizeControls.querySelector('#size_orientation_select'),\n};\n\nfunction cmToPixels(cm, dpi = 300) {\n  return Math.floor((cm / 2.54) * dpi);\n}\n\nconst SCREEN_SIZE = [\n  Math.floor(window.screen.width),\n  Math.floor(window.screen.height),\n];\n\nconst SIZES = [\n  { id: 'fit', name: 'Fit to screen' },\n  {\n    id: 'A4',\n    value: [20, 28].map(v => cmToPixels(v)),\n    orientationSelect: true,\n  },\n  {\n    id: 'A3',\n    value: [28, 40].map(v => cmToPixels(v)),\n    orientationSelect: true,\n  },\n  {\n    id: 'screen',\n    name: `Screen size (${SCREEN_SIZE.join('x')})`,\n    value: SCREEN_SIZE,\n  },\n  { id: 'custom', name: 'Custom...' },\n];\n\nexport default class EditorSizeControls {\n  element = document.querySelector('#size_controls');\n\n  constructor({ getCurrentSize }) {\n    const sizeOptionsFragment = document.createDocumentFragment();\n    SIZES.forEach(size => {\n      const sizeListItem = document.createElement('option');\n      sizeListItem.setAttribute('value', size.id);\n      sizeListItem.innerText = size.name ?? size.id;\n      sizeOptionsFragment.appendChild(sizeListItem);\n    });\n    elements.sizeSelect.appendChild(sizeOptionsFragment);\n    this.selectedSize = SIZES[0];\n\n    elements.sizeSelect.addEventListener('change', e => {\n      const selectedSizeId = e.target.value;\n      const size = SIZES.find(({ id }) => id === selectedSizeId);\n      this.selectedSize = size;\n\n      if (size.id === 'custom') {\n        elements.sizeCustom.removeAttribute('hidden');\n        const [width, height] = getCurrentSize();\n        elements.width.value = width;\n        elements.height.value = height;\n      } else {\n        elements.sizeCustom.setAttribute('hidden', 'hidden');\n        this._notifyOnChange(this.getValue());\n      }\n\n      if (size.orientationSelect) {\n        elements.orientationSelect.removeAttribute('hidden');\n      } else {\n        elements.orientationSelect.setAttribute('hidden', 'hidden');\n      }\n    });\n\n    elements.orientationSelect.addEventListener('change', e => {\n      this._notifyOnChange(this.getValue());\n    });\n\n    elements.sizeCustom.addEventListener('focusin', e => {\n      e.target.select();\n    });\n\n    elements.sizeCustom.addEventListener('input', () => {\n      this._notifyOnChange([\n        elements.width.value ? parseInt(elements.width.value) : null,\n        elements.height.value ? parseInt(elements.height.value) : null,\n      ]);\n    });\n  }\n\n  _notifyOnChange([width, height] = []) {\n    this.element.dispatchEvent(\n      new CustomEvent<Dimensions | null>('sizechange', {\n        detail: width && height ? [width, height] : null,\n      })\n    );\n  }\n\n  getValue() {\n    if (this.selectedSize.id === 'custom') {\n      return [\n        parseInt(elements.width.value, 10),\n        parseInt(elements.height.value, 10),\n      ];\n    } else {\n      let value = this.selectedSize.value;\n      if (\n        this.selectedSize.orientationSelect &&\n        elements.orientationSelect.value === 'horizontal'\n      ) {\n        value = Array.from(value).reverse();\n      }\n      return value;\n    }\n  }\n}\n","import patternTypes from '../pattern_types';\nimport CanvasRenderer from '../renderers/CanvasRenderer';\nimport type StringArt from '../StringArt';\nimport Persistance from '../Persistance';\nimport EventBus from '../helpers/EventBus';\n\nconst THUMBNAIL_WIDTH_PX = '100px';\nconst MINIMIZED_CLASS = 'minimized';\n\nexport class Thumbnails extends EventBus<{ select: { patternId: string }}> {\n  elements: Record<string, HTMLElement> = {\n    root: document.querySelector('#pattern_select_panel'),\n    thumbnails: document.querySelector('#thumbnails'),\n    toggleBtn: document.querySelector('#pattern_select_btn'),\n    dropdown: document.querySelector('#pattern_select_dropdown'),\n    patternName: document.querySelector('#pattern_name')\n  };\n\n  pattern: StringArt<any>;\n  thumbnailsRendered = false;\n  _onClickOutside: (e: MouseEvent) => void;\n\n  constructor(persistance: Persistance) {\n    super();\n\n    this.elements.toggleBtn.addEventListener('click', () => this.toggle());\n\n    persistance.addEventListener('newPattern', ({ pattern }) => {\n      if (this.isOpen) {\n      this.createThumbnails();\n      } else {\n        this.thumbnailsRendered = false;\n      }\n\n      this.setCurrentPattern(pattern);\n      this.emit('select', { patternId: pattern.id })\n    });\n\n    persistance.addEventListener('save', ({ pattern }) => {\n      if (this.isOpen) {\n      this.createThumbnails();\n      } else {\n        this.thumbnailsRendered = false;\n      }\n\n      this.setCurrentPattern(pattern);\n    });\n\n    persistance.addEventListener('deletePattern', ({pattern}) => {\n      if (this.isOpen) {\n        const thumbnail = this.elements.thumbnails.querySelector(`[data-pattern=\"${pattern.id}\"]`);\n        thumbnail.remove();\n      } else {\n        this.thumbnailsRendered = false;\n      }\n    });\n\n    this.elements.thumbnails.addEventListener('click', e => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      const link =\n        e.target instanceof HTMLElement &&\n        (e.target.closest('[data-pattern]') as HTMLElement);\n\n      if (!link) {\n        return false;\n      }\n\n      this.emit('select', { patternId: link.dataset.pattern });\n     \n      this.toggle();\n    });\n  }\n\n  get isOpen(): boolean {\n    return !this.elements.root.classList.contains(MINIMIZED_CLASS);\n  }\n\n  toggle() {\n    if (!this.isOpen) {\n      this.open();\n    } else if (this.pattern) {\n      this.close();\n    }\n  }\n\n  open() {\n    if (!this.isOpen) {\n      this.elements.root.classList.remove(MINIMIZED_CLASS);\n      if (!this.thumbnailsRendered) {\n        this.createThumbnails();\n        this.thumbnailsRendered = true;\n      }\n\n      this._onClickOutside = e => {\n        if (\n          e.target instanceof HTMLElement &&\n          !e.target.closest('#pattern_select_panel')\n        ) {\n          this.toggle();\n        }\n      };\n\n      document.body.addEventListener('mousedown', this._onClickOutside);\n    }\n  }\n\n  close() {\n    if (this.isOpen) {\n      this.elements.root.classList.add(MINIMIZED_CLASS);\n      document.body.removeEventListener('mousedown', this._onClickOutside);\n      this._onClickOutside = null;\n    }\n  }\n\n  setCurrentPattern(pattern: StringArt<any>) {\n    this.pattern = pattern;\n    this.elements.patternName.innerText = pattern?.name ?? 'Choose a pattern';\n  }\n\n  #createThumbnailsSection(title: string, patterns: StringArt<any>[]): void {\n    const section = document.createElement(\"section\");\n    \n    const sectionTitle = document.createElement('h3');\n    sectionTitle.className = 'pattern_select_thumbnails_title';\n    sectionTitle.innerText = title;\n    section.appendChild(sectionTitle);\n    \n    const thumbnailsList = document.createElement(\"ul\");\n    thumbnailsList.className = \"pattern_select_thumbnails\";\n    section.appendChild(thumbnailsList);\n    \n    const thumbnailsFragment = document.createDocumentFragment();\n    patterns.forEach(pattern => {\n      const patternLink = document.createElement('a');\n\n      patternLink.style.width = patternLink.style.height = THUMBNAIL_WIDTH_PX;\n      pattern.renderer = new CanvasRenderer(patternLink);\n\n      pattern.assignConfig({\n        margin: 1,\n        enableBackground: false,\n        nailRadius: 0.5,\n        ...(pattern.constructor as typeof StringArt<any>).thumbnailConfig,\n      });\n\n      const li = document.createElement('li');\n      thumbnailsFragment.appendChild(li);\n\n      patternLink.href = `?pattern=${pattern.id}`;\n      patternLink.setAttribute('data-pattern', pattern.id);\n      patternLink.title = pattern.name;\n      li.appendChild(patternLink);\n    });\n\n    thumbnailsList.appendChild(thumbnailsFragment);\n\n    this.elements.thumbnails.appendChild(section);\n\n    patterns.forEach(pattern => pattern.draw());\n  }\n\n  createThumbnails() {\n    this.elements.thumbnails.innerHTML = \"\";\n\n    const savedPatterns = Persistance.getSavedPatterns();\n    if (savedPatterns.length) {\n      this.#createThumbnailsSection('My Patterns', Persistance.getSavedPatterns());\n    }\n    const patterns = patternTypes.map(PatternType => new PatternType);\n    this.#createThumbnailsSection('Built-in patterns', patterns);\n  }\n}\n","import Renderer from './Renderer';\nimport { PI2 } from '../helpers/math_utils';\nimport type { Coordinates, Dimensions } from '../types/general.types';\nimport type { Nail } from '../types/stringart.types';\nimport { ColorValue } from '../helpers/color/color.types';\n\nexport default class CanvasRenderer extends Renderer {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n  pixelRatio: number;\n\n  constructor(parentElement: HTMLElement) {\n    super(parentElement);\n\n    this.canvas = document.createElement('canvas');\n    this.ctx = this.canvas.getContext('2d');\n\n    const dpr = window.devicePixelRatio || 1;\n    this.pixelRatio = dpr;\n    this.ctx.globalCompositeOperation = 'source-over';\n\n    parentElement.appendChild(this.canvas);\n  }\n\n  get element() {\n    return this.canvas;\n  }\n\n  /**\n   * Clears the canvas and resets the width and height\n   */\n  reset() {\n    this.ctx.clearRect(0, 0, ...this.getSize());\n    this.canvas.removeAttribute('width');\n    this.canvas.removeAttribute('height');\n\n    const [width, height] = this.getSize();\n    this.canvas.setAttribute('width', String(width));\n    this.canvas.setAttribute('height', String(height));\n  }\n\n  setColor(color: ColorValue) {\n    this.ctx.strokeStyle = color;\n  }\n\n  setLineWidth(width: number) {\n    this.ctx.lineWidth = width;\n  }\n\n  setBackground(color: ColorValue) {\n    this.ctx.globalCompositeOperation = 'destination-over';\n    this.ctx.fillStyle = color;\n    this.ctx.fillRect(0, 0, ...this.getSize());\n    this.ctx.globalCompositeOperation = 'source-over';\n  }\n\n  getSize(): Dimensions {\n    return [\n      this.canvas.clientWidth * this.pixelRatio,\n      this.canvas.clientHeight * this.pixelRatio,\n    ];\n  }\n\n  renderLines(startPosition: Coordinates, ...positions: Array<Coordinates>) {\n    this.ctx.beginPath();\n    this.ctx.moveTo(...startPosition);\n\n    for (const position of positions) {\n      this.ctx.lineTo(...position);\n    }\n\n    this.ctx.stroke();\n  }\n\n  renderNails(\n    nails: ReadonlyArray<Nail>,\n    {\n      color,\n      fontSize,\n      radius,\n      renderNumbers,\n      margin = 0,\n    }: {\n      color: ColorValue;\n      fontSize: number;\n      radius: number;\n      renderNumbers?: boolean;\n      margin?: number;\n    }\n  ) {\n    const centerX = this.canvas.width / 2;\n\n    this.ctx.globalCompositeOperation = 'source-over';\n    this.ctx.beginPath();\n    this.ctx.fillStyle = color;\n    this.ctx.textBaseline = 'middle';\n    this.ctx.font = `${fontSize}px sans-serif`;\n    const nailNumberOffset = radius + margin;\n\n    nails.forEach(({ point: [x, y], number }) => {\n      this.ctx.moveTo(x + radius, y);\n      this.ctx.arc(x, y, radius, 0, PI2);\n      if (renderNumbers && number != null) {\n        const isRightAlign = x < centerX;\n\n        const numberPosition: Coordinates = [\n          isRightAlign ? x - nailNumberOffset : x + nailNumberOffset,\n          y,\n        ];\n\n        this.ctx.textAlign = isRightAlign ? 'right' : 'left';\n        this.ctx.fillText(String(number), ...numberPosition);\n      }\n    });\n\n    this.ctx.fill();\n  }\n\n  clear() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  toDataURL(): string {\n    return this.canvas.toDataURL();\n  }\n}\n","import { ColorValue } from '../helpers/color/color.types';\nimport type { Coordinates, Dimensions } from '../types/general.types';\nimport type { Nail, NailsRenderOptions } from '../types/stringart.types';\n\nexport default abstract class Renderer {\n  parentElement: HTMLElement;\n  color?: ColorValue;\n  size: Dimensions;\n\n  constructor(parentElement: HTMLElement) {\n    this.parentElement = parentElement;\n  }\n\n  destroy() {\n    this.element.remove();\n  }\n\n  get element(): Element {\n    throw new Error('element getter not implemented!');\n  }\n\n  setColor(color: ColorValue) {\n    this.color = color;\n  }\n\n  abstract reset(): void;\n  abstract setLineWidth(width: number): void;\n  abstract renderLines(\n    startPosition: Coordinates,\n    ...positions: Array<Coordinates>\n  ): void;\n  abstract renderNails(\n    nails: ReadonlyArray<Nail>,\n    options: NailsRenderOptions\n  ): void;\n  abstract clear(): void;\n  abstract toDataURL(): string;\n\n  setBackground(color: ColorValue) {}\n\n  getSize(): Dimensions {\n    const { width, height } = this.parentElement.getBoundingClientRect();\n    return [width, height];\n  }\n\n  setSize(size: Dimensions | null) {\n    this.element.removeAttribute('width');\n    this.element.removeAttribute('height');\n\n    if (this.element instanceof HTMLElement) {\n      if (size) {\n        this.element.style.width = `${size[0]}px`;\n        this.element.style.height = `${size[1]}px`;\n      } else {\n        this.element.removeAttribute('style');\n      }\n    }\n  }\n}\n","import EventBus from './helpers/EventBus';\nimport patternTypes from './pattern_types';\nimport StringArt, { Pattern } from './StringArt';\nimport { AppData, PatternData } from './types/persistance.types';\nimport type InputDialog from './components/dialogs/InputDialog';\nimport { confirm, prompt } from './helpers/dialogs';\n\nconst APP_DATA_STORAGE_KEY = 'string_art_app_data';\n\nexport default class Persistance extends EventBus<{\n  newPattern: { pattern: StringArt<any> };\n  deletePattern: { pattern: StringArt<any> };\n  save: { pattern: StringArt<any> };\n}> {\n  elements: {\n    saveDialog: InputDialog;\n  };\n\n  currentPattern: StringArt<any>;\n\n  constructor() {\n    super();\n\n    this.elements = {\n      saveDialog: document.querySelector('#save_dialog'),\n    };\n\n    document.querySelector('#pattern_menu').addEventListener('select', e => {\n      // @ts-ignore\n      switch (e.detail.value) {\n        case 'save_as':\n          this.#showSaveAsDialog();\n          break;\n        case 'delete':\n          this.deletePattern();\n          break;\n        case 'save':\n          this.saveCurrentPattern();\n          break;\n        case 'rename':\n          this.renameCurrentPattern();\n          break;\n      }\n    });\n\n    document.querySelector('#save_btn').addEventListener('click', () => {\n      if (this.currentPattern.isTemplate) {\n        this.#showSaveAsDialog();\n      } else {\n        this.saveCurrentPattern();\n      }\n    });\n  }\n\n  #showSaveAsDialog() {\n    const nextId = this.#getNextAvailableId();\n    const defaultName = `Pattern #${nextId}`;\n\n    prompt({\n      title: 'Save pattern',\n      description: 'Name this pattern:',\n      submit: 'Save',\n      value: defaultName,\n    }).then(\n      patternName => {\n        this.saveNewPattern({\n          type: this.currentPattern.type,\n          config: this.currentPattern.config,\n          name:\n            patternName == null || patternName === ''\n              ? defaultName\n              : patternName,\n        });\n      },\n      () => {}\n    );\n  }\n\n  setPattern(pattern: StringArt<any>) {\n    this.currentPattern = pattern;\n  }\n\n  static patternDataToStringArt({\n    type: patternType,\n    ...patternData\n  }: PatternData): StringArt<any> {\n    const Pattern = patternTypes.find(({ type }) => type === patternType);\n    if (Pattern == null) {\n      throw new Error(`No pattern of type \"${patternType}\" found!`);\n    }\n\n    const pattern = new Pattern();\n    Object.assign(pattern, patternData);\n\n    return pattern;\n  }\n\n  static getSavedPatterns(): StringArt<any>[] {\n    const { patterns } = this.loadAppData();\n    return patterns.map(this.patternDataToStringArt);\n  }\n\n  static getPatternByID(patternId: string): StringArt<any> | null {\n    const patternData = this.loadPatternDataById(patternId);\n    return patternData ? this.patternDataToStringArt(patternData) : null;\n  }\n\n  static loadPatternDataById(patternId: string): PatternData | null {\n    const { patterns } = this.loadAppData();\n    return patterns.find(({ id }) => id === patternId);\n  }\n\n  #getNextAvailableId(): string {\n    const appData = Persistance.loadAppData();\n    const lastId = appData?.patterns?.length\n      ? Number(appData.patterns[appData.patterns.length - 1].id)\n      : 0;\n    const nextId = isNaN(lastId) ? 1 : lastId + 1;\n    return String(nextId);\n  }\n\n  saveNewPattern(patternData: Omit<PatternData, 'id'>): PatternData {\n    const appData = Persistance.loadAppData();\n    const nextId = this.#getNextAvailableId();\n\n    const newPatternData: PatternData = {\n      ...patternData,\n      id: nextId,\n    };\n\n    appData.patterns.push(newPatternData);\n    this.saveAppData(appData);\n\n    this.emit('newPattern', {\n      pattern: Persistance.patternDataToStringArt(newPatternData),\n    });\n\n    return newPatternData;\n  }\n\n  savePattern(patternData: PatternData) {\n    const appData = Persistance.loadAppData();\n\n    const patternIndex = appData.patterns.findIndex(\n      ({ id }) => id === this.currentPattern.id\n    );\n    if (patternIndex !== -1) {\n      appData.patterns[patternIndex] = patternData;\n      this.saveAppData(appData);\n\n      this.emit('save', {\n        pattern: Persistance.patternDataToStringArt(patternData),\n      });\n    }\n  }\n\n  saveCurrentPattern() {\n    const newPatternData: PatternData = {\n      id: this.currentPattern.id,\n      name: this.currentPattern.name,\n      type: this.currentPattern.type,\n      config: this.currentPattern.config,\n    };\n\n    this.savePattern(newPatternData);\n    return newPatternData;\n  }\n\n  renameCurrentPattern() {\n    prompt({\n      title: 'Rename',\n      description: 'Name this pattern:',\n      submit: 'Save',\n      value: this.currentPattern.name,\n    }).then(newPatternName => {\n      if (newPatternName !== this.currentPattern.name) {\n        const patternData = Persistance.loadPatternDataById(\n          this.currentPattern.id\n        );\n        patternData.name = newPatternName;\n        this.savePattern(patternData);\n      }\n\n      this.currentPattern.name = newPatternName;\n    });\n  }\n\n  deletePattern() {\n    confirm({\n      title: 'Delete pattern',\n      description: 'Are you sure you wish to delete this pattern?',\n      submit: 'Delete',\n      type: 'error',\n    }).then(\n      () => {\n        const appData = Persistance.loadAppData();\n        const patternIndex = appData.patterns.findIndex(\n          ({ id }) => id === this.currentPattern.id\n        );\n        if (patternIndex === -1) {\n          throw new Error(\n            `Can't delete pattern with ID \"${this.currentPattern.id}\", it's not found!`\n          );\n        }\n\n        const pattern = appData.patterns.splice(patternIndex, 1)[0];\n        this.saveAppData(appData);\n\n        this.emit('deletePattern', {\n          pattern: Persistance.patternDataToStringArt(pattern),\n        });\n      },\n      () => {}\n    );\n  }\n\n  static loadAppData(): AppData {\n    const rawData = localStorage.getItem(APP_DATA_STORAGE_KEY);\n    try {\n      return rawData ? JSON.parse(rawData) : { patterns: [] };\n    } catch (error) {\n      throw new Error(\n        'App data is corrupted, failed to load it. ' + error.message\n      );\n    }\n  }\n\n  saveAppData(appData: AppData): void {\n    localStorage.setItem(APP_DATA_STORAGE_KEY, JSON.stringify(appData));\n  }\n}\n","export default class EventBus<TEvents extends Record<string, any>> {\n  #eventHandlers: {\n    [K in keyof TEvents]: Array<(payload: TEvents[K]) => void>;\n  } = {} as any;\n\n  addEventListener<K extends keyof TEvents>(\n    event: K,\n    handler: (payload: TEvents[K]) => void\n  ) {\n    const handlers = (this.#eventHandlers[event] ??= []);\n    if (!handlers.includes(handler)) {\n      handlers.push(handler);\n    }\n  }\n\n  removeEventListener<K extends keyof TEvents>(\n    event: K,\n    handler: (payload: TEvents[K]) => void\n  ) {\n    const handlers = this.#eventHandlers[event];\n    if (!handlers) return;\n\n    const index = handlers.indexOf(handler);\n    if (index !== -1) {\n      handlers.splice(index, 1);\n    }\n  }\n\n  protected emit<K extends keyof TEvents>(event: K, payload: TEvents[K]) {\n    this.#eventHandlers[event]?.forEach(handler => handler(payload));\n  }\n}\n","import type InputDialog from '../components/dialogs/InputDialog';\nimport type ConfirmDialog from '../components/dialogs/ConfirmDialog';\nimport type { ConfirmDialogType } from '../components/dialogs/ConfirmDialog';\n\nexport interface ConfirmOptions {\n  title: string;\n  description?: string;\n  submit?: string;\n  cancel?: string;\n  type?: ConfirmDialogType;\n}\nexport type PromptOptions = ConfirmOptions & {\n  value?: string;\n};\n\nconst promptDialogId = 'prompt_dialog';\nexport function prompt({ value, ...options }: PromptOptions): Promise<string> {\n  let dialog: InputDialog = document.querySelector(`#${promptDialogId}`);\n  if (!dialog) {\n    dialog = document.createElement('input-dialog') as InputDialog;\n    dialog.id = promptDialogId;\n    document.body.appendChild(dialog);\n  }\n\n  ['title', 'description', 'submit', 'cancel', 'type'].forEach(attr => {\n    if (options[attr] != null && options[attr] !== '') {\n      dialog.setAttribute(attr, options[attr]);\n    } else {\n      dialog.removeAttribute(attr);\n    }\n  });\n\n  return dialog.show(value);\n}\n\nconst CONFIRM_DIALOG_ID = 'confirm_dialog';\n\nexport function confirm(options: ConfirmOptions): Promise<void> {\n  let dialog: ConfirmDialog = document.querySelector(`#${CONFIRM_DIALOG_ID}`);\n  if (!dialog) {\n    dialog = document.createElement('confirm-dialog') as ConfirmDialog;\n    dialog.id = CONFIRM_DIALOG_ID;\n    document.body.appendChild(dialog);\n  }\n\n  ['title', 'description', 'submit', 'cancel', 'type'].forEach(attr => {\n    if (options[attr] != null && options[attr] !== '') {\n      dialog.setAttribute(attr, options[attr]);\n    } else {\n      dialog.removeAttribute(attr);\n    }\n  });\n\n  return dialog.show();\n}\n","import StringArt from './StringArt';\n\nconst MAX_FLOAT_DECIMALS = 6;\n\nexport function serializeConfig(pattern: StringArt<any>): string {\n  const { defaultConfig, config } = pattern;\n\n  const nonDefaultConfigValues = Object.entries(config).map(([key, value]) => {\n    if (value === defaultConfig[key]) {\n      return null;\n    }\n\n    if (typeof value === 'boolean') {\n      return `!${value ? 1 : 0}`;\n    }\n\n    if (typeof value === 'number') {\n      return parseFloat(value.toFixed(MAX_FLOAT_DECIMALS));\n    }\n\n    return value;\n  });\n\n  while (nonDefaultConfigValues[nonDefaultConfigValues.length - 1] === null) {\n    nonDefaultConfigValues.pop();\n  }\n\n  if (!nonDefaultConfigValues.length) {\n    return '';\n  }\n\n  const serializedConfigValues = nonDefaultConfigValues\n    .join('_')\n    .replace(/\\_{2,}/g, match => '~' + match.length + '_');\n  return serializedConfigValues;\n}\n\nconst numberRegExp = /^\\-?\\d+(\\.\\d+)?$/;\nconst booleanRegExp = /^(?:!)([01])$/;\n\nexport function deserializeConfig<TConfig>(\n  pattern: StringArt<TConfig>,\n  serializedCofig: string\n): TConfig {\n  const serializedConfigValues = serializedCofig\n    .replace(/(?:~)(\\d+)(?:_)/g, (_, commaCount) =>\n      new Array(+commaCount).fill('_').join('')\n    )\n    .split('_')\n    .map(v => {\n      if (v === '') {\n        return null;\n      }\n\n      if (numberRegExp.test(v)) {\n        return parseFloat(v);\n      }\n\n      const booleanMatch = v.match(booleanRegExp);\n      if (booleanMatch) {\n        return booleanMatch[1] === '1';\n      }\n\n      return v;\n    });\n\n  const configKeys = Object.keys(pattern.defaultConfig);\n\n  return serializedConfigValues.reduce((config, serializedValue, i) => {\n    if (serializedValue !== null) {\n      const key = configKeys[i];\n      return { ...config, [key]: serializedValue };\n    }\n\n    return config;\n  }, {} as TConfig);\n}\n","import type Renderer from './renderers/Renderer';\nimport type StringArt from './StringArt';\n\nexport interface ShareInput {\n  renderer: Renderer;\n  pattern: StringArt<any>;\n}\n\nexport async function share(input: ShareInput) {\n  try {\n    navigator.share(await getShareData(input));\n  } catch (error) {\n    alert('Error: ' + error.message);\n  }\n}\n\nexport async function isShareSupported(input: ShareInput) {\n  if (!navigator.share) {\n    return false;\n  }\n\n  const shareData = await getShareData(input);\n  return navigator.canShare(shareData);\n}\n\nasync function getShareData({ renderer, pattern }: ShareInput) {\n  const dataUrl = renderer.toDataURL();\n  const blob = await (await fetch(dataUrl)).blob();\n  const files = [\n    new File([blob], pattern.name + '.jpg', {\n      type: blob.type,\n      lastModified: new Date().getTime(),\n    }),\n  ];\n  return {\n    url: window.location.href,\n    files,\n    title: document.title,\n    text: 'String Art Studio - ' + pattern.name,\n  };\n}\n","const swFilename = 'service-worker.js';\n\nexport async function initServiceWorker() {\n  if (!navigator.serviceWorker || document.location.hostname === '127.0.0.1') {\n    return;\n  }\n\n  try {\n    const registration = await navigator.serviceWorker.register(swFilename);\n    registration.onupdatefound = () => {\n      const installingWorker = registration.installing;\n      if (installingWorker == null) {\n        return;\n      }\n      installingWorker.onstatechange = () => {\n        if (installingWorker.state === 'installed') {\n          if (navigator.serviceWorker.controller) {\n            console.log(\n              'New content is available and will be used when all ' +\n                'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n            );\n          } else {\n            console.log('Content is cached for offline use.');\n          }\n        }\n      };\n    };\n  } catch (error) {\n    console.error('Error during service worker registration:', error);\n  }\n}\n","import Renderer from './Renderer.js';\nimport { PI2 } from '../helpers/math_utils.js';\nimport type { Dimensions } from '../types/general.types.js';\nimport { ColorValue } from '../helpers/color/color.types.js';\n\nconst SVG_NS = 'http://www.w3.org/2000/svg';\n\nexport default class SVGRenderer extends Renderer {\n  svg: SVGElement;\n  backgroundGroup: SVGGElement;\n  background: SVGRectElement = null;\n  linesGroup: SVGGElement;\n  nailsGroup: SVGGElement;\n  nailsCirclesGroup: SVGGElement;\n  nailsTextGroup: SVGGElement;\n  currentColor: ColorValue | null = null;\n  lineWidth: number | string = 1;\n  currentLineGroup: SVGGElement = null;\n\n  constructor(parentElement) {\n    super(parentElement);\n\n    this.svg = document.createElementNS(SVG_NS, 'svg');\n    this.svg.style.setProperty('display', 'block');\n    this.backgroundGroup = document.createElementNS(SVG_NS, 'g');\n    this.backgroundGroup.setAttribute('data-id', 'background');\n    this.linesGroup = document.createElementNS(SVG_NS, 'g');\n    this.linesGroup.setAttribute('data-id', 'lines');\n    this.nailsGroup = document.createElementNS(SVG_NS, 'g');\n    this.nailsGroup.setAttribute('data-id', 'nails');\n\n    this.nailsCirclesGroup = document.createElementNS(SVG_NS, 'g');\n    this.nailsCirclesGroup.setAttribute('data-id', 'nailsCircles');\n\n    this.nailsTextGroup = document.createElementNS(SVG_NS, 'g');\n    this.nailsTextGroup.setAttribute('data-id', 'nailsText');\n\n    this.nailsGroup.appendChild(this.nailsCirclesGroup);\n    this.nailsGroup.appendChild(this.nailsTextGroup);\n\n    this.svg.appendChild(this.backgroundGroup);\n    this.svg.appendChild(this.linesGroup);\n    this.svg.appendChild(this.nailsGroup);\n\n    this.svg.setAttribute('xmlns', SVG_NS);\n\n    parentElement.appendChild(this.svg);\n  }\n\n  get element() {\n    return this.svg;\n  }\n\n  reset() {\n    this.linesGroup.innerHTML = '';\n    this.nailsCirclesGroup.innerHTML = '';\n    this.nailsTextGroup.innerHTML = '';\n\n    const [width, height] = this.getSize().map(Math.trunc);\n    this.svg.setAttributeNS(SVG_NS, 'viewBox', `0 0 ${width} ${height}`);\n    this.svg.setAttributeNS(SVG_NS, 'width', String(width));\n    this.svg.setAttributeNS(SVG_NS, 'height', String(height));\n    this.svg.style.width = width + 'px';\n    this.svg.style.height = height + 'px';\n    this.currentColor = null;\n    this.lineWidth = null;\n  }\n\n  setColor(color: ColorValue) {\n    if (color !== this.currentColor) {\n      this.currentLineGroup = document.createElementNS(SVG_NS, 'g');\n      this.currentLineGroup.setAttribute('stroke', color);\n      this.currentLineGroup.setAttribute(\n        'stroke-width',\n        String(this.lineWidth)\n      );\n      this.linesGroup.appendChild(this.currentLineGroup);\n      this.currentColor = color;\n    }\n  }\n\n  setLineWidth(width) {\n    this.lineWidth = width ?? '1';\n    this.linesGroup.setAttributeNS(SVG_NS, 'stroke-width', width ?? '1');\n    this.linesGroup.childNodes.forEach(group => {\n      if (group instanceof SVGGElement) {\n        group.setAttributeNS(SVG_NS, 'stroke-width', width ?? '1');\n      }\n    });\n  }\n\n  setBackground(color: ColorValue) {\n    if (color) {\n      if (!this.background) {\n        this.background = document.createElementNS(SVG_NS, 'rect');\n        this.background.setAttribute('width', '100%');\n        this.background.setAttribute('height', '100%');\n        this.backgroundGroup.appendChild(this.background);\n      }\n\n      this.background.setAttribute('fill', color);\n    } else {\n      this.background = null;\n      this.backgroundGroup.innerHTML = '';\n    }\n  }\n\n  getSize(): Dimensions {\n    return [this.svg.clientWidth, this.svg.clientHeight];\n  }\n\n  setSize(size: Dimensions | null) {\n    super.setSize(size);\n\n    if (size) {\n      const [width, height] = size.map(Math.trunc);\n\n      this.svg.setAttributeNS(SVG_NS, 'viewBox', `0 0 ${width} ${height}`);\n      this.svg.setAttributeNS(SVG_NS, 'width', String(width));\n      this.svg.setAttributeNS(SVG_NS, 'height', String(height));\n    }\n  }\n  renderLines(startPosition, ...positions) {\n    let previousPoint = startPosition;\n    const fragment = document.createDocumentFragment();\n\n    for (const position of positions) {\n      const line = document.createElementNS(SVG_NS, 'line');\n      line.setAttribute('x1', String(Math.trunc(previousPoint[0])));\n      line.setAttribute('y1', String(Math.trunc(previousPoint[1])));\n      line.setAttribute('x2', String(Math.trunc(position[0])));\n      line.setAttribute('y2', String(Math.trunc(position[1])));\n      previousPoint = position;\n\n      fragment.appendChild(line);\n    }\n\n    this.currentLineGroup.appendChild(fragment);\n  }\n\n  renderNails(nails, { color, fontSize, radius, renderNumbers, margin = 0 }) {\n    const centerX = this.getSize()[0] / 2;\n    this.nailsCirclesGroup.innerHTML = this.nailsTextGroup.innerHTML = '';\n    const circlesFragment = document.createDocumentFragment();\n    const textFragment = document.createDocumentFragment();\n    this.nailsGroup.setAttribute('fill', color);\n    const nailNumberOffset = radius + margin;\n\n    this.nailsTextGroup.style.fontSize = fontSize;\n    nails.forEach(({ point: [x, y], number }) => {\n      const circle = document.createElementNS(SVG_NS, 'circle');\n      circle.setAttribute('cx', x);\n      circle.setAttribute('cy', y);\n      circle.setAttribute('r', radius);\n      circlesFragment.appendChild(circle);\n\n      if (renderNumbers && number != null) {\n        const isRightAlign = x < centerX;\n\n        const numberPosition = [\n          isRightAlign ? x - nailNumberOffset : x + nailNumberOffset,\n          y,\n        ];\n\n        const textEl = document.createElementNS(SVG_NS, 'text');\n        textEl.innerHTML = String(number);\n        textEl.setAttribute('x', numberPosition[0]);\n        textEl.setAttribute('y', numberPosition[1]);\n        if (isRightAlign) {\n          textEl.setAttribute('text-anchor', 'end');\n        }\n        textFragment.appendChild(textEl);\n      }\n    });\n\n    this.nailsCirclesGroup.appendChild(circlesFragment);\n    this.nailsTextGroup.appendChild(textFragment);\n  }\n\n  clear() {\n    this.linesGroup.innerHTML = '';\n    this.nailsGroup.innerHTML = '';\n  }\n\n  toDataURL() {\n    return '';\n  }\n}\n","import SVGRenderer from '../renderers/SVGRenderer.js';\nimport { downloadFile } from './Download.js';\n\nexport function downloadPatternAsSVG(pattern, size) {\n  const parentEl = document.createElement('article');\n  parentEl.style.width = size[0] + 'px';\n  parentEl.style.height = size[1] + 'px';\n  document.body.appendChild(parentEl);\n  const svgRenderer = new SVGRenderer(parentEl);\n\n  const PatternConstructor = pattern.constructor;\n  const svgPattern = new PatternConstructor(svgRenderer);\n\n  svgPattern.setConfig(pattern.config);\n  svgPattern.draw();\n\n  var svgData = svgPattern.renderer.svg.outerHTML;\n  var svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });\n  var svgUrl = URL.createObjectURL(svgBlob);\n\n  downloadFile(svgUrl, pattern.name + '.svg');\n  document.body.removeChild(parentEl);\n}\n","export function downloadFile(dataUrl, fileName) {\n  const downloadLink = document.createElement('a');\n  downloadLink.href = dataUrl;\n  downloadLink.download = fileName;\n  document.body.appendChild(downloadLink);\n  downloadLink.click();\n  document.body.removeChild(downloadLink);\n}\n","import './StringArtRangeInput';\nimport './StringArtHueInput';\nimport './DropdownMenu';\nimport './DropdownMenuItem';\nimport './dialogs/InputDialog';\nimport './dialogs/ConfirmDialog';\n","export class DropdownMenu extends HTMLElement {\n  private button!: HTMLButtonElement;\n  #buttonStyle: string;\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot!.innerHTML = `\n      <style>\n        :host {\n          display: inline-block;\n          position: relative;\n        }\n\n        button {\n          display: block;\n          padding: 10px 15px;\n          background: transparent;\n          color: white;\n          border: none;\n          cursor: pointer;\n          font: inherit;\n        }\n\n        button:hover {\n          background: #444;\n        }\n\n        button:focus {\n          background: rgba(255,255,255,.2)\n        }\n        ul {\n          display: none;\n          position: absolute;\n          top: 100%;\n          right: 0;\n          min-width: 120px;\n          background: var(--color-dialog-background);\n          border: var(--border-dialog);\n          margin: 0;\n          padding: 0;\n          list-style: none;\n          z-index: 1000;\n          box-shadow: 1px 1px 10px rgba(0,0,0,.7)\n        }\n\n        :host(.open) ul {\n          display: block;\n        }\n      </style>\n\n      <button aria-haspopup=\"true\" aria-expanded=\"false\">\n        <slot name=\"label\">Menu</slot>\n      </button>\n      <ul role=\"menu\">\n        <slot></slot>\n      </ul>\n    `;\n  }\n\n  connectedCallback(): void {\n    this.button = this.shadowRoot!.querySelector('button') as HTMLButtonElement;\n    this.button.addEventListener('click', () => this.toggle());\n\n    if (this.#buttonStyle) {\n      this.button.style = this.#buttonStyle;\n    }\n    document.addEventListener('click', e => {\n      if (\n        !this.contains(e.target as Node) &&\n        !this.shadowRoot!.contains(e.target as Node)\n      ) {\n        this.close();\n      }\n    });\n\n    this.button.addEventListener('keydown', (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        this.close();\n        this.button.focus();\n      }\n    });\n\n    // Listen for selection from child items\n    this.addEventListener('item-selected', (e: Event) => {\n      const customEvent = e as CustomEvent<{ value: string }>;\n      this.dispatchEvent(\n        new CustomEvent('select', {\n          detail: { value: customEvent.detail.value },\n          bubbles: true,\n          composed: true,\n        })\n      );\n      this.close();\n    });\n  }\n\n  static get observedAttributes() {\n    return ['button-style'];\n  }\n\n  attributeChangedCallback(name: string, oldVal: string, newVal: string) {\n    if (name === 'button-style') {\n      if (this.button) {\n        this.button.style = newVal;\n      } else {\n        this.#buttonStyle = newVal;\n      }\n    }\n  }\n\n  private toggle(): void {\n    const isOpen = this.classList.toggle('open');\n    this.button.setAttribute('aria-expanded', String(isOpen));\n  }\n\n  private close(): void {\n    this.classList.remove('open');\n    this.button.setAttribute('aria-expanded', 'false');\n  }\n}\n\ncustomElements.define('dropdown-menu', DropdownMenu);\n","class DropdownMenuItem extends HTMLElement {\n  static get observedAttributes() {\n    return ['value'];\n  }\n\n  value: string = '';\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot!.innerHTML = `\n      <style>\n        li {\n          list-style: none;\n          padding: 12px 40px 12px 20px;\n          color: White;\n          text-decoration: none;\n          white-space: nowrap;\n          background: transparent;\n          cursor: pointer;\n        }\n        li:hover {\n          background: rgba(255,255,255,.1);\n        }\n        span:not(:empty) {\n          float: left; \n          margin-right: .5em;\n          position: relative;\n          left: -4px;\n          top: 1px;\n        }\n      </style>\n      <li role=\"menuitem\">\n        <span id=\"icon\"><slot name=\"icon\"></span>\n        <slot></slot>\n      </li>\n    `;\n  }\n\n  connectedCallback(): void {\n    const item = this.shadowRoot!.querySelector('li')!;\n    item.addEventListener('click', e => {\n      e.preventDefault();\n      this.dispatchEvent(\n        new CustomEvent('item-selected', {\n          detail: { value: this.value },\n          bubbles: true,\n          composed: true,\n        })\n      );\n    });\n  }\n\n  attributeChangedCallback(name: string, _oldValue: string, newValue: string) {\n    if (name === 'value') {\n      this.value = newValue;\n    }\n  }\n}\n\ncustomElements.define('dropdown-menu-item', DropdownMenuItem);\n","import * as styles from 'bundle-text:./dialog.css';\nimport type ConfirmDialog from './ConfirmDialog';\n\nconst sheet = new CSSStyleSheet();\nsheet.replaceSync(String(styles));\n\nexport default class InputDialog extends HTMLElement {\n  private dialog: ConfirmDialog;\n  private input: HTMLInputElement;\n\n  static get observedAttributes() {\n    return ['title', 'description', 'value', 'submit', 'cancel', 'type'];\n  }\n\n  constructor() {\n    super();\n\n    const shadow = this.attachShadow({ mode: 'open' });\n\n    shadow.adoptedStyleSheets = [sheet];\n    this.shadowRoot!.innerHTML = `\n      <confirm-dialog>\n        <input\n            type=\"text\"\n            class=\"dialog-input\"\n            name=\"patternName\"\n            required\n          />\n      </confirm-dialog>\n    `;\n\n    this.dialog = shadow.querySelector('confirm-dialog')!;\n    this.input = shadow.querySelector('input')!;\n    this.input.addEventListener('keypress', e => {\n      if (e.code === 'Enter') {\n        this.dialog.submit();\n      }\n    });\n  }\n\n  connectedCallback() {\n    this.syncAttributes();\n  }\n\n  attributeChangedCallback() {\n    this.syncAttributes();\n  }\n\n  private syncAttributes() {\n    InputDialog.observedAttributes\n      .filter(attr => attr !== 'value')\n      .forEach(attr => {\n        if (this.hasAttribute(attr)) {\n          this.dialog.setAttribute(attr, this.getAttribute(attr));\n        } else {\n          this.dialog.removeAttribute(attr);\n        }\n      });\n\n    if (this.hasAttribute('value')) {\n      this.input.value = this.getAttribute('value') || '';\n    }\n  }\n\n  /**\n   * Opens the dialog, optionally with an initial value.\n   */\n  show(initialValue?: string): Promise<string | null> {\n    if (initialValue !== undefined) {\n      this.input.value = initialValue;\n    } else if (this.hasAttribute('value')) {\n      this.input.value = this.getAttribute('value') || '';\n    }\n    this.input.select();\n    return this.dialog.show().then(() => this.input.value);\n  }\n\n  /**\n   * Gets the value entered by the user if submitted,\n   * or null if canceled.\n   */\n  getValue(): string | null {\n    return this.input.value;\n  }\n}\n\ncustomElements.define('input-dialog', InputDialog);\n","module.exports = \"72349662a41355c1\";","import * as styles from 'bundle-text:./dialog.css';\n\nconst sheet = new CSSStyleSheet();\nsheet.replaceSync(String(styles));\n\nexport type ConfirmDialogType = 'default' | 'error';\n\nexport default class ConfirmDialog extends HTMLElement {\n  private dialog: HTMLDialogElement;\n  private cancelBtn: HTMLButtonElement;\n  private submitBtn: HTMLButtonElement;\n  private titleEl: HTMLElement;\n  private descEl: HTMLElement;\n\n  static get observedAttributes() {\n    return ['title', 'description', 'submit', 'cance', 'type'];\n  }\n\n  constructor() {\n    super();\n\n    const shadow = this.attachShadow({ mode: 'open' });\n\n    shadow.adoptedStyleSheets = [sheet];\n    this.shadowRoot!.innerHTML = `\n      <dialog>\n        <form method=\"dialog\">\n          <h2 class=\"dialog-title\"></h2>\n          <p class=\"dialog-desc\"></p>\n          <div id=\"dialog_contents\">\n            <slot></slot>\n          </div>\n          <menu class=\"dialog-menu\">\n            <button type=\"button\" class=\"btn-cancel\">Cancel</button>\n            <button type=\"submit\" value=\"confirm\" class=\"btn-submit\"></button>\n          </menu>\n        </form>\n      </dialog>\n    `;\n\n    this.dialog = shadow.querySelector('dialog')!;\n    this.cancelBtn = shadow.querySelector('.btn-cancel')!;\n    this.submitBtn = shadow.querySelector('.btn-submit')!;\n    this.titleEl = shadow.querySelector('.dialog-title')!;\n    this.descEl = shadow.querySelector('.dialog-desc')!;\n  }\n\n  connectedCallback() {\n    this.cancelBtn.addEventListener('click', () => {\n      this.dialog.returnValue = '';\n      this.dialog.close();\n    });\n\n    // Initialize attributes on first connect\n    this.syncAttributes();\n  }\n\n  attributeChangedCallback() {\n    this.syncAttributes();\n  }\n\n  private syncAttributes() {\n    if (this.hasAttribute('title')) {\n      this.titleEl.textContent = this.getAttribute('title');\n    }\n    if (this.hasAttribute('description')) {\n      this.descEl.textContent = this.getAttribute('description');\n    }\n    this.submitBtn.textContent = this.getAttribute('submit') || 'Submit';\n    this.cancelBtn.textContent = this.getAttribute('cancel') || 'Cancel';\n\n    if (this.hasAttribute('type') && this.getAttribute('type') === 'error') {\n      this.dialog.classList.add('error');\n    } else {\n      this.dialog.classList.remove('error');\n    }\n  }\n\n  /**\n   * Opens the dialog, optionally with an initial value.\n   */\n  show(): Promise<void> {\n    this.dialog.showModal();\n    return new Promise((resolve, reject) => {\n      const handleClose = () => {\n        this.dialog.removeEventListener('close', handleClose);\n        if (this.dialog.returnValue === 'confirm') {\n          resolve();\n        } else {\n          reject();\n        }\n      };\n      this.dialog.addEventListener('close', handleClose);\n    });\n  }\n\n  submit() {\n    this.submitBtn.click();\n  }\n}\n\ncustomElements.define('confirm-dialog', ConfirmDialog);\n","module.exports = \"6724f4af4f91cfc4\";"],"names":["$da037f8140467741$var$inputTimeout","$1ccc8d3c866b7484$var$currentRenderer","$b103c63dc979d40c$export$596571ef134d4065","controlsConfig","parent","index","control","children","$b103c63dc979d40c$export$2d97e2da46663803","controlConfig","attributeName","attr","attrCopy","$b103c63dc979d40c$export$68091c7c829a57b8","map","copy","$b103c63dc979d40c$export$c4f94c8b3850a5a9","insertAfterKey","controlsConfigToInsert","configCopy","nodeToAddAfter","$b103c63dc979d40c$var$getControlConfigNodeByKey","controlKey","findFn","key","node","list","splice","$9e482fa80a49eb9a$export$2e2bcd8739ae039","label","defaultValue","type","min","max","step","show","isMultiColor","colorthumb","start","multicolorStart","snap","thumbcolor","minLightness","background","multicolorByLightness","maxLightness","repeatColors","$44d9dab6555abf73$export$2e2bcd8739ae039","config","multiColorStep","multiColorLightnessStep","colors","multicolorRange","colorCount","darkMode","saturation","reverseColors","mirrorColors","Math","Array","fill","_","colorIndex","lightness","_firstColor","restColors","pop","reverse","getColor","color","length","getOppositeColor","hslColor","hslMatch","match","oppositeHue","Number","getColorMap","stepCount","Error","stepsPerColor","floor","colorMap","Map","i","set","getConfig","include","exclude","defaults","customControls","propMapper","groupLabel","maxColorCount","$b103c63dc979d40c$export$d9fe7d5b8b296e7c","controlPropMapper","getControls","filter","includes","finalControl","Object","freeze","$557ca0c92a954a23$var$DEFAULT_OPTIONS","fontSize","radius","renderNumbers","margin","$557ca0c92a954a23$export$2e2bcd8739ae039","nailRadius","nailsColor","nailNumbersFontSize","nails","addedPoints","setConfig","Set","clear","addNail","nail","nailPoint","point","round","join","has","push","add","addGroup","options","renderer","renderNails","draw","drawNumbers","forEach","groupNails","groupConfig","$a64bacef9e98af6b$var$COMMON_CONFIG_CONTROLS","isDisabled","showNails","showStrings","displayValue","showNailNumbers","enableBackground","customBackgroundColor","$a64bacef9e98af6b$export$2e2bcd8739ae039","controls","defaultValues","size","center","position","stringsIterator","id","name","link","linkText","thumbnailConfig","getCommonControls","configControls","concat","controlsIndex","configIndex","isTemplate","defaultConfig","assign","Function","value","assignConfig","currentConfig","onConfigChange","changedControlKeys","keys","resetStructure","some","isStructural","affectsStepCount","onResize","setConfigValue","getSize","setUpDraw","previousSize","reset","width","height","setLineWidth","stringWidth","afterDraw","drawNails","initDraw","backgroundColor","setBackground","Infinity","generateStrings","drawNext","done","goto","result","next","$6e85582323150d4b$var$easing","linear","x","inOutCirc","sqrt","pow","easeOutQuint","fastSlowFast","t","cos","PI","fastInOutSquare","fastInOutCubic","fastInOutQuint","fastInOut","fastInOutFixed","fastArea","y1","y2","requirePower","requireFastArea","$e2b746416d2bf62b$export$f4644083ce95e7e3","$c29d66861308df7e$export$f05027632b38f3a4","obj1","obj2","props","p","$dd4af12b0f1337d9$export$2e2bcd8739ae039","points","easingFunction","xyRadius","rotationAngle","indexAngle","isReverse","arc","isPartialArc","excludedNailIndexes","getPoint","realIndex","getNailIndex","get","angle","n","angleStart","sin","rotation","configCenter","angleEnd","v","clampedRadius","distortion","size1","size2","ratio","abs","displacementFunc","easingParams","displacementMag","displacementFastArea","easingFunctionWithParams","bind","generateNails","nailsNumberStart","getNumber","excludedNailRanges","end","j","number","arr","restProps","drawRing","ringSize","prevPoint","ringDistance","prevPointIndex","isPrevSide","setColor","startPoint","positions","renderLines","rotationConfig","nailsConfig","displacementConfig","distortionConfig","$44064e6908c034c2$var$COLOR_CONFIG","$44064e6908c034c2$export$2e2bcd8739ae039","innerLength","repetition","circleConfig","getStepCount","drawSpiral","shift","currentInnerLength","repetitionCount","isPrevPoint","stepColor","nextPoint","$63660c6a2fc9a003$var$Spirals","calc","getCalc","nSpirals","radiusIncrease","angleStep","maxRadius","spiralRotations","nailsPerSpiral","angleIncrease","generatePoints","s","nailNumber","spiralIndex","centerx","centery","lastPoint","$ad2ceb60c48a58dd$export$2e2bcd8739ae039","circle","nConfig","layers","layerFill","stringsPerLayer","layerShift","base","drawTimesTable","layerIndex","toIndex","layer","$96d8651f67c6b219$export$f481ea230fad194b","$33e9badd1f194d7c$export$2e2bcd8739ae039","layerSpread","$aa2c32cdcace5ae2$var$SIDES","$aa2c32cdcace5ae2$var$SIDES_ORDER","$aa2c32cdcace5ae2$var$SIDES_ROTATION","left","bottom","right","top","$aa2c32cdcace5ae2$var$Eye","maxSize","nailSpacing","layerAngle","getLayerProps","layerSize","layerStart","layerStringCount","theta","pivot","cosAngle","sinAngle","drawSide","side","sideIndex","indexOf","nextSide","nextSideRotation","sideProps","drawLayer","colorPerLayer","count","$2e2273f8da969026$export$2e2bcd8739ae039","sides","sideNails","centerRadius","centerRadiusFraction","maxCurveSize","sidesAngle","sideAngle","linesPerRound","sidesConnectionCount","sideSize","sinSideAngle","cosSideAngle","reverseOrder","sideNailsConfig","minNailIndex","alternate","rounds","ceil","isLastRound","isOdd","sidesConfig","description","centerRadiusConfig","StarConfig","$ca4a2eb6736370e4$export$2e2bcd8739ae039","starConfig","getArcPoint","drawStar","innerColor","drawCircle","outerColor","isStar","linesPerThisRound","pointPosition","ringColor","circleRounds","circleCount","$8db9d587e082a0d9$var$LAYER_DEFAULTS","$8db9d587e082a0d9$export$2e2bcd8739ae039","lineSpacing","lineNailCount","firstCirclePoint","totalNailCount","getLayer","call","enable","totalIndexCount","endIndex","indexLength","linePosition","circleIndex","self","advance","getPointIndex","reduce","$1530a0f3e43122ac$var$rotationConfig","$1530a0f3e43122ac$export$2e2bcd8739ae039","show1","rotation1","show2","rotation2","show3","rotation3","minNailDistance","maxShapeNailsCount","prop","circleNails","circumsference","prevCirclePoint","nextLayerIndex","$b43fc0eaa10ef4c7$export$2e2bcd8739ae039","fitSize","sizeAndCenter","configSize","boundingRect","getBoundingRect","scale","sideCount","nailsSpacing","radiusAngle","nailsDistance","radiusNailsCount","nailsPerSide","radiusNailsDistance","getSidePoint","pointsMapIndex","startX","getCenterPoint","firstPoint","slice","y","drawCenter","drawSides","filterCenterNails","sideIndexStart","$3f55ac726d5ebe61$var$COLOR_CONFIG","$3f55ac726d5ebe61$export$2e2bcd8739ae039","polygonConfig","bezier","limitedBezier","$7e0f39c01d255ee0$var$COLOR_CONFIG","$7e0f39c01d255ee0$export$2e2bcd8739ae039","layerAngleShift","polygon","leftSide","centerIndexes","getCenterIndexes","extraNailCount","firstNailIndex","$5498d6506310c764$var$COLOR_CONFIG","$5498d6506310c764$export$2e2bcd8739ae039","maxSteps","angleRadians","currentSize","k","r","angleGcd","$e2b746416d2bf62b$export$f81847884871263e","int1","int2","steps","$7a74ed27f7260395$var$COLOR_CONFIG","$7a74ed27f7260395$var$ANGLE","$7a74ed27f7260395$var$SIDE_ANGLES","$cfcb4d6877bfaba2$var$spreadModes","evenly","f","distance","layerDistance","firstLayerDistance","$cfcb4d6877bfaba2$var$COLOR_CONFIG","$cfcb4d6877bfaba2$export$2e2bcd8739ae039","entries","realColorCount","getLayerRingDistance","spread","getLayerRingStepCount","layerRingDistance","pointIndex","totalStepCount","$47fd6f35b394300f$export$2e2bcd8739ae039","starRadius","backdropSize","backdropRadius","backdropShift","toFixed","toUpperCase","backdropIsMultiColor","backdropMulticolorStart","backdropColorCount","backdropNailsColor","backdropNailsRadius","backdropNails","backdropRadiusConfig","starRadiusConfig","obj","mapper","mappedObj","toLowerCase","generateLayers","drawBackdrop","backdropSkip","shouldSkip","currentSide","currentSideIndex","backdropPoint","direction","circleNail","$54d330e2d674b207$export$2e2bcd8739ae039","renderCenter","$54d330e2d674b207$var$getSectionCountToRemove","removeSections","density","fit","centerRadiusPercent","densityNailCount","fixNailsCount","baseCircleConfig","petalSectionsToRemove","maxPetalSectionsToRemove","topSectionHeight","fitAspectRatio","removeSectionsNailCount","helperCircle","circles","circleNailsCount","sections","$54d330e2d674b207$var$getSectionsCount","removedSections","nailsPerSection","nailsPerCircle","lastSection","maxCenterRadiusPoint","centerCircleRadius","centerCircle","nailsCount","fullCircleNailCount","sectionsToRemove","radialColor","section","prevCircle","connectPoint","isLastSection","firstCircle","firstCircleStart","startIndex","renderCenterNails","innerSectionNailsStart","$3eff4f8917d513a6$var$patternTypes","globalRotation","renderRing","ringPadding","renderTriangles","levels","renderCaps","ringNailCount","globalRotationRadians","ringWidth","edgeSize","nailsLength","countPerLevelSide","level","triangleHeight","triangleCenterDistance","nailDistance","triangleCount","colorPerLevel","getPoints","getTrianglePoints","isCapLevel","triangleIndexInSide","missingSide","trianglePoints","triangleSidePoints","nNailDistance","largeDistance","smallDistance","levelsPoints","levelsCount","levelTrianglesPoints","levelSideTriangleCount","levelPositions","isFlipped","trianglePosition","atan","distanceFromCenter","sideRotation","triangleCenterAngle","rotatedTrianglePosition","generateTriangleStrings","indexInSide","initialSide","lastSide","lastIndex","isNextSide","nextSidePoint","targetSide","generateStringsBetweenTriangles","triangle1","triangle2","triangleIndex","isNextLevel","fillColor","levelSideCount","angleShift","isLastTriangleInSide","triangle1Points","triangle2Points","generateOrderInSide","t1Side","t2Side","getNextTriangleSide","last","triangleLevels","levelIndex","lastIndexInLevel","triangle","nextLevelTriangleIndex","fillStepsPerTriangle","levelsWithFillBetween","triangleSteps","triangleSide","$644cb43818f0710b$export$2e2bcd8739ae039","HTMLElement","formAssociated","internals","colorThumb","attachShadow","mode","delegatesFocus","shadowRoot","innerHTML","querySelector","attachInternals","observedAttributes","attributeChangedCallback","oldVal","newVal","parseInt","connectedCallback","hasAttribute","getAttribute","addEventListener","e","setFormValue","String","dispatchEvent","CustomEvent","detail","disconnectedCallback","focus","blur","setAttribute","thumbColor","customElements","define","$afb5e8cb2003dfda$var$TICK_COLOR","$afb5e8cb2003dfda$export$2e2bcd8739ae039","getTickValues","snappedValue","getClosestTick","ResizeObserver","entry","contentRect","observe","handleInput","handleKeydown","tabIndex","unobserve","ticks","ticksMatch","isNaN","sort","newValue","closestTick","distanceFromTick","value1","value2","event","preventDefault","find","undefined","prev","reversed","bubbles","composed","tickValue","navigator","vibrate","inputWidth","clientWidth","valueInRange","range","availableWidth","valueWidth","$afb5e8cb2003dfda$var$THUMB_RADIUS","tickPositions","$afb5e8cb2003dfda$var$TICK_WIDTH","tickPositionsInGradient","ticksBackground","styles","$da037f8140467741$var$elements","document","controlsPanel","sidebarForm","$da037f8140467741$var$EVENTS","$da037f8140467741$var$STATE_LOCAL_STORAGE_KEY","$da037f8140467741$export$2e2bcd8739ae039","state","eventHandlers","controlElements","_getState","groups","input","change","renderControls","destroy","removeEventListener","target","nodeName","parentElement","classList","toggle","groupId","dataset","group","contains","_updateState","eventHandler","_triggerEvent","eventData","selection","window","getSelection","removeAllRanges","$da037f8140467741$var$isRangeInput","setTimeout","body","clearTimeout","HTMLInputElement","HTMLSelectElement","updateInput","inputElement","originalEvent","deferChange","updateControlDisplayValue","displayValueElement","innerText","inputValue","$da037f8140467741$var$getInputValue","parseFloat","checked","replace","triggerChange","updateControlsVisibility","updateControlsAttributes","localStorage","getItem","JSON","parse","newState","setItem","stringify","removeItem","functionAttrs","inputEl","attributeValueFn","newAttrValue","getConfigValue","updateTimeout","shouldShowControl","controlEl","element","removeAttribute","shouldDisableControl","containerEl","_controlsConfig","indexStart","controlsFragment","createDocumentFragment","controlIndex","controlId","createElement","groupTitleEl","appendChild","className","childrenContainer","$da037f8140467741$var$getElementTagNameForControlType","controlType","selectOptions","_option","optionEl","realValue","updateGroupsState","requestAnimationFrame","querySelectorAll","groupEl","HTMLFieldSetElement","groupState","remove","valueOrFn","$fb81eeeade2a45e9$var$sizeControls","$fb81eeeade2a45e9$var$elements","sizeSelect","sizeCustom","orientationSelect","$fb81eeeade2a45e9$var$cmToPixels","cm","dpi","$fb81eeeade2a45e9$var$SCREEN_SIZE","screen","$fb81eeeade2a45e9$var$SIZES","$fb81eeeade2a45e9$export$2e2bcd8739ae039","getCurrentSize","sizeOptionsFragment","sizeListItem","selectedSize","selectedSizeId","_notifyOnChange","getValue","select","from","$9936be7d63e3034a$export$2e2bcd8739ae039","getBoundingClientRect","setSize","style","$d45f09bc4feaf860$export$2e2bcd8739ae039","canvas","ctx","pixelRatio","getContext","dpr","devicePixelRatio","globalCompositeOperation","clearRect","strokeStyle","lineWidth","fillStyle","fillRect","clientHeight","startPosition","beginPath","moveTo","lineTo","stroke","centerX","textBaseline","font","nailNumberOffset","isRightAlign","numberPosition","textAlign","fillText","toDataURL","$00df09d341073864$export$2e2bcd8739ae039","handler","handlers","emit","payload","$174f2c93f6348ee5$var$promptDialogId","$174f2c93f6348ee5$export$195ba6d62321b933","dialog","$174f2c93f6348ee5$var$CONFIRM_DIALOG_ID","$174f2c93f6348ee5$export$715f9d76bb8c1fea","$00643d12b3a54506$var$APP_DATA_STORAGE_KEY","$00643d12b3a54506$export$2e2bcd8739ae039","elements","currentPattern","saveDialog","deletePattern","saveCurrentPattern","renameCurrentPattern","nextId","defaultName","title","submit","then","patternName","saveNewPattern","setPattern","pattern","patternDataToStringArt","patternType","patternData","Pattern","getSavedPatterns","patterns","loadAppData","getPatternByID","patternId","loadPatternDataById","appData","lastId","newPatternData","saveAppData","savePattern","patternIndex","findIndex","newPatternName","rawData","error","message","$8a4d6517fbd25a59$var$MINIMIZED_CLASS","$8a4d6517fbd25a59$export$45b50bca1da1e9b3","root","thumbnails","toggleBtn","dropdown","thumbnailsRendered","_onClickOutside","persistance","isOpen","createThumbnails","setCurrentPattern","thumbnail","stopPropagation","closest","close","open","sectionTitle","thumbnailsList","thumbnailsFragment","patternLink","li","href","savedPatterns","PatternType","$d8f8628a77747326$var$numberRegExp","$d8f8628a77747326$var$booleanRegExp","$38bb4a85553a6bfc$export$ed80d9de1d9df928","share","$38bb4a85553a6bfc$var$getShareData","alert","$38bb4a85553a6bfc$export$4fa6f570da04f7cc","shareData","canShare","dataUrl","blob","fetch","files","File","lastModified","Date","getTime","url","location","text","$718de5d870731526$export$d594efb518b3cec4","serviceWorker","hostname","registration","register","onupdatefound","installingWorker","installing","onstatechange","controller","console","log","$3ff5c6d6cb93edd9$var$SVG_NS","$3ff5c6d6cb93edd9$export$2e2bcd8739ae039","svg","backgroundGroup","linesGroup","nailsGroup","nailsCirclesGroup","nailsTextGroup","currentColor","currentLineGroup","createElementNS","setProperty","trunc","setAttributeNS","childNodes","SVGGElement","previousPoint","fragment","line","circlesFragment","textFragment","textEl","$b7266296a7c0118e$export$bb3b75778e3e272","fileName","downloadLink","download","click","removeChild","$f4729f31dd8a035c$export$e44a253a59704894","button","customEvent","$0096ec60fce19dcf$var$DropdownMenuItem","item","_oldValue","$eb971f7ae22dc5e1$exports","$34a1caf943752901$var$sheet","CSSStyleSheet","replaceSync","$34a1caf943752901$export$2e2bcd8739ae039","shadow","adoptedStyleSheets","code","syncAttributes","initialValue","$7a37a3caedf4d681$exports","$1b7158181746ebe4$var$sheet","$1b7158181746ebe4$export$2e2bcd8739ae039","cancelBtn","submitBtn","titleEl","descEl","returnValue","textContent","showModal","Promise","resolve","reject","handleClose","$1ccc8d3c866b7484$var$elements","main","downloadBtn","downloadSVGBtn","downloadNailsBtn","resetBtn","shareBtn","playerBtn","buttons","instructionsLink","$1ccc8d3c866b7484$var$player","stringArt","parentEl","player","playerPosition","playBtn","pauseBtn","play","pause","updateStatus","isPlaying","update","removeProperty","updateStringArt","updatePosition","setInstructions","instructions","cancelAnimationFrame","$1ccc8d3c866b7484$var$sizeControls","$1ccc8d3c866b7484$var$persistance","$1ccc8d3c866b7484$var$thumbnails","$1ccc8d3c866b7484$var$main","updateState","$1ccc8d3c866b7484$var$hide","$1ccc8d3c866b7484$var$unHide","queryParams","URLSearchParams","search","history","queryPattern","findPatternById","selectPattern","serializedCofig","serializedConfigValues","commaCount","split","test","booleanMatch","configKeys","serializedValue","unselectPattern","initPattern","downloadCanvas","downloadNailsImage","showShare","onInputsChange","configQuery","nonDefaultConfigValues","replaceState","encodeURIComponent","setIsDefaultConfig","isDefaultConfig","setPatternOptions","pushState","isFirstTime","svgRenderer","svgPattern","svgBlob","Blob","outerHTML","URL","createObjectURL","deltaY","dialogId","toggleFor","btn","toggledElement","templatePattern"],"version":3,"file":"string_art.07585b46.js.map"}